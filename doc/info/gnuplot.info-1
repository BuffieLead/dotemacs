Info file: gnuplot.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnuplot-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.



INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* GNUPLOT: (gnuplot).             An Interactive Plotting Program
END-INFO-DIR-ENTRY




File: gnuplot.info, Node: Top, Next: gnuplot, Prev: (dir), Up: (dir)

Master Menu
***********

                            GNUPLOT

                 An Interactive Plotting Program
                  Thomas Williams & Colin Kelley
                     Version 4.6 organized by:
         Hans-Bernhard Broeker, Ethan A Merritt, and others

        Copyright (C) 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
                Copyright (C) 2004 - 2011  various authors

            Mailing list for comments: gnuplot-info@lists.sourceforge.net
          Mailing list for bug reports: gnuplot-bugs@lists.sourceforge.net

              This manual was originally prepared by Dick Crawford
                        Version 4.6 - December 2011


     Major contributors (alphabetic order):


* Menu:

* gnuplot::
* 描画スタイル_(plotting_styles)::
* コマンド_(Commands)::
* 出力形式_(Terminal)::
* バグ_(Bugs)::
* Concept_Index::
* Command_Index::
* Options_Index::
* Function_Index::
* Terminal_Index::



File: gnuplot.info, Node: gnuplot, Next: 描画スタイル_(plotting_styles), Prev: Top, Up: Top

gnuplot
*******



* Menu:

* 著作権_(Copyright)::
* はじめに_(Introduction)::
* 探し出す手助け_(Seeking-assistance)::
* 新しい機能_(New_features)::
* 後方互換性_(Backwards_compatibility)::
* バッチ/対話型操作_(Batch/Interactive)::
* キャンバスサイズ_(Canvas_size)::
* コマンドライン編集_(Command-line-editing)::
* コメント_(Comments)::
* 座標系_(Coordinates)::
* 文字列データ_(Datastrings)::
* 拡張文字列処理モード_(Enhanced_text_mode)::
* 環境変数_(Environment)::
* 式_(Expressions)::
* フォント::
* ヘルプの用語解説_(Glossary)::
* 線種、色、スタイル_(linetypes)::
* マウス入力_(mouse_input)::
* 描画_(Plotting)::
* 初期化_(Startup_(initialization))::
* 文字列定数と文字列変数_(Strings)::
* 置換とコマンドラインマクロ_(Substitution)::
* 区切りやカッコの使い方_(Syntax)::
* 時間/日付データ_(Time/Date)::



File: gnuplot.info, Node: 著作権_(Copyright), Next: はじめに_(Introduction), Prev: gnuplot, Up: gnuplot

著作権 (Copyright)
==================



         Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley


Permission to use, copy, and distribute this software and its
documentation for any purpose with or without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

Permission to modify the software is granted, but not the right to
distribute the complete modified source code.  Modifications are to be
distributed as patches to the released version.  Permission to
distribute binaries produced by compiling modified sources is granted,
provided you
       1. distribute the corresponding source modifications from the
        released version in the form of a patch file along with the binaries,
       2. add special version identification to distinguish your version
        in addition to the base release version number,
       3. provide your name and address as the primary contact for the
        support of your modified version, and
       4. retain our contact information in regard to use of the base
        software.

Permission to distribute the released version of the source code along
with corresponding source modifications in the form of a patch file is
granted with same provisions 2 through 4 for binary distributions.

This software is provided "as is" without express or implied warranty
to the extent permitted by applicable law.


           AUTHORS


           Original Software:
              Thomas Williams,  Colin Kelley.


           Gnuplot 2.0 additions:
              Russell Lang, Dave Kotz, John Campbell.


           Gnuplot 3.0 additions:
              Gershon Elber and many others.



           Gnuplot 4.0 additions:
              See list of contributors at head of this document.


(以下おおまかな訳; 訳は正しくないかも知れませんので詳しくは上記の原文を
当たってください。訳者は責任を持ちません。)

         Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley


このソフトウェアとその付属文書の使用、複製、配布の許可は、上記の著作権
(copyright) 表示が、全ての複製物に書かれていること、および著作権表示と
この許諾文の両方がその支援文書に書かれていることを条件とした上で、この
文書により保証されます。

このソフトウェアの修正も認められています。しかし、修正を含む全ソースコー
ドの配布の権利は認められません。修正はリリース版に対するパッチの形で配
布しなければなりません。修正されたソースをコンパイルして作られたバイナ
リの配布は、以下の条件の元で認められます:
       1. リリース版からのソースの修正部分を、パッチの形でバイナリと共に配
          布すること
       2. ベースとなるリリース版と区別するために、そのバージョン番号に特別
          なバージョン指定子を付加すること
       3. その修正版のサポート用に、あなたの名前とアクセス可能なアドレスと
          を提供すること
       4. ベースとなるソフトウェアの使用に関しては、我々の連絡情報を保持し
          続けること

リリース版のソースコードを、パッチの形でのソースの修正と一緒に配布する
ことは、バイナリ配布に関する条項 2 から 4 までの条件の元で許されます。

このソフトウェアは "あるがまま" 提供され、適用可能な法律で許められる範
囲の保証を表明あるいは暗示していはいません。


           著者


           オリジナルソフトウェア:
              Thomas Williams,  Colin Kelley.


           Gnuplot 2.0 追加:
              Russell Lang, Dave Kotz, John Campbell.


           Gnuplot 3.0 追加:
              Gershon Elber とその他の人々。


           Gnuplot 4.0 追加:
              この文書の最初にある寄与者 (contributors) のリスト参照。




File: gnuplot.info, Node: はじめに_(Introduction), Next: 探し出す手助け_(Seeking-assistance), Prev: 著作権_(Copyright), Up: gnuplot

はじめに (Introduction)
=======================


`gnuplot` は、ポータブルなコマンド入力方式のグラフユーティリティで、
Linux, OS/2, MS Windows, OSX, VMS, その他多くのプラットホーム上で動作し
ます。ソースコードには著作権がありますが、無料で配布されています (すな
わち、それに対価を支払う必要はありません)。元は、科学者や学生が数学関数
やデータなどを対話的に表示できるよう作られたのですが、現在までに、例え
ば Web スクリプトなど、多くの非対話型の利用もサポートするように成長して
います。これは、例えば Octave のようにサードパーティのアプリケーション
の描画エンジンとしても使われています。gnuplot は、1986 よりサポートと活
発な開発が行われています。

gnuplot は、2 次元、または 3 次元の、多くの種類のグラフをサポートしてい
ます: 折線グラフ、点グラフ、棒グラフ、等高線、ベクトル場描画、曲面、そ
してそれらに関連するさまざまな文字列等。そしてさらにいくつかの特別な描
画型もサポートしています。

gnuplot は多くの異なる出力をサポートしています: 対話型スクリーン出力形
式 (マウスやホットキー入力も可能)、ペンプロッタや現在のプリンタへの直接
出力、または多くのファイル形式への出力 (eps, emf, fig, jpeg, LaTeX,
pdf, png, postscript, ...)。gnuplot は、容易に新しい出力形式を追加する
よう拡張することができます。最近追加された対話型出力形式には、
wxWidgets (複数のプラットホームで利用可能), Qt を元にしたものがあります。
svg や HTML5 canvas 出力形式を利用すれば、グラフを Web ページ内にマウス
利用可能な形で埋め込んだ出力を生成することもできます。

`gnuplot` のコマンド言語は大文字小文字を区別します。すなわち、小文字で
書かれたコマンドや関数名は、それらを大文字で書いたものとは同じではあり
ません。いずれのコマンドも、あいまいさの無い限りにおいて省略することが
できます。1 行中にはセミコロン (;) で区切って複数のコマンドを書くことが
できます。文字列は単一引用符、あるいは二重引用符のどちらかで書き始めま
すが、両者には微妙な違いがあります (詳細は、以下参照: `syntax`)。例:

           load "filename"
           cd 'dir'


コマンドは、複数行にまたがることができます。その場合は、最終行以外の全
ての行の行末にバックスラッシュ (\) を書く必要があります。バックスラッシュ
は必ず各行 *最後* の文字でなくてはなりません。その結果としてバックスラッ
シュと、それに続く改行文字が存在しなかったかのように扱われます。つまり、
改行文字がスペースの役をすることもありませんし、改行によってコメントが
終了することもありません。ですから複数行にまたがる行の先頭をコメントア
ウトすると、そのコマンド全体がコメントアウトされることになります (以下
参照: `comments`)。なお注意しますが、もし、複数行のコマンドのどこかでエ
ラーが起きたとき、パーサはその場所を正確には指示することができませんし、
また、正しい行に指示する必要もないでしょう。

このドキュメントにおいて、中括弧 ({}) は省略可能な引数を表すものとし、
縦棒 (|) は、互いに排他的な引数を区切るものとします。`gnuplot` のキーワー
ドや *Note help:: における項目名は、バッククオート (｀) または可能な場
合には `boldface` (太字) で表します。角括弧 (<>) は、それに対応するもの
に置き換えられるべきものを表します。多くの場合、オプションの引数には、
それが省略されるとデフォルトの値が使用されます。しかし、これらの場合、
必ずしも角括弧が中括弧で囲まれて書かれているわけではありません。

ある項目についてのヘルプが必要なときには、*Note help:: に続けてその項目
名を入力して下さい。または単に `help ?` でもヘルプの項目のメニューが現
われます。

初めて `gnuplot` を使う方は、`plotting` に関する説明から読みはじめると
良いでしょう (対話型で使用中ならば `help plotting` と入力して下さい)。

simple.dem デモを参照してください。あるいは以下の Web ページにも他のデ
モと一緒にあります。http://www.gnuplot.info/demo/
(http://www.gnuplot.info/demo/) `gnuplot` はコマンドラインから、あるい
はデスクトップ環境のアイコンから起動することができます。コマンドライン
から起動するときは、以下の書式が使えます。
           gnuplot {OPTIONS} file1 file2 ...

ここで file1, file2 等は、`local` コマンドで取り込むのと同等の入力ファ
イル (スクリプトファイル) です。X11 ベースのシステムでは、以下の書式が
使えます。
           gnuplot {X11OPTIONS} {OPTIONS} file1 file2 ...

詳細は、X11 のドキュメント、および以下参照: `x11`。

gnuplot に与えるオプションは、コマンド行のどこに置いても構いません。ファ
イルは指定した順に実行され、同様に -e オプションで任意のコマンドを与え
ることもできます。例:
           gnuplot   file1.in   -e "reset"   file2.in


特別なファイル名 "-" は、標準入力から読ませるのに使います。`gnuplot`は
最後のファイルを処理し終わると終了します。読み込ませるファイルを一つも
指定しない場合は、`gnuplot` は標準入力からの対話入力を取ります。詳細は、
以下参照: `batch/interactive`。gnuplot 用のオプションについては、以下の
ようにして一覧を見ることができます:
           gnuplot --help

詳細は以下参照: `command line options`。

対話型描画ウィンドウでの作業中は、'h' を打つとホットキー (`hotkeys`)と
マウス機能 (`mousing`) に関するヘルプを見ることができます。
`seeking-assistance` のセクションは、さらなる情報やヘルプ、FAQ を探す手
掛りを与えてくれるでしょう。



File: gnuplot.info, Node: 探し出す手助け_(Seeking-assistance), Next: 新しい機能_(New_features), Prev: はじめに_(Introduction), Up: gnuplot

探し出す手助け (Seeking-assistance)
===================================





公式の gnuplot Web ページは以下にあります。http://www.gnuplot.info
(http://www.gnuplot.info)

助けを求める前に、ファイル FAQ.pdf か、または上の Web サイトのFAQ (度々
聞かれる質問; Frequently Asked Questions) の一覧
(http://www.gnuplot.info/faq/)をチェックしてください。

gnuplot ユーザとしての手助けが必要なら、以下のニュースグループを利用し
てください。
               comp.graphics.apps.gnuplot

私達はメーリングリストに参加するより、むしろニュースグループのメッセー
ジを読むことを勧めます。メーリングリストも有効で、同じメッセージ列を配
送しています。メーリングリストに参加する方法に関しては、SouceForge にあ
る gnuplot の開発 Web サイトhttp://sourceforge.net/projects/gnuplot
(http://sourceforge.net/projects/gnuplot)を参照してください。

メーリングリストメンバーへのメールアドレス:
               gnuplot-info@lists.sourceforge.net


バグリポート、ソースの改良等は以下の trackers に upload してください:
               http://sourceforge.net/projects/gnuplot/support

ただし、リポートを送る前に、あなたがリポートしようとしているバグが、よ
り新しい gnuplot で既に修正されていないかチェックしてください。

開発版に関するメーリングリスト:
               gnuplot-beta@lists.sourceforge.net


何か質問を投稿するときは、あなたが使用している gnuplot のバージョン、出
力形式、オペレーティングシステム、といった全ての情報を含むようにしてく
ださい。その問題を引き起こす「小さい」スクリプトがあればなお良いです。
その場合、データファイルのプロットよりも関数のプロットの方がより良いで
す。




File: gnuplot.info, Node: 新しい機能_(New_features), Next: 後方互換性_(Backwards_compatibility), Prev: 探し出す手助け_(Seeking-assistance), Up: gnuplot

新しい機能 (New features)
=========================


この節では、バージョン 4.4 以降に追加された主なものを紹介します。より網
羅的な一覧は、ファイル NEWS を参照してください。


* Menu:

* 新しい構文_(New_syntax)::
* 線種のカスタマイズ_(Local_customization_of_linetypes)::
* 新しい描画スタイル_(New_plot_styles)::
* 極座標軸の改良_(Revised_polar_axes)::
* 新しい平滑化アルゴリズム::
* 新しい日時_(time/date)_の取扱い::
* データの簡単な統計情報::
* 新しい/修正された出力形式::



File: gnuplot.info, Node: 新しい構文_(New_syntax), Next: 線種のカスタマイズ_(Local_customization_of_linetypes), Prev: 新しい機能_(New_features), Up: 新しい機能_(New_features)

新しい構文 (New syntax)
-----------------------

この版の gnuplot には、繰り返し (iteration) コマンドやブロック構造を扱
える if/else/while/do が導入されています。以下参照: `if`, `while`,
`do`。単純な繰り返しは、コマンド *Note plot::, `set` で利用できます。以
下参照: `iteration`。複数のコマンドを包含する一般的な繰り返しは、以下で
紹介するブロック構造を利用することで行えます。新しい機能に関連して、数
式型の以下も参照: `summation`。以下は、これらの新しい構文機能をいくつか
利用した例です:
           set multiplot layout 2,2
           fourier(k, x) = sin(3./2*k)/k * 2./3*cos(k*x)
           do for [power = 0:3] {
               TERMS = 10**power
               set title sprintf("%g term Fourier series",TERMS)
               plot 0.5 + sum [k=1:TERMS] fourier(k,x) notitle
           }
           unset multiplot


現在は、データファイルからのデータ列を、ファイルの 1 行目に書かれたラベ
ル名で選択することもできます。以下参照: *Note columnhead::。例:
           plot for [crop in "Oats Peas Beans"] 'data' using "Year":crop





File: gnuplot.info, Node: 線種のカスタマイズ_(Local_customization_of_linetypes), Next: 新しい描画スタイル_(New_plot_styles), Prev: 新しい構文_(New_syntax), Up: 新しい機能_(New_features)

線種のカスタマイズ (Local customization of linetypes)
-----------------------------------------------------

現在では、ユーザが描画に使用される線種の属性 (色、線幅、点の種類) のデ
フォルトの並びをカスタマイズできます。以下参照: `set linetype`。これは
通常、システム用の初期化ファイル `gnuplotrc` か個人的な初期化ファイル
`~/.gnuplot` のいずれかで行います。以下参照: `initialization`。

現在は多くの出力形式でグラフの背景色を明示的に設定できます。その色で描
画するのに、特別な線種 (linetype) `bgnd` が利用できます。以下参照:
`bgnd`。




File: gnuplot.info, Node: 新しい描画スタイル_(New_plot_styles), Next: 極座標軸の改良_(Revised_polar_axes), Prev: 線種のカスタマイズ_(Local_customization_of_linetypes), Up: 新しい機能_(New_features)

新しい描画スタイル (New plot styles)
------------------------------------

描画スタイルの節の以下参照: *Note boxplot::, *Note circles::, *Note ellipses::,
*Note fillsteps::。




File: gnuplot.info, Node: 極座標軸の改良_(Revised_polar_axes), Next: 新しい平滑化アルゴリズム, Prev: 新しい描画スタイル_(New_plot_styles), Up: 新しい機能_(New_features)

極座標軸の改良 (Revised polar axes)
-----------------------------------

極座標描画モードは、より多くの描画スタイルをサポートするように改良され
ました。極座標軸は、今では x, y 軸とは独立に描画、ラベル付けできます。
以下参照: *Note polar::, *Note rrange::。




File: gnuplot.info, Node: 新しい平滑化アルゴリズム, Next: 新しい日時_(time/date)_の取扱い, Prev: 極座標軸の改良_(Revised_polar_axes), Up: 新しい機能_(New_features)

新しい平滑化アルゴリズム
------------------------



2 次元、3 次元描画の両方に、新しい平滑化アルゴリズムが追加されていて、
滑らかなヒストグラムや累積分布関数の *Note plot:: による描画に、それぞ
れ`smooth kdensity` や `smooth cumulative` が使えます。*Note dgrid3d::
には、`splot` 用に新しい平滑化重み付け関数 (kernel) がいくつか追加され
ています。以下参照: *Note smooth::, *Note dgrid3d::。




File: gnuplot.info, Node: 新しい日時_(time/date)_の取扱い, Next: データの簡単な統計情報, Prev: 新しい平滑化アルゴリズム, Up: 新しい機能_(New_features)

新しい日時 (time/date) の取扱い
-------------------------------


現在の gnuplot は、時刻をミリ秒精度で追跡し、時刻のフォーマットもそれに
伴って変更されています。新しい組み込み関数 time() は、システム時計に従っ
た時刻を返します。例: 現在の時刻をミリ秒精度で表示
          print strftime("%H:%M:%.3S %d-%b-%Y",time(0.0))
          18:15:04.253 16-Apr-2011




File: gnuplot.info, Node: データの簡単な統計情報, Next: 新しい/修正された出力形式, Prev: 新しい日時_(time/date)_の取扱い, Up: 新しい機能_(New_features)

データの簡単な統計情報
----------------------

新しいコマンド `stats` は、*Note plot:: や `splot` と同じ書式でファイル
からデータを読み込みますが、グラフを描画するのではなく、これは、column
で指定されたデータ列の簡単な統計情報を出力します。出力するのは、最小値
(min)、最大値 (max)、標準偏差 (standard deviation)、相関 (correlation)
等で、そしてそれらの値をそれ以降の描画コマンドの構成、修正に利用できる
ように名前のついた変数に保存します。以下参照: `stats`。




File: gnuplot.info, Node: 新しい/修正された出力形式, Prev: データの簡単な統計情報, Up: 新しい機能_(New_features)

新しい/修正された出力形式
-------------------------

ドライバ `qt` は、Qt グラフィック階層の最上位に位置する対話型出力形式の
実装です。それは、フル装備のデスクトップ環境内の一つのウィンドウとして、
あるいは Qt ベースの埋め込みデバイス上のフルスクリーンアプリケーション
として機能します。`qt` 出力形式は新しく、まだある種の粗さがあります。

Web ベースの対話型表示をサポートする出力形式が 2 つあります。HTML5 の
`canvas` 出力形式は version 4.4 で導入されました。`svg` 出力形式は、マ
ウス操作に関して、および gnuplot からの svg 出力をより大きな svg/xml文
書によりよく埋め込めるように、大きく改良されています。

出力ドライバ `canvas` は、ウェブページの canvas 要素 HTML 中に描画する
javascript 出力を生成します。これは、一つの描画だけを含む完全なウェブペー
ジ、あるいは外部に生成された HTML ドキュメントの一部 (複数の描画を入れ
ることができる) として埋め込めるスクリプト、のいずれかを作成できます。
埋め込ませる描画は、拡大/縮小などの、ブラウザ側のマウス動作をサポートし
ています。

出力ドライバ `lua` は、lua プログラミング言語のスクリプトによってさらな
る処理が可能なデータを生成します。現時点では、そのようなスクリプトとし
ては gnuplot-tikz.lua のみが用意されていて、これは、latex TikZ パッケー
ジ用の出力を作成します。もちろん、他の TeX パッケージ用、あるいはTeX 以
外のツール用の gnuplot 出力を生成する lua スクリプトなどを作成すること
も可能でしょう。

`set term tikz` は、`set term lua tikz` の省略形です。上に書いたように
これは lua 出力形式と外部の lua スクリプトを使用して latex 文書を生成し
ます。

出力ドライバ `context` は、ConTeXt TeX マクロパッケージでさらに処理され
る出力を生成します。その出力の処理には、以下の ConTeXt 用の gnuplotモ
ジュールが必要です: http://ctan.org/pkg/context-gnuplot
(http://ctan.org/pkg/context-gnuplot)

出力形式 `epscairo` は、cairo と pango ライブラリを使用して EPS 出力
(Encapsulated PostScript) を生成します。これは、出力ドライバ
`postscript` とは別の EPS 出力方法となりますが、例えば出力形式`wxt` の
画面出力と同じ見た目の EPS ファイルが欲しいという人向きです。

出力形式 `cairolatex` は、出力形式 `pdfcairo` や `epscairo` の cairoに
よる後処理を使用して LaTeX 文書に取り込むためのグラフを生成します。これ
は、PDF か EPS グラフを生成しますが、テキスト文字列は、出力形式
`epslatex` と同じ方法で LaTeX に転送します。

出力ドライバ `windows` は、透明化、アンチエイリアス、バッファリング出力、
複数のグラフウィンドウ、グラフのクリップボードへのコピーやグラフのEMF
ファイルへの保存をサポートするよう改良されています。新しいオプションも
たくさんあり、ユーザーインターフェースも改良されています。さらに、長い
行の折りたたみをサポートするようにテキストコンソールのプログラムも大幅
に書き換えられています。ヘルプは、現在は HTML 形式のものを用意していま
す。




File: gnuplot.info, Node: 後方互換性_(Backwards_compatibility), Next: バッチ/対話型操作_(Batch/Interactive), Prev: 新しい機能_(New_features), Up: gnuplot

後方互換性 (Backwards compatibility)
====================================


以前の版で使われていたいくつかの書式は gnuplot 4.0 で非推奨となりました
が、それは今でも認識はされ続けています。これは現在コンパイル時に制御さ
れ、以下のようにして有効にできます:

           ./configure --enable-backwards-compatibility


注意: 非推奨の書式は、未来の gnuplot のある版で、完全に削除されてしまう
かもしれません。

一つの主な違いは、複雑なコマンド (特に文字列変数を含むコマンド) のあい
まいさを避けるようなキーワードの導入です。特に注意すべき点は、オフセッ
ト、線種、点種に対する生の数の使用でした。具体例:

非推奨:
           set title "Old" 0,-1
           set data linespoints
           plot 1 2 4               # horizontal line at y=1

新:
           TITLE = "New"
           set title TITLE offset char 0, char -1
           set style data linespoints
           plot 1 linetype 2 pointtype 4





File: gnuplot.info, Node: バッチ/対話型操作_(Batch/Interactive), Next: キャンバスサイズ_(Canvas_size), Prev: 後方互換性_(Backwards_compatibility), Up: gnuplot

バッチ/対話型操作 (Batch/Interactive)
=====================================


`gnuplot` は多くのシステム上で、バッチ処理形式、あるいは対話型のどちら
の形式でも実行でき、それらを組み合わせることも可能です。

コマンドライン引数は、プログラムへのオプション (文字 - で始まる) か、
`gnuplot` コマンドを含むファイルの名前であると解釈されます。
-e "command" の形式のオプションは、gnuplot コマンドを強制的に実行させ、
各ファイルとこのコマンド文字列は、指定された順に実行されます。特別なファ
イル名 "-" は、コマンドを標準入力から読み込むことを意味します。最後のファ
イルを実行した後に `gnuplot` は終了します。読み込ませるファイル、および
コマンド文字列を指定しなかった場合は、`gnuplot` は標準入力からの対話型
の入力を受け付けます。

*Note exit:: と *Note quit:: はどちらも現在のコマンドファイルを終了し、
まだ全てのファイルが終っていなければ、次のファイルを `load` するのに使
われます。

例:

対話を開始する:
           gnuplot


2 つのコマンドファイル "input1", "input2" を使ってバッチ処理を行なう:
           gnuplot input1 input2


初期化ファイル "header" の後、対話型モードを起動し、その後別のコマンド
ファイル "tailer" を実行する:
           gnuplot header - trailer


コマンドラインから `gnuplot` コマンドを直接与え、終了後にスクリーン上に
グラフが残るようにオプション "-persist" を使う:
            gnuplot -persist -e "set title 'Sine curve'; plot sin(x)"


ファイルのコマンドを実行する前に、ユーザ定義変数 a と s をセットする:
           gnuplot -e "a=2; s='file.png'" input.gpl





File: gnuplot.info, Node: キャンバスサイズ_(Canvas_size), Next: コマンドライン編集_(Command-line-editing), Prev: バッチ/対話型操作_(Batch/Interactive), Up: gnuplot

キャンバスサイズ (Canvas size)
==============================



gnuplot の以前の版では、*Note size:: の値を、出力する描画領域 (キャンバ
ス) のサイズを制御するのにも使っていた出力形式もありましたが、すべての
出力形式がそうだったわけではありませんでした。この目的のために*Note
size:: を使用することは version 4.2 で非推奨となり、version 4.4 以降は、
ほとんどの出力形式が以下のルールに従うようになりました:

`set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、ま
たは "キャンバス" のサイズを制御します。サイズパラメータの有効な値につ
いては、個々の出力形式のヘルプを参照してください。デフォルトでは、グラ
フはそのキャンバス全体に描画されます。

`set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
形式では問題が起こるかもしれないことに注意してください。

このルールに沿わない主な例外は PostScript ドライバで、デフォルトでは以
前の版のと同じ振舞いをします。gnuplot の次の版では、PostScript ドライバ
も同様にデフォルトの振舞いを変更することになるでしょう。

例:

           set size 0.5, 0.5
           set term png size 600, 400
           set output "figure.png"
           plot "data" with lines


このコマンドは、幅 600 ピクセル、高さ 400 ピクセルの出力ファイル
figure.png" を生成します。グラフはキャンバスの中の左下に置かれます。こ
れは、multiplot モードが常に行ってきた方法と矛盾しません。




File: gnuplot.info, Node: コマンドライン編集_(Command-line-editing), Next: コメント_(Comments), Prev: キャンバスサイズ_(Canvas_size), Up: gnuplot

コマンドライン編集 (Command-line-editing)
=========================================




コマンドラインでの編集機能とコマンドヒストリの機能は、外部の GNU
readline ライブラリか外部の BSD libedit ライブラリ、または組み込まれて
いる同等のもののいずれかを使ってサポートしています。この選択は、
gnuplot のコンパイル時の configure のオプションで行います。

組み込みの readline 版の場合の編集コマンドは以下の通りですが、DEL キー
に関する動作はシステムに依存することに注意してください。GNU readlineラ
イブラリと BSD libedit ライブラリに関しては、それ自身のドキュメントを参
照してください。


           `行編集`:


           ^B    1 文字前へ戻す
           ^F    1 文字先へ進める
           ^A    行の先頭に移動
           ^E    行の最後に移動
           ^H    直前の文字を削除
           DEL   現在の文字を削除
           ^D    現在位置の文字を削除、空行なら EOF を送信
           ^K    現在位置から行末まで削除
           ^L,^R 壊れた表示の行を再表示
           ^U    行全体の削除
           ^W    直前の単語を削除


           `履歴`:


           ^P    前の履歴へ移動
           ^N    次の履歴へ移動






File: gnuplot.info, Node: コメント_(Comments), Next: 座標系_(Coordinates), Prev: コマンドライン編集_(Command-line-editing), Up: gnuplot

コメント (Comments)
===================


コメントは次のように実装されています: 文字 '#' は、行中のたいていの場所
に書くことができます。このとき `gnuplot` はその行の残りの部分を無視しま
す。ただし、引用符の中、数 (複素数を含む) の中、コマンド置換(command
substitution) の中などではこの効果がありません。簡単に言うと意味のある
ような使い方をしさえすれば、正しく動作すると言うことです。

データファイル中のコメント文字の指定については、以下参照: `set
datafile commentschars`。コメント行が '\' で終わっている場合、次の行も
コメントとして扱われることに注意してください。



File: gnuplot.info, Node: 座標系_(Coordinates), Next: 文字列データ_(Datastrings), Prev: コメント_(Comments), Up: gnuplot

座標系 (Coordinates)
====================



コマンド *Note arrow::, `set key`, `set label`, *Note object:: はグラフ
上の任意の位置が指定できます。その位置は以下の書式で指定します:

           {<system>} <x>, {<system>} <y> {,{<system>} <z>}


各座標系指定 <system> には、`first`, `second`, `graph`, `screen`,
`character` のいずれかが入ります。

`first` は左と下の軸で定義される x,y (3D の場合は z も) の座標系を使用
します。`second` は第 2 軸 (上と右の軸) を使用します。`graph` はグラフ
描画領域内の相対的位置を指定し、左下が 0,0 で 右上が 1,1 (splot の場合
はグラフ描画領域内の左下が 0,0,0 で、土台の位置は負の z の値を使用しま
す。以下参照: *Note xyplane::) となります。`screen` は表示範囲内 (範囲
全体であり、*Note size:: で選択される一部分ではありません) を指定し、左
下が 0,0 で 右上が 1,1 となります。`character` は、画面領域の左下
(screen 0,0) からの、文字の幅、文字の高さでの位置を与えます。よって、
`character` 座標は、選択されたフォントのサイズに依存します。

x の座標系が指定されていない場合は `first` が使われます。y の座標系が指
定されていない場合は x に対する座標系が使用されます。

与える座標が絶対的な位置ではなくて相対的な値である場合もあります (例え
ば *Note arrow:: ... `rto` の 2 番目の数値)。そのほとんどが、与えられた
数値を最初の位置に対する差として使います。与えられた座標が対数軸内にあ
る場合は、その相対的な値は倍率として解釈されます。例えば

           set logscale x
           set arrow 100,5 rto 10,2


は、x 軸が対数軸で y 軸が線形の軸なので、100,5 の位置から 1000,7 の位置
への矢印を書くことになります。

一つ (あるいはそれ以上) の軸が時間軸である場合、*Note timefmt:: の書式
文字列に従って、引用符で囲まれた時間文字列で適切な座標を指定する必要が
あります。以下参照: *Note xdata::, *Note timefmt::。また、`gnuplot` は
整数表記も認めていて、その場合その整数は 2000 年 1 月 1 日からの秒数と
解釈されます。



File: gnuplot.info, Node: 文字列データ_(Datastrings), Next: 拡張文字列処理モード_(Enhanced_text_mode), Prev: 座標系_(Coordinates), Up: gnuplot

文字列データ (Datastrings)
==========================


データファイルには、ホワイトスペース (空白やタブ) を含まない任意の印字
可能な文字列、あるいは 2 重引用符で囲まれた任意の文字列 (ホワイトスペー
スが含まれても良い)、のいずれかの形からなる文字列データを持たせることも
可能です。データファイルに次の例のような行が含まれている場合、それは 4
つの列を含み、3 列目がテキスト部分であると見なされます:

       1.000 2.000 "Third column is all of this text" 4.00


テキスト部分は 2 次元や 3 次元描画内で例えば以下のように使用されます:

       plot 'datafile' using 1:2:4 with labels
       splot 'datafile' using 1:2:3:4 with labels


テキスト部分の列データは 1 つ、または複数の描画軸の目盛りのラベルとして
使用できます。次の例は、入力データの 3 列目と 4 列目を (X,Y) 座標として
取り出し、それらの点の列を結ぶ線分を描画します。しかしこの場合gnuplot
は、x 軸に沿って標準的に間の空いた数字ラベルのついた目盛り刻みをつける
のではなく、入力データファイルの 1 行目の X 座標の位置に、目盛り刻みと
文字列を x 軸に沿ってつけて行きます。

       set xtics
       plot 'datafile' using 3:4:xticlabels(1) with linespoints



入力データの列の最初のエントリ (すなわち列の見出し) をテキスト部分と解
釈するもう一つのオプションがあり、それはテキスト部分を、その描画した列
のデータの説明 (key) のタイトル部分として使用します。次の例は、先頭の行
の 2 列目の部分を説明ボックス内のタイトルを生成するのに使用し、その後の
列の 2,4 列目は要求された曲線を描画するのに処理されます:

       plot 'datafile' using 1:(f($2)/$4) with lines title columnhead(2)


別の例:

       plot for [i=2:6] 'datafile' using i title "Results for ".columnhead(i)


以下参照: *Note labels::, `using xticlabels`, *Note title::,
*Note using::。



File: gnuplot.info, Node: 拡張文字列処理モード_(Enhanced_text_mode), Next: 環境変数_(Environment), Prev: 文字列データ_(Datastrings), Up: gnuplot

拡張文字列処理モード (Enhanced text mode)
=========================================


多くの出力形式が、拡張文字列処理モード (enhanced text mode) をサポート
しています。これは、文字列に追加の書式情報を埋めこみます。例えば "x^2"
は x の自乗を、通常我々が見る上付きの 2 がついた形で書き出します。この
モードは、例えば、"set term png enhanced" のように普通は出力形式を設定
するときに選択しますが、後で "set termoption enhanced" を使ってその機能
を有効/無効にもできますし、"set label 'x_2' noenhanced" のように個々の
文字列に適用することもできます。


      制御記号     例              説明
       ^           a^x             上付き文字
       _           a_x             下付き文字
       @           @x, a@^b_{cd}   空ボックス (幅がない)
       &           &{space}        指定した長さのスペースを挿入
       ~           ~a{.8-}         'a' の上に '-' を、現在のフォントサ
                                   イズの .8 倍持ち上げた位置に重ね書き




中カッコは一文字が期待される箇所に複数の文字を書く場合に使われます (例
えば 2^{10})。フォント、およびそのサイズを変更するには、以下の形式を使っ
てください: {/[fontname][=fontsize | *fontscale] text} よって、例えば
{/Symbol=20 G} は 20 ポイントのΓ (ガンマ)に、{/*0.75 K} は現在の有効な
フォントサイズの 3/4 の大きさの K になります (文字 '/' は、'{' の直後の
文字でなくてはなりません)。

空ボックス (phantom box) は a@^b_c の上付き文字と下付き文字を揃えるとき
に有用ですが、文字にアクセント記号を重ねる場合にはうまく働きません。後
者の目的のためには、色々なアクセントやその他のダイアクリティカルマーク
のある多くの文字を持つエンコード (例えば iso_8859_1 や utf8) を使用する
方がいいでしょう。以下参照: *Note encoding::。そのボックスはスペーシン
グが行なわれないので、ボックス内 (つまり @ の後ろ) の上付き文字や下付き
文字を短く出力するのに適しています。

ある文字列と同じ長さのスペースを文字 '&' を使うことで入れることができま
す。すなわち、
             'abc&{def}ghi'

は以下を生成します (abc と ghi の間は 3 文字分の空白):
             'abc   ghi'


文字 '~' は、次の文字、またはカッコで囲まれた文字列に、それに続く文字ま
たはカッコで囲まれた文字列を重ね書きします。2 番目の文字は最初の文字に
あわせて水平方向にセンタリングされます。よって '~a/' は 'a' を貫くよう
なスラッシュが得られます。2 番目の文字は、その前に数字を置くことで垂直
方向に移動させることができます。その数字は現在のフォントサイズに対する
割合を意味し、それに従って文字が上がったり下がったりします。この場合数
字と文字列は 1 文字より長くなるのでカッコで囲む必要があります。重ね書き
される文字列が数字から始まっている場合は、垂直にずらす値と文字列との間
にスペースを入れてください ('~{abc}{.5 000}')。それ以外はスペースは不要
です ('~{abc}{.5---}')。一方、あるいは両方のフォントを変更することもで
きます ('~a{.5 /*.2 o}'; 'a' その 1/5 の大きさの 'o'、この場合数字とス
ラッシュの間のスペースは必要です) が、その文字列が始まった後で変更する
ことはできません。それぞれの文字列内で、他の特殊な書式を使うこともでき
ません。もちろん、'~a{\^}' のように特殊な文字をエスケープすること (下記
参照) は可能です。

\文字コード (8 進数) を指定することで特殊な記号を指定することができます。
例えば、{/Symbol \245} は無限大の記号になります。しかし、これは、UTF-8
のようなマルチバイトエンコードの場合にはうまくいきません。UTF-8環境では、
タイプ入力するかまたは別のやり方であなたが望む文字を選択することでマル
チバイト列を入力できるようにすべきです。

制御文字は、 \\ や \{ などのように \ を使ってエスケープできます。

しかし、二重引用符内の文字列は単一引用符内の文字列とは異なって解釈され
ることを知っておいてください。主な違いは、二重引用符内の文字列ではバッ
クスラッシュは 2 つ重ねる必要があることです。

例 (これらは言葉で説明するのは難しいのでとりあえずやってみてください):
           set xlabel 'Time (10^6 {/Symbol m}s)'
           set title '{/Symbol=18 \\362@_{/=9.6 0}^{/=12 x}} \\
                      {/Helvetica e^{-{/Symbol m}^2/2} d}{/Symbol m}'


gnuplot ソース配布物内の /docs/psdoc サブディレクトリにあるファイル
ps_guide.ps" に、拡張された書式に関する例が更に載っています。



File: gnuplot.info, Node: 環境変数_(Environment), Next: 式_(Expressions), Prev: 拡張文字列処理モード_(Enhanced_text_mode), Up: gnuplot

環境変数 (Environment)
======================


`gnuplot` は多くのシェル環境変数を認識します。必須のものはありませんが、
使えば便利になるかも知れません。

GNUTERM が定義されている場合、それは使用される出力形式 (terminal) の名
前として使われます。これは `gnuplot` が起動時に見つけた出力形式に優先し
て使用されますが、.gnuplot (またはそれに相当する) スタートアップファイ
ル (以下参照: `startup`) による指定や、当り前のことですが、その後に明示
的に指定した物の方が優先されます。

GNUHELP にヘルプファイル (gnuplot.gih) のパス名を定義しておくことができ
ます。

VMS では、論理名 GNUPLOT$HELP を `gnuplot` のヘルプライブラリの名前とし
て定義します。`gnuplot` のヘルプは任意のシステムのヘルプライブラリに入
れることができ、`gnuplot` の内部からでも外部からでも参照して構いません。

Unix においては、カレントディレクトリに .gnuplot というファイルがない場
合には、HOME に定義されたディレクトリを探します。MS-DOS, Windows, OS/2
では GNUPLOT がその役割に使われます。Windows では、NT 専用の変数
USERPROFILE も参照されます。VMS では SYS$LOGIN です。`help startup`と打っ
てみてください。

Unix においては、PAGER がヘルプメッセージの出力用のフィルタとして使われ
ます。

Unix では、SHELL が *Note shell:: コマンドの際に使われます。MS-DOS,
OS/2 では COMSPEC が *Note shell:: コマンドの際に使われます。

FIT_SCRIPT は、当てはめ (fit) が中断されたときに実行する `gnuplot` コマ
ンドの指定に使われます。以下参照: `fit`。FIT_LOG は当てはめによるログファ
イルのデフォルトのファイル名の指定に使われます。

GNUPLOT_LIB は、データやコマンドファイルの検索ディレクトリを追加定義す
るのに使われます。その変数は、一つのディレクトリ名かまたは複数のディレ
クトリ名を書くことができますが、ディレクトリの区切りはプラットホーム毎
に違います。例えば Unix では ':' で、MS-DOS, Windows, OS/2 では ';' で
す。GNUPLOT_LIB の値は変数 *Note loadpath:: に追加されますが、それは
*Note save::や `save set` コマンドでは保存されません。

出力ドライバの中には gd ライブラリ経由で TrueType フォントを扱えるもの
もいくつかあります。これらのドライバのフォント検索パスは、環境変数
GDFONTPATH で制御できます。さらに、それらのドライバでのデフォルトのフォ
ントは環境変数 GNUPLOT_DEFAULT_GDFONT で制御できます。

postscript 出力ドライバは自分で持っているフォント検索パスを使いますが、
それは環境変数 GNUPLOT_FONTPATH で制御できます。書式は GNUPLOT_LIB と同
じです。GNUPLOT_FONTPATH の値は変数 *Note fontpath:: に追加されますが、
それは *Note save:: や `save set` コマンドでは保存されません。

PostScript ドライバは、外部 (組み込まれていない) 定義ファイルを探すため
に環境変数 GNUPLOT_PS_DIR を利用します。インストール時の作業により、
gnuplot にはそれらのファイルのコピーが組み込まれているか、またはデフォ
ルトのパスが埋め込まれています。この変数は、postscript 出力形式でデフォ
ルトのファイルの代わりにカスタマイズした prologue ファイルを使用するの
に利用できます。以下参照: `postscript prologue`。



File: gnuplot.info, Node: 式_(Expressions), Next: フォント, Prev: 環境変数_(Environment), Up: gnuplot

式 (Expressions)
================


基本的には C, FORTRAN, Pascal, BASIC において利用可能な数学表現を使用で
きます。 演算子の優先順位は C 言語の仕様に従います。数式中の空白文字と
タブ文字は無視されます。

複素数の定数は {<real>,<imag>} と表現します。ここで <real> と <imag>
(実部、虚部) は数値定数である必要があります。例えば {3,2} は 3 + 2i を
あらわし、{0,1} は 'i' 自身を表します。これらには明示的に中カッコを使う
必要があります。


gnuplot は "実数" と "整数" 演算を FORTRAN や C のように扱うということ
に注意してください。"1", "-10" などは整数と見なされ、"1.0", "-10.0",
1e1", 3.5e-1 などは実数と見なされます。 これら 2 つのもっとも重要な違い
は割算です。整数の割算は切り捨てられます: 5/2 = 2。実数はそうではありま
せん: 5.0/2.0 = 2.5。それらが混在した式の場合、計算の前に整数は実数に
拡張" されます: 5/2e0 = 2.5。負の整数を正の整数で割る場合、その値はコン
パイラによって変わります。"print -5/2" として、あなたのシステムが -2
と -3 のどちらを答えとするかを確認してください。

数式 "1/0" は "未定義値 (undefined)" フラグを生成し、それによりその点を
無視します。あるいは、あらかじめ定義されている値 NaN を使っても同じこと
になります。例については、以下参照: *Note using::。


複素数表現の実数部分、虚数部分は、どんな形で入力されても常に実数です:
{3,2} の "3" と "2" は実数であり、整数ではありません。

gnuplot は文字列に対する単純な演算、および文字列変数も利用できます。例
えば式 ("A" . "B" eq "AB") は真と評価されますが、これは文字列の結合演算
子と文字列の等号演算子を意味しています。

数としての値を含む文字列は、それが数式で利用された場合は、対応する整数
や実数に変換されます。よって、("3" + "4" == 7) や (6.78 == "6.78") はど
ちらも真になります。整数は、それが文字列結合演算子で使われた場合は文字
列に変換されますが、実数や複素数はダメです。典型的な例は、ファイル名や
他の文字列内に整数を使う場合でしょう: 例えば ("file" . 4 eq "file4")は
真です。

後置指定する範囲記述子 [beg:end] によって、部分文字列を指定することがで
きます。例えば、"ABCDEF"[3:4] == "CD" で、"ABCDEF"[4:*] == "DEF" です。
書式 "string"[beg:end] は、文字列値の組み込み関数
substr("strings",beg,end) を呼ぶこととほぼ同じですが、関数呼び出しでは
beg, end は省略することはできません。

* Menu:

* 関数_(Functions)::
* 演算子_(Operators)::
* 和_(Summation)::
* 定義済み変数_(Gnuplot-defined_variables)::
* ユーザ定義の変数と関数_(User-defined)::



File: gnuplot.info, Node: 関数_(Functions), Next: 演算子_(Operators), Prev: 式_(Expressions), Up: 式_(Expressions)

関数 (Functions)
----------------

`gnuplot` の数学関数は、Unix 数学ライブラリの関数とほぼ同じですが、特に
注意がなければ全ての関数が整数、実数、複素数の引数を取ることができます。
角を引数や戻り値とする関数 (例えば sin(x), cos(x), arg(z)) は、その値を
ラジアンとして扱いますが、これはコマンド *Note angles:: によって度に変
更できます。








* Menu:

* abs::
* acos::
* acosh::
* airy::
* arg::
* asin::
* asinh::
* atan::
* atan2::
* atanh::
* EllipticK::
* EllipticE::
* EllipticPi::
* besj0::
* besj1::
* besy0::
* besy1::
* ceil::
* cos::
* cosh::
* erf::
* erfc::
* exp::
* expint::
* floor::
* gamma::
* ibeta::
* inverf::
* igamma::
* imag::
* invnorm::
* int::
* lambertw::
* lgamma::
* log::
* log10::
* norm::
* rand::
* real::
* sgn::
* sin::
* sinh::
* sqrt::
* tan::
* tanh::
* voigt::
* gprintf::
* sprintf::
* strlen::
* strstrt::
* substr::
* strftime::
* strptime::
* system::
* word::
* words::
* column::
* columnhead::
* defined::
* exists::
* stringcolumn::
* timecolumn::
* tm_hour::
* tm_mday::
* tm_min::
* tm_mon::
* tm_sec::
* tm_wday::
* tm_yday::
* tm_year::
* time::
* valid::
* 種々の楕円積分_(elliptic_integrals)::
* 乱数の生成_(random)::
* value::



File: gnuplot.info, Node: abs, Next: acos, Prev: 関数_(Functions), Up: 関数_(Functions)

abs
...


関数 `abs(x)` 引数の絶対値を返します。返り値の型は引数と同じです。

複素数の引数に対しては, abs(x) は複素平面における x の長さと定義されて
います [すなわち sqrt(real(x)**2 + imag(x)**2) ]。



File: gnuplot.info, Node: acos, Next: acosh, Prev: abs, Up: 関数_(Functions)

acos
....


関数 `acos(x)` は引数のアークコサイン (逆余弦) を返します。`acos` の返
す値がラジアン単位かまたは度であるかは *Note angles:: で選択されます。



File: gnuplot.info, Node: acosh, Next: airy, Prev: acos, Up: 関数_(Functions)

acosh
.....


関数 `acosh(x)` は逆ハイパボリックコサイン (逆双曲余弦) の値をラジアン
で返します。



File: gnuplot.info, Node: airy, Next: arg, Prev: acosh, Up: 関数_(Functions)

airy
....


関数 `airy(x)` は、エアリー (Airy) 関数 Ai(x) の値を返します。関数
Ai(x) は、微分方程式 y" - x y = 0 の、実数全体で有界な解です。引数が複
素数の場合、その虚数部分は無視されます。



File: gnuplot.info, Node: arg, Next: asin, Prev: airy, Up: 関数_(Functions)

arg
...


関数 `arg(x)` は複素数の偏角を、*Note angles:: の設定にしたがってラジア
ン、または度で返します。



File: gnuplot.info, Node: asin, Next: asinh, Prev: arg, Up: 関数_(Functions)

asin
....


関数 `asin(x)` は引数のアークサイン (逆正弦) を返します。`asin` の返す
値は *Note angles:: の設定によってラジアン単位かまたは度になります。



File: gnuplot.info, Node: asinh, Next: atan, Prev: asin, Up: 関数_(Functions)

asinh
.....


関数 `asinh(x)` は逆ハイパボリックサイン (逆双曲正弦) の値をラジアンで
返します。



File: gnuplot.info, Node: atan, Next: atan2, Prev: asinh, Up: 関数_(Functions)

atan
....


関数 `atan(x)` は引数のアークタンジェント (逆正接) の値を返します。
`atan` の返す値は *Note angles:: の設定によってラジアン単位かまたは度に
なります。



File: gnuplot.info, Node: atan2, Next: atanh, Prev: atan, Up: 関数_(Functions)

atan2
.....


関数 `atan2(y,x)` は引数の実数部分の比のアークタンジェント (逆正接) の
値を返します。*Note atan2:: は *Note angles:: の設定によってラジアン単
位か度になる、適切な四分円における値を返します。



File: gnuplot.info, Node: atanh, Next: EllipticK, Prev: atan2, Up: 関数_(Functions)

atanh
.....


関数 `atanh(x)` は逆ハイパボリックタンジェント (逆双曲正接) の値をラジ
アンで返します。



File: gnuplot.info, Node: EllipticK, Next: EllipticE, Prev: atanh, Up: 関数_(Functions)

EllipticK
.........

以下参照: `elliptic integrals`。



File: gnuplot.info, Node: EllipticE, Next: EllipticPi, Prev: EllipticK, Up: 関数_(Functions)

EllipticE
.........

以下参照: `elliptic integrals`。



File: gnuplot.info, Node: EllipticPi, Next: besj0, Prev: EllipticE, Up: 関数_(Functions)

EllipticPi
..........

以下参照: `elliptic integrals`。



File: gnuplot.info, Node: besj0, Next: besj1, Prev: EllipticPi, Up: 関数_(Functions)

besj0
.....


関数 `besj0(x)` は引数の j0 ベッセル関数 (0 次の第 1 種円柱関数 J0、0次
ベッセル関数) の値を返します。*Note besj0:: には引数はラジアンで与えま
す。



File: gnuplot.info, Node: besj1, Next: besy0, Prev: besj0, Up: 関数_(Functions)

besj1
.....


関数 `besj1(x)` は引数の j1 ベッセル関数 (1 次の第 1 種円柱関数 J1、1次
ベッセル関数) の値を返します。*Note besj1:: には引数はラジアンで与えま
す。



File: gnuplot.info, Node: besy0, Next: besy1, Prev: besj1, Up: 関数_(Functions)

besy0
.....


関数 `besy0(x)` は引数の y0 ベッセル関数 (0 次の第 2 種円柱関数 Y0、0次
ノイマン関数) の値を返します。*Note besy0:: には引数はラジアンで与えま
す。



File: gnuplot.info, Node: besy1, Next: ceil, Prev: besy0, Up: 関数_(Functions)

besy1
.....


関数 `besy1(x)` は引数の y1 ベッセル関数 (1 次の第 2 種円柱関数 Y1、1次
ノイマン関数) の値を返します。*Note besy1:: には引数はラジアンで与えま
す。



File: gnuplot.info, Node: ceil, Next: cos, Prev: besy1, Up: 関数_(Functions)

ceil
....


関数 `ceil(x)` は引数以上の最小の整数を返します。複素数引数に対しては
*Note ceil:: はその引数の実部以上の最小の整数を返します。



File: gnuplot.info, Node: cos, Next: cosh, Prev: ceil, Up: 関数_(Functions)

cos
...


関数 `cos(x)` は引数のコサイン (余弦) の値を返します。`cos` は
*Note angles:: の選択にしたがって、ラジアンまたは度の引数を受け付けます。



File: gnuplot.info, Node: cosh, Next: erf, Prev: cos, Up: 関数_(Functions)

cosh
....


関数 `cosh(x)` は引数のハイパボリックコサインの値を返します。*Note
cosh:: の引数はラジアンで与えます。



File: gnuplot.info, Node: erf, Next: erfc, Prev: cosh, Up: 関数_(Functions)

erf
...


関数 `erf(x)` は引数の実部の誤差関数の値を返します。引数が複素数の場合
は虚部は無視されます。以下参照: *Note erfc::, *Note inverf::, *Note
norm::。



File: gnuplot.info, Node: erfc, Next: exp, Prev: erf, Up: 関数_(Functions)

erfc
....


関数 `erfc(x)` は 1.0 から、引数の実部の誤差関数の値を引いたものを返し
ます。引数が複素数の場合は虚部は無視されます。以下参照: `erf`,
*Note inverf::, *Note norm::。



File: gnuplot.info, Node: exp, Next: expint, Prev: erfc, Up: 関数_(Functions)

exp
...


関数 `exp(x)` 引数の指数関数の値 (`e` の引数乗) を返します。環境によっ
ては (特に sun) 大きい x の値に対する exp(-x) は未定義値を返す場合があ
ります。このような場合、safe(x) = x<-100 ? 0 : exp(x) のようなユーザ定
義関数が役に立つでしょう。



File: gnuplot.info, Node: expint, Next: floor, Prev: exp, Up: 関数_(Functions)

expint
......


関数 `expint(n,x)` は、その引数の実数部分の指数積分、すなわち t の関数
t^(-n) e^(-tx) の 1 から∞までの積分値を返します。n は 0 以上の整数、x
は 0 以上の実数で、x>0 か n>1 のいずれかでなければなりません。



File: gnuplot.info, Node: floor, Next: gamma, Prev: expint, Up: 関数_(Functions)

floor
.....


関数 `floor(x)` はその引数以下の最大の整数を返します。複素数引数に対し
ては *Note floor:: はその引数の実部以下の最大の整数を返します。



File: gnuplot.info, Node: gamma, Next: ibeta, Prev: floor, Up: 関数_(Functions)

gamma
.....


関数 `gamma(x)` は引数の実部のガンマ関数の値を返します。整数 n に対して
は gamma(n+1) = n! です。引数が複素数の場合、虚数部分は無視されます。



File: gnuplot.info, Node: ibeta, Next: inverf, Prev: gamma, Up: 関数_(Functions)

ibeta
.....


関数 `ibeta(p,q,x)` は引数の実部の不完全ベータ関数の値を返します。p, q
は正で x は [0:1] 内の値です。引数が複素数の場合は虚部は無視されます。
この関数は連分数法 (Abramowitz and Stegun, 1964) で近似していて、この近
似は x < (p-1)/(p+q-2) の範囲でしか正確ではありません。



File: gnuplot.info, Node: inverf, Next: igamma, Prev: ibeta, Up: 関数_(Functions)

inverf
......


関数 `inverf(x)` は引数の実部の逆誤差関数の値を返します。以下参照:
`erf`, *Note invnorm::。



File: gnuplot.info, Node: igamma, Next: imag, Prev: inverf, Up: 関数_(Functions)

igamma
......


関数 `igamma(a,x)` は引数の実部の、正規化された不完全ガンマ関数の値を返
します。ここで、a > 0, x >= 0 です。標準的な記法では P(a,x) (例えば
Abramowitz and Stegun (6.5.1)) で、x が無限大に発散する場合の極限値は1
です。引数が複素数の場合は虚部は無視されます。



File: gnuplot.info, Node: imag, Next: invnorm, Prev: igamma, Up: 関数_(Functions)

imag
....


関数 `imag(x)` は引数の虚数部分を実数として返します。



File: gnuplot.info, Node: invnorm, Next: int, Prev: imag, Up: 関数_(Functions)

invnorm
.......


関数 `invnorm(x)` は引数の実部に対する、正規分布 (ガウス分布) の累積分
布関数の逆関数の値を返します。以下参照: *Note norm::。



File: gnuplot.info, Node: int, Next: lambertw, Prev: invnorm, Up: 関数_(Functions)

int
...


関数 `int(x)` は、引数の整数部分 (0 に向かって丸めた) を返します。



File: gnuplot.info, Node: lambertw, Next: lgamma, Prev: int, Up: 関数_(Functions)

lambertw
........


lambertw 関数は Lambert の W 関数の主値を返します。これは、
(W(z)*exp(W(z))=z で定義されます。z は z >= -exp(-1) を満たす実数でなけ
ればいけません。



File: gnuplot.info, Node: lgamma, Next: log, Prev: lambertw, Up: 関数_(Functions)

lgamma
......


関数 `lgamma(x)` は引数の実部のガンマ関数値の自然対数の値を返します。引
数が複素数の場合、虚部は無視されます。



File: gnuplot.info, Node: log, Next: log10, Prev: lgamma, Up: 関数_(Functions)

log
...


関数 `log(x)` は引数の自然対数 (底 `e`) の値を返します。以下参照:
*Note log10::。



File: gnuplot.info, Node: log10, Next: norm, Prev: log, Up: 関数_(Functions)

log10
.....


関数 `log10(x)` は引数の対数 (底 10) を返します。



File: gnuplot.info, Node: norm, Next: rand, Prev: log10, Up: 関数_(Functions)

norm
....


関数 `norm(x)` は、引数の実部に対する、正規分布 (ガウス分布) の累積分布
関数の値を返します。以下参照: *Note invnorm::, `erf`, *Note erfc::。



File: gnuplot.info, Node: rand, Next: real, Prev: norm, Up: 関数_(Functions)

rand
....


`rand(0)` 区間 [0:1] 内の疑似乱数を返す。詳しくは以下参照: `random`。



File: gnuplot.info, Node: real, Next: sgn, Prev: rand, Up: 関数_(Functions)

real
....


関数 `real(x)` は引数の実部を返します。



File: gnuplot.info, Node: sgn, Next: sin, Prev: real, Up: 関数_(Functions)

sgn
...


関数 `sgn(x)` は引数が正なら 1 を、負なら -1 を、0 ならば 0 を返します。
引数が複素数の場合虚部は無視されます。



File: gnuplot.info, Node: sin, Next: sinh, Prev: sgn, Up: 関数_(Functions)

sin
...


関数 `sin(x)` は引数のサイン (正弦) の値を返します。`sin` は
*Note angles:: の選択にしたがって、ラジアンまたは度の引数を受け付けます。



File: gnuplot.info, Node: sinh, Next: sqrt, Prev: sin, Up: 関数_(Functions)

sinh
....


関数 `sinh(x)` は引数のハイパボリックサインの値を返します。*Note
sinh:: の引数はラジアンで与えます。



File: gnuplot.info, Node: sqrt, Next: tan, Prev: sinh, Up: 関数_(Functions)

sqrt
....


関数 `sqrt(x)` は引数の平方根の値を返します。



File: gnuplot.info, Node: tan, Next: tanh, Prev: sqrt, Up: 関数_(Functions)

tan
...


関数 `tan(x)` は引数のタンジェント (正接) の値を返します。`tan` は
*Note angles:: の選択にしたがって、ラジアンまたは度の引数を受け付けます。



File: gnuplot.info, Node: tanh, Next: voigt, Prev: tan, Up: 関数_(Functions)

tanh
....


関数 `tanh(x)` は引数のハイパボリックタンジェントの値を返します。
*Note tanh:: の引数はラジアンで与えます。



File: gnuplot.info, Node: voigt, Next: gprintf, Prev: tanh, Up: 関数_(Functions)

voigt
.....


関数 `voigt(x,y)` は、スペクトル解析で使用される Voigt/Faddeeva 関数の
近似を返します。その誤差は 1/10^4 以内です。






File: gnuplot.info, Node: gprintf, Next: sprintf, Prev: voigt, Up: 関数_(Functions)

gprintf
.......

`gprintf("format",x)` は、gnuplot 独自の書式指定子に一つの変数 x を適用
し、その結果の文字列を返します。標準的な C 言語書式指定子を使いたい場合
は、代わりに `sprintf("format",x)` を使う必要があります。以下参照:
`format specifiers`。



File: gnuplot.info, Node: sprintf, Next: strlen, Prev: gprintf, Up: 関数_(Functions)

sprintf
.......


`sprintf("format",var1,var2,...)` は標準的な C 言語の書式指定子を複数個
の引数に適用し、その結果の文字列を返します。gnuplot 独自の書式指定子を
使いたい場合は、代わりに `gprintf()` を使用する必要があります。sprintf
の書式指定子に関するより詳しい情報については、標準的な C 言語の本か、
unix の sprintf の man ページを参照してください。



File: gnuplot.info, Node: strlen, Next: strstrt, Prev: sprintf, Up: 関数_(Functions)

strlen
......


`strlen("string")` は、バイト単位での文字列の長さを返します。現在のエン
ドーディングが多バイト文字をサポートしていれば、その値は文字列中の文字
数よりも大きくなるでしょう。



File: gnuplot.info, Node: strstrt, Next: substr, Prev: strlen, Up: 関数_(Functions)

strstrt
.......


`strstrt("string","key")` は、文字列 "key" を "string" の中で探し、それ
が現れる先頭位置を返します。"key" が見つからなかった場合は 0 を返します。
C ライブラリの strstr 関数に似ていますが、文字列へのポインタを返す
strstr とは違い、これは整数での位置を返します。例えば、
strstrt("hayneedlestack","needle") = 4 となります。



File: gnuplot.info, Node: substr, Next: strftime, Prev: strstrt, Up: 関数_(Functions)

substr
......



`substr("string",beg,end)` は、元の文字列の beg から end 番目までの文字
からなる文字列を返します。これは、"string"[beg:end] という式とほぼ同じ
ですが、こちらはオプション beg, end を省略できません。



File: gnuplot.info, Node: strftime, Next: strptime, Prev: substr, Up: 関数_(Functions)

strftime
........


`strftime("timeformat",t)` は、2000 年からの秒数による時刻 t に、時刻書
式指定 timeformat を適用します。以下参照: `time_specifiers`, *Note
strptime::。



File: gnuplot.info, Node: strptime, Next: system, Prev: strftime, Up: 関数_(Functions)

strptime
........


`strptime("timeformat",s)` 書式指定 timeformat を使って文字列 s から時
刻を読み込んで、それを 2000 年からの秒数に変換します。以下参照:
`time_specifiers`, *Note strftime::。



File: gnuplot.info, Node: system, Next: word, Prev: strptime, Up: 関数_(Functions)

system
......



`system("command")` は、標準的なシェルを用いて "command" を実行し、その
標準出力への文字列を文字列変数として返します。一番最後の改行一つは無視
されます。

これは、'f(x) = real(system(sprintf("somecommand %f", x)))' のようにし
て、外部関数の出力を gnuplot スクリプト内に取り込むのに利用できます。



File: gnuplot.info, Node: word, Next: words, Prev: system, Up: 関数_(Functions)

word
....



`word("string",n)` は文字列 string の n 番目の単語文字列を返します。例
えば `word("one two three",2)` は文字列 "two" を返します。



File: gnuplot.info, Node: words, Next: column, Prev: word, Up: 関数_(Functions)

words
.....



`words("string")` は文字列 string 中の単語数を返します。例えば`words("
a b c d")` は 4 を返します。






File: gnuplot.info, Node: column, Next: columnhead, Prev: words, Up: 関数_(Functions)

column
......


`column(x)` は fit あるいはデータファイルプロットでの *Note using:: の
処理中の数式の一部としてのみ使われます。これは $x$ 列目の内容を数値とし
て評価します。以下参照: *Note using::。



File: gnuplot.info, Node: columnhead, Next: defined, Prev: column, Up: 関数_(Functions)

columnhead
..........


`columnhead(x)` は、非線形のあてはめ (fit) の際の *Note using:: 処理内の数式
として、あるいはデータファイル描画でのいずれかのみで使えます。これは、
データの最初の行の x 列目の内容を含む文字列と評価されます。以下参照:
*Note using::。



File: gnuplot.info, Node: defined, Next: exists, Prev: columnhead, Up: 関数_(Functions)

defined
.......


`defined(X)` [非推奨] は、X が定義されていれば 1、そうでなければ 0 を返
します。`exists("X")` を代わりに使用してください。



File: gnuplot.info, Node: exists, Next: stringcolumn, Prev: defined, Up: 関数_(Functions)

exists
......


exists() の引数は文字列定数、または文字列変数です。その文字列が、定義さ
れている変数名を持っていれば 1 を、そうでなければ 0 を返します。



File: gnuplot.info, Node: stringcolumn, Next: timecolumn, Prev: exists, Up: 関数_(Functions)

stringcolumn
............



`stringcolumn(x)` は fit あるいはデータファイルプロットでの *Note
using:: の操作の数式の一部としてのみ使われます。これは $x$ 列目の内容を
文字列変数として返します。以下参照: *Note using::。



File: gnuplot.info, Node: timecolumn, Next: tm_hour, Prev: stringcolumn, Up: 関数_(Functions)

timecolumn
..........


`timecolumn(x)` は fit あるいはデータファイルプロットでの *Note
using:: 処理中の数式の一部としてのみ使われます。以下参照: *Note
using::。

これは、その指定した列から始まるデータを日時データ値として読み、その値
を gnuplot の内部時間表現である "2000 年からの秒数" で返します。

処理のために正しい *Note timefmt:: 文字列を見つけるため、*Note
timecolumn:: はその引数と同じ列番号を *Note using:: 指定の中で探します。
もしそれが見つかったら、その指定の対象となる軸の *Note timefmt:: 文字列
が使用されます。見つからなかったら、*Note timecolumn:: はデフォルトでは
x 軸の *Note timefmt:: 文字列を選択します。



File: gnuplot.info, Node: tm_hour, Next: tm_mday, Prev: timecolumn, Up: 関数_(Functions)

tm_hour
.......


関数 *Note tm_hour:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
が時刻の何時 (0--23 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_mday, Next: tm_min, Prev: tm_hour, Up: 関数_(Functions)

tm_mday
.......


関数 *Note tm_mday:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
がその月の何日 (1--31 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_min, Next: tm_mon, Prev: tm_mday, Up: 関数_(Functions)

tm_min
......


関数 *Note tm_min:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
が時刻の何分 (0--59 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_mon, Next: tm_sec, Prev: tm_min, Up: 関数_(Functions)

tm_mon
......


関数 *Note tm_mon:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
が何月 (0--11 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_sec, Next: tm_wday, Prev: tm_mon, Up: 関数_(Functions)

tm_sec
......


関数 *Note tm_sec:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
が時刻の何秒 (0--59 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_wday, Next: tm_yday, Prev: tm_sec, Up: 関数_(Functions)

tm_wday
.......


関数 *Note tm_wday:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
がその週の何日目 (0--6 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_yday, Next: tm_year, Prev: tm_wday, Up: 関数_(Functions)

tm_yday
.......


関数 *Note tm_yday:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
がその年の何日目 (1--366 の範囲の整数) であるかを、実数として返します。



File: gnuplot.info, Node: tm_year, Next: time, Prev: tm_yday, Up: 関数_(Functions)

tm_year
.......


関数 *Note tm_year:: は引数を 2000 年 1 月 1 日からの秒数と解釈し、それ
が西暦何年 (整数) であるかを、実数として返します。



File: gnuplot.info, Node: time, Next: valid, Prev: tm_year, Up: 関数_(Functions)

time
....


関数 `time` は現在のシステム時刻を返します。この値は *Note strftime::
関数で日時文字列に変換できますし、*Note timecolumn:: と組み合わせて相対
的な日時グラフを作成するのにも使えます。引数の型はそれが返すものを決定
します。引数が整数の場合は time() は現在の時刻を 2000 年 1 月 1 日から
の整数として返し、引数が実数 (または複素数) ならば同様の値を実数として
返します。引数が文字列ならば、それを書式文字列であるとみなし、書式化さ
れた日時文字列を提供するようそれを *Note strftime:: に渡します。



File: gnuplot.info, Node: valid, Next: 種々の楕円積分_(elliptic_integrals), Prev: time, Up: 関数_(Functions)

valid
.....


`valid(x)` は、データ描画か fit における *Note using:: の式の中でしか使
われません。以下参照: *Note using::。






File: gnuplot.info, Node: 種々の楕円積分_(elliptic_integrals), Next: 乱数の生成_(random), Prev: valid, Up: 関数_(Functions)

種々の楕円積分 (elliptic integrals)
...................................


関数 `EllipticK(k)` は、第 1 種完全楕円積分、すなわち、関数
`(1-(k*sin(p))**2)**(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を返し
ます。`k` の定義域は -1 から 1 です (両端は含まない)。

関数 `EllipticE(k)` は、第 2 種完全楕円積分、すなわち、関数
`(1-(k*sin(p))**2)**0.5` の 0 からπ/2 までの範囲の広義積分の値を返しま
す。`k` の定義域は -1 から 1 です (両端も含む)。

関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分、すなわち関数
`(1-(k*sin(p))**2)**(-0.5)/(1-n*sin(p)**2)` の 0 からπ/2 までの範囲の広
義積分の値を返します。パラメータ `n` は 1 より小さく、`k` は -1 と 1の
間 (両端は含まない) でなければいけません。定義より、すべての正の `k`に
対し EllipticPi(0,k) == EllipticK(k) であることに注意してください。



File: gnuplot.info, Node: 乱数の生成_(random), Next: value, Prev: 種々の楕円積分_(elliptic_integrals), Up: 関数_(Functions)

乱数の生成 (random)
...................



関数 `rand()` は 0 と 1 の間の疑似乱数列を生成します。これは以下からの
アルゴリズムを使用しています: P. L'Ecuyer and S. Cote, "Implementing a
random number package with splitting facilities", ACM Transactions on
Mathematical Software, 17:98-111 (1991).

           rand(0)     内部に持つ 2 つの 32bit の種 (seed) の現在の値から生
                       成される [0:1] 区間内の疑似乱数値を返す
           rand(-1)    2 つの種の値を標準値に戻す
           rand(x)     0 < x < 2^31-1 の整数なら種の両方を x に設定する
           rand({x,y}) 0 < x,y < 2^31-1 の整数なら seed1 を x に seed2 を y
                       に設定する




File: gnuplot.info, Node: value, Prev: 乱数の生成_(random), Up: 関数_(Functions)

value
.....


A がユーザー定義変数の名前であれば、B = value("A") は事実上 B = A と全
く同じです。これは、変数の名前自身が文字列変数に収められている場合に有
用です。以下参照: *Note variables::。これは、変数名をデータファイルから
読み取ることも可能にします。引数が数式である場合、value() はその数式の
値を返します。引数が文字列で、定義されている変数に対応するものがない場
合、value() は NaN を返します。




File: gnuplot.info, Node: 演算子_(Operators), Next: 和_(Summation), Prev: 関数_(Functions), Up: 式_(Expressions)

演算子 (Operators)
------------------


`gnuplot` の演算子は、C 言語の演算子とほぼ同じですが、特に注意がなけれ
ば全ての演算子が整数、実数、複素数の引数を取ることができます。また、
FORTRAN で使える ** (累乗) 演算子もサポートされています。

演算の評価の順序を変更するにはかっこを使います。

* Menu:

* 単項演算子_(Unary)::
* 二項演算子_(Binary)::
* 三項演算子_(Ternary)::



File: gnuplot.info, Node: 単項演算子_(Unary), Next: 二項演算子_(Binary), Prev: 演算子_(Operators), Up: 演算子_(Operators)

単項演算子 (Unary)
..................


以下は、単項演算子とその使用法の一覧です:


         記号          例        説明
           -           -a          マイナス符号
           +           +a          プラス符号 (何もしない)
           ~           ~a        * 1 の補数 (ビット反転)
           !           !a        * 論理的否定
           !           a!        * 階乗
           $           $3        * *Note using:: 内での引数/列指定








説明に星印 (*) のついた演算子の引数は整数でなければなりません。

演算子の優先順位は Fortran や C と同じです。それらの言語同様、演算の評
価される順序を変えるためにかっこが使われます。よって -2**2 = -4 で、
(-2)**2 = 4 です。

階乗演算子は、大きな値を返せるように実数を返します。



File: gnuplot.info, Node: 二項演算子_(Binary), Next: 三項演算子_(Ternary), Prev: 単項演算子_(Unary), Up: 演算子_(Operators)

二項演算子 (Binary)
...................

以下は、二項演算子とその使用法の一覧です:


         記号          例          説明
           **          a**b          累乗
           *           a*b           積
           /           a/b           商
           %           a%b         * 余り
           +           a+b           和
           -           a-b           差
           ==          a==b          等しい
           !=          a!=b          等しくない
           <           a<b           より小さい
           <=          a<=b          以下
           >           a>b           より大きい
           >=          a>=b          以上
           &           a&b         * ビット積 (AND)
           ^           a^b         * ビット排他論理和 (XOR)
           |           a|b         * ビット和 (OR)
           &&          a&&b        * 論理的 AND
           ||          a||b        * 論理的 OR
           =           a = b         代入
           ,           (a,b)         累次評価
           .           A.B           文字列の連結
           eq          A eq B        文字列が等しい
           ne          A ne B        文字列が等しくない









説明に星印 (*) のついた演算子の引数は整数でなければなりません。大文字の
A,B は演算子が文字列引数を要求することを意味します。

論理演算子の AND (&&) と OR (||) は C 言語同様に必要最小限の評価しかし
ません。すなわち、`&&` の第 2 引数は、第 1 引数が偽ならば評価されません
し、`||` の第 2 引数は、第 1 引数が真ならば評価されません。

累次評価 (,) は、カッコの中でのみ評価され、左から右へ順に実行することが
保証され、最も右の式の値が返されます。



File: gnuplot.info, Node: 三項演算子_(Ternary), Prev: 二項演算子_(Binary), Up: 演算子_(Operators)

三項演算子 (Ternary)
....................


一つだけ三項演算子があります:


          記号          例       説明
           ?:          a?b:c     三項演算子





三項演算子は C のものと同じ働きをします。最初の引数 (a) は整数でなけれ
ばいけません。この値が評価され、それが真 (ゼロでない) ならば 2 番目の引
数 (b) が評価されその値が返され、そうでなければ 3 番目の引数 (c) が評価
され、その値が返されます。

三項演算子は、区分的に定義された関数や、ある条件が満たされた場合にのみ
点を描画する、といったことを行なう場合に有用です。

例:

0 <= x < 1 では sin(x) に、1 <= x < 2 では 1/x に等しくて、それ以外のx
では定義されない関数を描画:
           f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
           plot f(x)

`gnuplot` は未定義値に対しては何も表示せずにただ無視するので、最後の場
合の関数 (1/0) は点を何も出力しないことに注意してください。また、この関
数描画の描画スタイルが lines (線描画) の場合、不連続点 (x=1) の所も連続
関数として線が結ばれてしまうことにも注意してください。その点を不連続に
なるようにするには、関数を 2 つの部分それぞれに分けてください (このよう
な場合、媒介変数関数を使うのが便利です)。

ファイル 'file' のデータで、4 列目のデータが負でないときだけ、1 列目の
データに関する 2 列目と 3 列目のデータの平均値を描画:

           plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )


*Note using:: の書式の説明に関しては、以下参照: *Note using::。



File: gnuplot.info, Node: 和_(Summation), Next: 定義済み変数_(Gnuplot-defined_variables), Prev: 演算子_(Operators), Up: 式_(Expressions)

和 (Summation)
--------------


和の式は、以下の形式で表します:
           sum [<var> = <start> : <end>] <expression>

ここで <var> は、<start> から <end> までの整数値を順に取る整数変数とし
て扱われます。その各値に対して、式 <expression> の値が合計値に追加され、
最終的な合計値がこの和の式の値となります。例:
           print sum [i=1:10] i
               55.
           # 以下は plot 'data' using 1:($2+$3+$4+$5+$6+...) と同等
           plot 'data' using 1 : (sum [col=2:MAXCOL] column(col))

<expression> は、必ずしも変数 <var> を含む必要はありません。<start> と
<end> は変数値や数式で指定もできますが、それらの値は動的に変更すること
はできません。そうでないと副作用が起こり得ます。<end> が <start> より小
さい場合は、和の値は 0 となります。



File: gnuplot.info, Node: 定義済み変数_(Gnuplot-defined_variables), Next: ユーザ定義の変数と関数_(User-defined), Prev: 和_(Summation), Up: 式_(Expressions)

定義済み変数 (Gnuplot-defined variables)
----------------------------------------




gnuplot は、プログラムの現在の内部状態と直前の描画を反映するような読み
出し専用の変数をいくつか持っています。これらの変数の名前は、例えば
GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN のように "GPVAL_" で
始まります。これらすべての一覧とその値を見るには、`show variables
all`と入力してください。ただし、軸のパラメータに関連する値 (範囲、対数
軸であるか等) は、現在 `set` したものではなく、最後に描画されたものが使
用されます。

例: 点 [X,Y] のスクリーン比での座標を計算する方法
          GRAPH_X = (X - GPVAL_X_MIN) / (GPVAL_X_MAX - GPVAL_X_MIN)
          GRAPH_Y = (Y - GPVAL_Y_MIN) / (GPVAL_Y_MAX - GPVAL_Y_MIN)
          SCREEN_X = GPVAL_TERM_XMIN + GRAPH_X * (GPVAL_TERM_XMAX - GPVAL_TERM_XMIN)
          SCREEN_Y = GPVAL_TERM_YMIN + GRAPH_Y * (GPVAL_TERM_YMAX - GPVAL_TERM_YMIN)
          FRAC_X = SCREEN_X / GPVAL_TERM_XSIZE
          FRAC_Y = SCREEN_Y / GPVAL_TERM_YSIZE




読み出し専用変数 GPVAL_ERRNO は、任意の gnuplot コマンドがあるエラーの
ために早く終わってしまった場合に 0 でない値にセットされ、直前のエラーメッ
セージは文字列変数 GPVAL_ERRMSG に保存されます。GPVAL_ERRNO と
GPVAL_ERRMSG は、コマンド `reset errors` を使ってクリアできます。

`mouse` 機能が使える対話型入出力形式は、"MOUSE_" で始まる読み出し専用変
数をいくつか持っています。詳細は、以下参照: *Note variables::。

`fit` 機能は、"FIT_" で始まるいくつかの変数を使用しますので、そのような
名前を使うのは避けるべきでしょう。しかし、`fit` の使用に際しては、例え
ば "FIT_LIMIT" のように再定義をする必要があるような変数はあります。
`set fit errorvariables` とすると各当てはめ変数のエラーは、そのパラメー
タ名に "_err" を追加した変数に保存されます。詳細は、以下参照: `fit`。

以下も参照: *Note variables::, `reset errors`,
*Note variables::, `fit`。




File: gnuplot.info, Node: ユーザ定義の変数と関数_(User-defined), Prev: 定義済み変数_(Gnuplot-defined_variables), Up: 式_(Expressions)

ユーザ定義の変数と関数 (User-defined)
-------------------------------------




新たなユーザ定義変数と 1 個から 12 個までの引数を持つユーザ定義関数を、
任意の場所で定義したり使ったりすることができます。それは *Note plot::
コマンド上でも可能です。

ユーザ定義関数書式:
           <func-name>( <dummy1> {,<dummy2>} ... {,<dummy12>} ) = <expression>


ここで <expression> は仮変数 <dummy1> から <dummy12> で表される数式です。

ユーザ定義変数書式:
           <variable-name> = <constant-expression>


例:
           w = 2
           q = floor(tan(pi/2 - 0.1))
           f(x) = sin(w*x)
           sinc(x) = sin(pi*x)/(pi*x)
           delta(t) = (t == 0)
           ramp(t) = (t > 0) ? t : 0
           min(a,b) = (a < b) ? a : b
           comb(n,k) = n!/(k!*(n-k)!)
           len3d(x,y,z) = sqrt(x*x+y*y+z*z)
           plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)


           file = "mydata.inp"
           file(n) = sprintf("run_%d.dat",n)


最後の 2 行の例は、ユーザ定義文字列変数と、ユーザ定義文字列関数を意味し
ています。



変数 `pi` (3.14159...) と `NaN` (IEEE 非数 ("Not a Number")) はあらかじ
め定義されています。これらが必要なければ、他のものに再定義することも可
能ですし、以下のようにして元の値に復帰することもできます:

           NaN = GPVAL_NaN
           pi  = GPVAL_pi


他にもいくつかの変数が、例えば対話型入出力形式でのマウス操作や当てはめ
(fit) などの gnuplot の動作状態に応じて定義されます。詳細は以下参照:
*Note variables::。

ある変数 V が既に定義されているかどうかは、式 exists("V") でチェックで
きます。例:
           a = 10
           if (exists("a")) print "a is defined"
           if (!exists("b")) print "b is not defined"


変数名や関数名の命名規則は、大抵のプログラミング言語と同じで、先頭はア
ルファベットで、その後の文字はアルファベット、数字、"_" が使えます。

各関数の定義式は、'GPFUN_' という接頭辞を持つ特別な文字列値変数として利
用できます。

例:
           set label GPFUN_sinc at graph .05,.95


以下参照: *Note functions::, *Note functions::, *Note variables::,
*Note macros::, *Note value::。



File: gnuplot.info, Node: フォント, Next: ヘルプの用語解説_(Glossary), Prev: 式_(Expressions), Up: gnuplot

フォント
========


gnuplot それ自身にはどんなフォントも含まれてはおらず、外部フォント処理
に頼っているだけで、その細部は悲しいことに出力形式毎に異なります。ここ
では、複数の出力形式に適用されるフォント機構について説明します。ここに
上げたもの以外の出力形式でのフォントの使用に関しては、その出力形式のド
キュメントを参照してください。

* Menu:

* cairo_(pdfcairo::
* gd_(png::
* postscript_(カプセル化_postscript_*.eps_も)::



File: gnuplot.info, Node: cairo_(pdfcairo, Next: gd_(png, Prev: フォント, Up: フォント

cairo (pdfcairo, pngcairo, epscairo, wxt 出力形式)
--------------------------------------------------








すみません。このセクションはまだできていません。これらの出力形式は、フォ
ントの検索とアクセスに外部の fontconfig ツール群を使用します。
fontconfig ユーザマニュアル
(http://fontconfig.org/fontconfig-user.html)を参照してください。これは、
gnuplot で一般的な名前やサイズでフォントを要求することを可能にし、必要
ならば fontconfig に同等のフォントを代用させることもできるので、通常は
これで十分でしょう。以下は、多分いずれも機能します:
          set term pdfcairo font "sans,12"
          set term pdfcairo font "Times,12"
          set term pdfcairo font "Times-New-Roman,12"





File: gnuplot.info, Node: gd_(png, Next: postscript_(カプセル化_postscript_*.eps_も), Prev: cairo_(pdfcairo, Up: フォント

gd (png, gif, jpeg terminals)
-----------------------------







png, gif, jpeg 出力形式のフォント処理は、外部ライブラリ libgd によって
行われます。libgd は、次の 5 種類の基本フォントを直接提供しています:
`tiny` (5x8 ピクセル), `small` (6x12 ピクセル), `medium`, (7x13 Bold),
`large` (8x16), `giant` (9x15 ピクセル)。これらのフォントは大きさを変更
したり回転したりすることはできません。使用する際は、`font` キーワードの
代わりに上のキーワードを指定します。例:
          set term png tiny


多くのシステムで、libgd は Adobe Type 1 フォント (*.pfa) と TrueTypeフォ
ントへのアクセスも提供します。その場合フォント自身の名前ではなく、フォ
ントファイルの名前を、"<face> {,<pointsize>}" の形式で与えます。ここで、
<face> はフォントファイルのフルパス名か、または環境変数GDFONTPATH で指
示されるディレクトリの一つの中のファイル名の先頭部分、のいずれかです。
よって、'set term png font "Face"' は、<あるディレクトリ>/Face.ttf か
<あるディレクトリ>/Face.pfa というファイル名のフォントを探そうとします。
例えば、GDFONTPATH に`/usr/local/fonts/ttf:/usr/local/fonts/pfa` が含ま
れている場合は、以下のコマンドの 2 つずつはいずれも同じことになります:
          set term png font "arial"
          set term png font "/usr/local/fonts/ttf/arial.ttf"
          set term png font "Helvetica"
          set term png font "/usr/local/fonts/pfa/Helvetica.pfa"

デフォルトのフォントサイズも同時に指定するには:
          set term png font "arial,11"


TrueType と Adobe Type 1 フォントは、完全に大きさの変更や回転が可能です。
set term" コマンドでフォントを指定しなかった場合、gnuplot は別のデフォ
ルトフォントの設定があるかどうかを調べるために環境変数
GNUPLOT_DEFAULT_GDFONT を参照します。



File: gnuplot.info, Node: postscript_(カプセル化_postscript_*.eps_も), Prev: gd_(png, Up: フォント

postscript (カプセル化 postscript *.eps も)
-------------------------------------------




PostScript フォント処理は、プリンタか表示ソフトが行います。もし、あなた
のコンピュータにフォントが一切なくても、gnuplot は正しい PostScriptファ
イル、またはカプセル化 PostScript (*.eps) ファイルを生成できます。
gnuplot は単に出力ファイル中にフォントを名前として入れるだけで、プリン
タや表示ソフトがその名前からフォントを見つけるか近似することを仮定して
います。

PostScript プリンタや表示ソフトはすべて、標準的な Adobe フォントセット
`Times-Roman`, `Helvetica`, `Courier`, `Symbol` は知っているはずです。
多分その他にも多くのフォントが使えるようになっていると思いますが、それ
ら特定のフォントセットはあなたのシステムやプリンタの設定に依存します。
gnuplot は、それは知りませんし気にもしません。gnuplot が作成した *.psや
*.eps 出力は、あなたの要求したフォント名を単に持っているだけです。

よって、
          set term postscript eps font "Times-Roman,12"

は、すべてのプリンタや表示ソフトに適切な出力を作成します。

一方、
          set term postscript eps font "Garamond-Premier-Pro-Italic"

は、正しい PostScript を含む出力ファイルを作成しますが、それは特殊なフォ
ントを参照しますので、一部のプリンタや表示ソフトしか、要求したその特定
のフォントは表示できないでしょう。大抵の場合は別なフォントで代用されま
す。

しかし、指定したフォントを出力ファイル中に埋め込んで、どんなプリンタで
もそれを使うようにすることも可能です。これには、あなたのシステムに適切
なフォント記述ファイルがあることが必要となります。この方法でフォントを
埋め込む場合、特定のライセンスが必要となるフォントファイルもあることに
注意してください。より詳細な説明や例については、以下参照: `postscript
fontfile`。



File: gnuplot.info, Node: ヘルプの用語解説_(Glossary), Next: 線種、色、スタイル_(linetypes), Prev: フォント, Up: gnuplot

ヘルプの用語解説 (Glossary)
===========================


このドキュメント全体に渡って、用語に関する一貫性の維持が考えられていま
す。しかしこの試みは完全には成功していません。それは `gnuplot` が時間を
かけて進化してきたように、コマンドやキーワードの名前もそのような完全性
を排除するかのように採用されて来ているからです。この節では、これらのキー
ワードのいくつかがどのように使われているかを説明します。

"ページ (page)"、"表示画面 (screen)"、"キャンバス (canvas)" は、
`gnuplot` がアクセス可能な領域全体を指します。デスクトップではそれはウィ
ンドウ全体を指し、プロッタでは、一枚の紙全体、svga モードでは、モニタス
クリーン全体を指します。

表示画面は、一つ、またはそれ以上の "グラフ描画 (plot)" を含みます。グラ
フ描画は一つの横座標と一つの縦座標で定義されますが、余白 (margin) やそ
の中に書かれる文字列 (text) 同様、それらは実際にその上に表示されている
必要はありません。

グラフ描画は一つの "グラフ" を含みます。グラフは一つの横座標と一つの縦
座標で定義されますが、これらは実際にその上に表示されている必要はありま
せん。

グラフは一つまたはそれ以上の "曲線 (line)" を含みます。曲線は一つの関数、
またはデータ集合です。用語 "line" は描画スタイルとしても使われます。さ
らにこの用語は "文字列の一行 (a line of text)" のように使われることもあ
ります。多分文脈からそれらは区別できるでしょう。

一つのグラフ上の複数の曲線はそれぞれ名前を持ちます。その名前は、その曲
線の表現に使われる描画スタイルのサンプルとともに "(説明) key" 内に一覧
表示されます。説明は、時には "(表題) legend" とも呼ばれます。

用語 "タイトル (title)" は `gnuplot` では複数の意味で使われます。このド
キュメントではそれらを区別するために、形容詞として "描画の (plot)"、"曲
線の (line)"、"説明の (key)" を頭につけたりもします。2 次元のグラフは
4 つまでの見出し付けされる軸を持つことができます。これら 4 つの軸の名前
はそれぞれ、グラフ描画の下の境界に沿う軸である "x"、左の境界に沿う軸
y"、上の境界に沿う軸 "x2"、右の境界に沿う軸 "y2" となっています。以下参
照: `axes`。

3 次元のグラフは 3 つまでの見出し付けされる軸 (`axes`) "x","y","z" を持
つことができます。どの特定の軸に関してもそれがグラフ上でどこに書かれる
かを述べることはできません。それは、*Note view:: でグラフを見る方向を変
更できるからです。

データファイルに関する議論では、用語 "行 (record)" を復活し、ファイルの
一行の文字列、すなわち、改行文字や行末文字同士の間の文字列、を指し示す
のに使います。"点 (point)" は行から取り出した一つのデータです。"データ
ブロック (datablock)" は、空行で区切られた連続した複数の行からなる点の
集合です。データファイルの議論の中で "line" が参照される場合は、これは
データブロックの部分集合を指します。

(訳注: この日本語訳の中ではここに書かれているような用語の統一は考慮され
てはおらず、よって混乱を引き起こす可能性があります。厳密には原文を参照
すべきでしょう。)



File: gnuplot.info, Node: 線種、色、スタイル_(linetypes), Next: マウス入力_(mouse_input), Prev: ヘルプの用語解説_(Glossary), Up: gnuplot

線種、色、スタイル (linetypes)
==============================



gnuplot の各出力形式は "線種 (linetype)" をある程度用意しています。それ
らは色、太さ、点線/破線のパターン、または色と点線/破線の組合せで違いを
表現しています。特定の出力形式のデフォルトの線種は、その出力形式を設定
した (*Note terminal::) 後で *Note test:: コマンドを発行することで確認
できます。定義されている色、点線/破線のパターンはすべての出力形式で同じ
ものであるという保証は何もありませんが、線種 -1 は特別に全ての出力形式
で、最も普通の表示色 (通常は黒) の実線を意味しています。また、多くの出
力形式で、背景色での実線を意味する特別な線種 "bgnd" も認識します。

デフォルトの線種 (linetype) の属性は、対話的か初期化ファイルのいずれか
によって再定義可能です。これは、すべての gnuplot 描画コマンドで使用され
る線の色や他の属性をカスタマイズすることを可能にします。以下参照: `set
linetype`。

デフォルトでは、一つの描画コマンド内での関数やデータファイルの並びには、
順番に線種が割り当てられます。そのデフォルトの順列は、関数、データファ
イル、またはその他の描画要素に個別に線種を指定することで上書きできます。

例:

          plot "foo", "bar"                 # 線種 1, 2 で 2 ファイルを描画
          plot sin(x) linetype 4            # 出力形式に依存する線種色 4
          plot sin(x) lt -1                 # 黒



多くの出力形式で、ユーザ定義色を定義できるようになっています。色の定義
は明示的な rgb (赤、緑、青) を指定するか、色名か、現在の pm3d パレット
を参照する色の値のいずれかで行ないます。

例:

          plot sin(x) lt rgb "violet"       # gnuplot の持つ色名の一つ
          plot sin(x) lt rgb "#FF00FF"      # 明示的な 16 進 RGB 3 つ組
          plot sin(x) lt palette cb -45     # 現在のパレットの cbrange の
                                            # -45 に対応する色
          plot sin(x) lt palette frac 0.3   # パレットに対応する小数値


以下参照: `show colornames`, *Note palette::, *Note cbrange::。

点線/破線のパターンをサポートする出力形式では、デフォルトの線種は点線/
破線のパターンと色の両方が定義されています。今の所 gnuplot には、点線/
破線パターンを変更する仕組みがないので、特定の点線パターンと特定の色を
組み合わせたい場合は、先にその点線パターンを持つ線種 (linetype) を選択
し、デフォルトの色をキーワード `linecolor` (省略形は `lc`) で上書きする
必要があります。例えば、postscript 出力形式のデフォルトの線種 3 は青の
破線です。以下の描画コマンドは同じ破線パターンで 3 つの描画を行ないます
が、一つは青 (デフォルト)、一つは赤 (線種 1 のデフォルト色)、もう一つは
金色になります。

例:

          set term postscript dashed color
          plot 'foo' lt 3, 'baz' lt 3 linecolor 1, 'bar' lt 3 lc rgb 'gold'



* Menu:

* 色指定_(colorspec)::
* linestyles_と_linetypes::



File: gnuplot.info, Node: 色指定_(colorspec), Next: linestyles_と_linetypes, Prev: 線種、色、スタイル_(linetypes), Up: 線種、色、スタイル_(linetypes)

色指定 (colorspec)
------------------








多くのコマンドで、明示的な色の指定をともなった線種を指定することができ
ます。出力形式に依存する色の選択は、使用している出力形式が RGB カラーか
pm3d パレットをサボートしている場合にのみ利用可能です。

書式:

           ... {linecolor | lc} {<colorspec> | <n>}
           ... {textcolor | tc} {<colorspec> | {linetype | lt} <n>}


<colorspec> は以下の形式のいずれかです:

           rgbcolor "colorname"
           rgbcolor "#RRGGBB"
           rgbcolor variable       # 色は入力ファイルから読み込む
           palette frac <val>      # <val> は 0 から 1 の値
           palette cb <value>      # <val> は cbrange の範囲の値
           palette z
           variable                # 入力ファイルから色番号を読み込む


<n> は、その線種 (linetype) 番号が使う色を意味します。以下参照:
*Note test::。

"colorname" は gnuplot が内部に持っている色の名前のうちの一つを指定しま
す。有効な名前の一覧に関しては、以下参照: `show colornames`。

"#RRGGBB" は "#" 記号の後に 16 進定数を並べます。RRGGBB は、赤、緑、青
の色の成分を意味し、それぞれは 0 - 255 の範囲の数です。例えば、マゼンタ
(紫) = 最も明るい赤 + 最も明るい青、なので、#FF00FF と表され、これは
16 進数で、(255 << 16) + (0 << 8) + (255) を意味しています。

カラーパレットとは、色の線型な勾配で、単一の数値を特定の色に滑らかに対
応づけます。常にそのような 2 つの対応付けが効力を持ちます。`palette
frac` は 0 から 1 までの小数値を、カラーパレットの全範囲に対応付けるも
ので、`palette cb` は、色軸の範囲を同じカラーパレットへ割り当てるもので
す。以下参照: *Note cbrange::, `set colorbox`。これらの対応付けのどちら
かを使って、現在のパレットから定数色を選び出すことができます。

"palette z" は、各描画線分や描画要素の z の値を、パレットへ対応づけられ
ている cbrange の範囲に対応づけます。これにより、3 次元の曲線や曲面に沿っ
て色を滑らかに変化させることができます。これは、2 次元描画で、パレット
値を追加の列データから読み込ませて色付けするのにも使えます (すべての 2
次元描画スタイルがこの追加列を認識するわけではありません)。

* Menu:

* background_color::
* linecolor_variable::
* rgbcolor_variable::



File: gnuplot.info, Node: background_color, Next: linecolor_variable, Prev: 色指定_(colorspec), Up: 色指定_(colorspec)

background color
................



現在は多くの出力形式でグラフの背景色を明示的に設定できます。特別な線種
(linetype) `bgnd` はその色で描画しますが、その `bgnd` は色としても認識
されます。例:
          # 以下はキャンバスの一部分を背景色で上書きすることで消去します。
          set term wxt background rgb "gray75"
          set object 1 rectangle from x0,y0 to x1,y1 fillstyle solid fillcolor bgnd
          # 以下は x 軸に沿った「見えない」線を描きます。
          plot 0 lt bgnd




File: gnuplot.info, Node: linecolor_variable, Next: rgbcolor_variable, Prev: background_color, Up: 色指定_(colorspec)

linecolor variable
..................

`lc variable` は、入力データの一つの列から読んだ値を線種 (linetype) の
番号として使い、その線種に属する色を使うようプログラムに指示します。よっ
てこれは、*Note using:: 指定子へ対応する列の指定の追加を必要とします。
文字の色も同様に、`tc variable` で指定できます。

例:
           # データの 3 列目を、個々の点に色を割り当てるのに使用
           plot 'data' using 1:2:3 with points lc variable


           # 一つのデータファイルには複数のデータ集合を入れることが可能で、
           # それらは 2 行の空行で分離されています。個々のデータ集合には
           # index 値が割り当てられていて (以下参照: *Note index::)、using 指定の
           # column(-2) で取得できます。以下参照: `pseudocolumns`。以下の例
           # は -2 の column 値を使って、個々のデータ集合を異なる線色で描画
           # します。
           plot 'data' using 1:2:(column(-2)) with lines lc variable





File: gnuplot.info, Node: rgbcolor_variable, Prev: linecolor_variable, Up: 色指定_(colorspec)

rgbcolor variable
.................

グラフの各データ点、各線分、または各ラベルにそれぞれ異なる色を割り当て
ることができます。`lc rgbcolor variable` は、データファイルの各行から
RGB 色の情報を読み込むようプログラムに指示します。よってこれは、*Note
using:: 指定子による対応する列の指定の追加を必要とし、その列は 24-bit形
式の RGB の 3 つ組であるとみなされます。その値をデータファイルから直接
与える場合は、これは最も簡単な形式の 16 進値で与えます (以下参照:
`rgbcolor`)。一方で、以下の例のように 24-bit RGB 色として評価されるよう
な数式を *Note using:: 指定子に入れることもできます。文字の色も同様に、
`tc rgbcolor variable` で指定できます。

例:
           # 3 次元描画で、各 x,y,z 座標に対応した赤、緑、青の成分を持つ色
           # のついた点を配置
           rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
           splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable





File: gnuplot.info, Node: linestyles_と_linetypes, Prev: 色指定_(colorspec), Up: 線種、色、スタイル_(linetypes)

linestyles と linetypes
-----------------------

線は、線幅のような他の属性も持つことができます。点 (point) の記号に対す
る同様の属性とともに、これらの属性をコマンド `set style line` を使って
ユーザ定義 "ラインスタイル (linestyle)" として結びつけることができます。
一度定義された linestyle は、plot コマンド中で、一つまたは多くの描画要
素に対してその表示を制御するのに使うことができます。

`linetypes` は永続的 (明示的にそれらを再定義するまでは保持される) です
が、`linestyles` は一時的なものです。次のグラフィックの状態がリセットさ
れるまでの間しか保持されません。

例:

          # 新しいラインスタイルを、出力形式に依存しない色 cyan、線幅が 3、
          # 点種 6 (丸の中に点) と定義
          set style line 5 lt rgb "cyan" lw 3 pt 6
          plot sin(x) with linespoints ls 5          # 定義スタイル 5 で





File: gnuplot.info, Node: マウス入力_(mouse_input), Next: 描画_(Plotting), Prev: 線種、色、スタイル_(linetypes), Up: gnuplot

マウス入力 (mouse input)
========================

多くの出力形式で、現在の描画にマウスを使って作用をすることが可能になっ
ています。そのうちいくつかはホットキーの定義もサポートしていて、マウス
カーソルが有効な描画ウィンドウにあるときに、あるキーを押すことであらか
じめ定義した関数を実行させることができます。マウス入力を `batch` コマ
ンドスクリプトと組み合わせることも可能で、例えば `pause mouse` として、
その後にマウスクリックによってパラメータとして返って来るマウス変数をそ
の後のスクリプト動作に反映させることができます。以下参照: `bind`,
*Note variables::。また以下も参照: `set mouse`。

* Menu:

* bind::
* マウス用の変数_(Mouse_variables)::



File: gnuplot.info, Node: bind, Next: マウス用の変数_(Mouse_variables), Prev: マウス入力_(mouse_input), Up: マウス入力_(mouse_input)

bind
----





書式:
           bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
           bind <key-sequence> ""
           reset bind


`bind` は、ホットキーの定義、再定義に使用します。ホットキーとは、入力カー
ソルがドライバのウィンドウ内にあるときに、あるキー、または複数のキーを
押すことで、gnuplot のコマンド列を実行させる機能のことを言います。
`bind` は、gnuplot が `mouse` をサポートするようにコンパイルされていて
かつマウスが有効な出力形式上で使われてる場合にのみ有効であることに注意
してください。ユーザ指定のキー割当 (binding) は、組み込み (builtin) キー
割当を置き換えますが、<space> と 'q' は通常は再定義はできません。その唯
一の例外については、以下参照: `bind space`。

マウスボタンは 1 のみ、そして 2D 描画に関してのみ再定義できます。

ホットキーの一覧を得るには `show bind`, または `bind` とタイプするか、
グラフウィンドウ上でホットキー 'h' を入力してください。

キー定義は、`reset bind` でデフォルトの状態に復帰できます。

修飾キーを含む複数のキーの定義は引用符で囲む必要があることに注意してく
ださい。

標準ではホットキーは現在の描画ウィンドウ上に入力カーソルがある場合のみ
認識されます。`bind allwindows <key> ...` (`bind all <key> ...` と省略
可) は、<key> の割当を、それが現在の有効なものか否かに関わらず、すべて
の gnuplot の描画ウィンドウ上で可能にします。この場合、gnuplot 変数
MOUSE_KEY_WINDOW にそれが行なわれたウィンドウの ID が保存されるのでそれ
をキーに割り当てたコマンドで使用することができます。

例:

- キー割当の設定:

         bind a "replot" bind "ctrl-a" "plot x*x" bind "ctrl-alt-a" 'print
         great"' bind Home "set view 60,30; replot" bind all Home 'print
         This is window ",MOUSE_KEY_WINDOW'


- キー割当を表示:
         bind "ctrl-a" # ctrl-a に対するキー割当を表示bind # 全てのキー定義
         を表示show bind # 全てのキー定義を表示


- キー割当を削除:
         bind "ctrl-alt-a" "" # ctrl-alt-a のキー割当を削除(組み込みキー定義
                                  は削除されません) reset bind # デフォルト
                                  (組み込み) のキー定義を導入bind!  #
                                  reset bind" の別の形式 (非推奨)


- トグルスイッチ形式にキー割当:
       v=0 bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term
       x11 raise"


修飾キー (ctrl / alt) は大文字小文字の区別はありませんが、キーはそうで
はありません:
         ctrl-alt-a == CtRl-alT-a
         ctrl-alt-a != ctrl-alt-A


修飾キー (alt == meta) の一覧:
         ctrl, alt


サポートされている特殊キーの一覧:

        "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
        "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
        "PageUp", "PageDown", "End", "Begin",


        "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
        "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
        "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
        "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
        "KP_Divide",


        "KP_1" - "KP_9", "F1" - "F12"


以下は、実際のキーではなく、ウィンドウに関するイベントです:

        "Button1" "Close"


以下も参照: `mouse`。

* Menu:

* bind_space::



File: gnuplot.info, Node: bind_space, Prev: bind, Up: bind

bind space
..........

gnuplot が、configure 時にオプション --enable-rase-console をつけてイン
ストールされた場合は、描画ウィンドウ内で <space> をタイプするとgnuplot
のコマンドウィンドウが前面に出ます。このホットキーは、'gnuplot -ctrlq'
のようにして gnuplot を起動するか、または X リソースの 'gnuplot*ctrlq'
を設定することで ctrl-space に変更できます。以下参照: `x11
command-line-options`。



File: gnuplot.info, Node: マウス用の変数_(Mouse_variables), Prev: bind, Up: マウス入力_(mouse_input)

マウス用の変数 (Mouse variables)
--------------------------------

`mousing` (マウス機能) が有効な場合、現在のウィンドウ上でのマウスクリッ
クによって gnuplot のコマンドライン上で使うことができる色々なユーザ変数
が設定されます。クリック時のマウスの座標は変数 MOUSE_X, MOUSE_Y,
MOUSE_X2, MOUSE_Y2 に代入されます。クリックされたボタンや、そのときのメ
タキーの状態は MOUSE_BUTTON, MOUSE_SHIFT, MOUSE_ALT, MOUSE_CTRL に代入
されます。これらの変数は任意の描画の開始時には未定義で、有効な描画ウィ
ンドウ中でのマウスクリックイベントによって初めて定義されます。有効な描
画ウィンドウ中でマウスが既にクリックされたかどうかをスクリプトから調べ
るには、これらの変数のうちのどれか一つが定義されているかどうかをチェッ
クすれば十分です。

           plot 'something'
           pause mouse
           if (defined(MOUSE_BUTTON)) call 'something_else'; \
           else print "No mouse click."


描画ウィンドウ上での一連のキー入力を追跡することも、マウスコードを使う
ことで可能となります。

           plot 'something'
           pause mouse keypress
           print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y


`pause mouse keypress` が、キー入力で終了した場合は MOUSE_KEY には押さ
れたキーの ASCII コードが保存されます。MOUSE_CHAR にはその文字自身が文
字列値として保存されます。pause コマンドが (例えば ctrl-C や描画ウィン
ドウが外部から閉じられるなどして) 異常終了した場合は MOUSE_KEY は -1に
なります。

マウスによる拡大の後の新しい描画範囲は、GPVAL_X_MIN, GPVAL_X_MAX,
GPVAL_Y_MIN, GPVAL_Y_MAX で参照できることに注意してください。以下参照:
*Note variables::。





File: gnuplot.info, Node: 描画_(Plotting), Next: 初期化_(Startup_(initialization)), Prev: マウス入力_(mouse_input), Up: gnuplot

描画 (Plotting)
===============


`gnuplot` には描画を生成する 3 つのコマンド、*Note plot::, `splot`,
*Note replot::があります。*Note plot:: は 2 次元描画を生成し、`splot`
は 3 次元描画 (もちろん実際には 2 次元面への射影) を生成します。*Note
replot:: は与えられた引数を、直前の *Note plot:: または `splot` コマン
ドに追加し、それを実行します。

描画に関する一般的な情報の大半は、*Note plot:: に関する項で見つかります。
3次元描画に固有の情報は `splot` の項にあります。

*Note plot:: は xy 直交座標系と極座標系が使えます。極座標系の詳細に関し
ては以下参照: *Note polar::。`splot` は xyz 直交座標系のみしか扱えませ
んが、コマンド *Note mapping:: で他の 2, 3 の座標系を使用することが出来
ます。さらに、オプション *Note using:: を使えば、*Note plot:: でも
`splot` でもほとんどどんな座標系でもそれを定義して使うことが出来ます。


*Note plot:: では、4 つの境界 x (下), x2 (上), y (左), y2 (右) をそれぞ
れ独立な軸として扱うこともできます。オプション `axes` で、与えられた関
数やデータ集合をどの軸のペアで表示させるかを選べます。また、各軸の縮尺
や見出しづけを完全に制御するために十分な補佐となる `set` コマンド群が存
在します。いくつかのコマンドは、*Note xlabel:: のように軸の名前をその中
に持っていますし、それ以外のものは `set logscale xy` のように、1 つ、ま
たは複数の軸の名前をオプションとしてとります。z 軸を制御するオプション
やコマンドは 2 次元グラフには効力を持ちません。

`splot` は、点や線に加えて曲面や等高線を書くことができます。3 次元の関
数の格子定義に関する情報については、以下参照: *Note isosamples::。3 次
元データのファイルに必要な形態については、以下参照: *Note datafile::。
等高線に関する情報については、以下参照: `set contour`, *Note
cntrparam::。

`splot` での縮尺や見出し付けの制御は、x2 軸と y2 軸を制御するコマンドや
オプションは効果がなく、z 軸を制御するものにはもちろん効果がある、とい
うことを除けば *Note plot:: と全く同じです。



File: gnuplot.info, Node: 初期化_(Startup_(initialization)), Next: 文字列定数と文字列変数_(Strings), Prev: 描画_(Plotting), Up: gnuplot

初期化 (Startup (initialization))
=================================






起動時に、gnuplot はまずシステム用の初期設定ファイル `gnuplotrc` を探し
ます。そのファイルの置き場所は gnuplot のインストール時に決定され、
*Note loadpath:: で知ることができます。次にユーザのホームディレクトリ内
に個人用の設定ファイルを探します。そのファイルは Unix 系のシステムでは
`.gnuplot` であり、その他の処理系では `GNUPLOT.INI` となっています。
(Windows と OS/2 では、環境変数 `GNUPLOT` に設定されている名前のディレ
クトリ内にそれを探します; Windows では、変数 GNUPLOT が定義されていなけ
れば `USEPROFILE` を使用します)。注意: インストール時に `gnuplot` が最
初にカレントディレクトリを探すように設定できますが、セキュリティ上危険
なのでそれは推奨しません。



File: gnuplot.info, Node: 文字列定数と文字列変数_(Strings), Next: 置換とコマンドラインマクロ_(Substitution), Prev: 初期化_(Startup_(initialization)), Up: gnuplot

文字列定数と文字列変数 (Strings)
================================


文字列定数に加えて、ほとんどの gnuplot コマンドは文字列変数、文字列式ま
たは文字列を返す関数も受け付けます。例えば、以下の 4 つの plot のやり方
は結果として全て同じ描画タイトルを生成します:

           four = "4"
           graph4 = "Title for plot #4"
           graph(n) = sprintf("Title for plot #%d",n)


           plot 'data.4' title "Title for plot #4"
           plot 'data.4' title graph4
           plot 'data.4' title "Title for plot #".four
           plot 'data.4' title graph(4)


整数は、それが文字列結合演算子によって作用された場合は、文字列に変換さ
れますので、以下の例も上と同様に動作します:

           N = 4
           plot 'data.'.N title "Title for plot #".N


一般に、コマンドラインの各要素は、それらが標準的な gnuplot への命令文法
の一部分と認識されるもの以外は、有効な文字列変数としての評価のみが行な
われます。よって、以下のコマンド列は、恐らくは混乱を引き起こさないよう
に避けられるべきですが、文法的には間違ってはいません:

           plot = "my_datafile.dat"
           title = "My Title"
           plot plot title title


文字列に対する 3 つの二項演算子が用意されています: 文字列の結合演算子
.", 文字列の等号演算子 "eq", および文字列の不等号演算子 "ne" です。以下
の例では TRUE が表示されます。

          if ("A"."B" eq "AB") print "TRUE"


以下も参照: 2 つの文字列書式関数 *Note gprintf::, *Note sprintf::。


任意の文字列、文字列変数、文字列値関数に、範囲指定子をつけることにより
部分文字列を指定できます。範囲指定子は [begin:end] の形で、begin は部分
文字列の先頭位置、end は最後の位置です。位置指定は、最初の文字を 1番目
と見ます。先頭の位置、最後の位置は空、あるいは '*' でも構いません。その
場合、それは元の文字列自体の先頭、あるいは最後を意味します。例えば、
str[:] や str[*:*] はどちらも str の文字列全体を意味します。



File: gnuplot.info, Node: 置換とコマンドラインマクロ_(Substitution), Next: 区切りやカッコの使い方_(Syntax), Prev: 文字列定数と文字列変数_(Strings), Up: gnuplot

置換とコマンドラインマクロ (Substitution)
=========================================


gnuplot への命令文字列が最初に読み込まれた時点、すなわちまだそれが解釈
され、もしくは実行される前の段階で、2 つの形式の単語の置換が実行されま
す。それらはバッククォート (ASCII 番号 96) で囲まれているか、または @
(ASCII 番号 64) が頭についた文字列に対して行なわれます。

* Menu:

* バッククォートによるシステムコマンドの置換_(Substitution_backquotes)::
* 文字列変数のマクロ置換_(Substitution_macros)::
* 文字列変数、マクロ、コマンドライン置換_(mixing_macros_backquotes)::



File: gnuplot.info, Node: バッククォートによるシステムコマンドの置換_(Substitution_backquotes), Next: 文字列変数のマクロ置換_(Substitution_macros), Prev: 置換とコマンドラインマクロ_(Substitution), Up: 置換とコマンドラインマクロ_(Substitution)

バッククォートによるシステムコマンドの置換 (Substitution backquotes)
--------------------------------------------------------------------


シェルコマンドをバッククォートで囲むことによってコマンド置換を行うこと
ができます。このコマンドは子プロセスで実行され、その出力結果でコマンド
ラインのバッククォートで囲まれたコマンドを置き換えます。処理系によって
はパイプがサポートされている場合もあります。以下参照: `plot datafile
special-filenames`。

コマンド置換は、単一引用符内の文字列以外は、`gnuplot` のコマンドライン
中、どこででも使用可能です。

例:

以下の例は、`leastsq` というプログラムを実行し、その出力結果で、
`leastsq` を (まわりの引用符こみで) 置き換えます:
           f(x) = `leastsq`


ただし VMS では、
           f(x) = `run leastsq`


以下は現在の日付とユーザー名のラベルを生成します:
           set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
           set timestamp "generated on %Y-%m-%d by `whoami`"




File: gnuplot.info, Node: 文字列変数のマクロ置換_(Substitution_macros), Next: 文字列変数、マクロ、コマンドライン置換_(mixing_macros_backquotes), Prev: バッククォートによるシステムコマンドの置換_(Substitution_backquotes), Up: 置換とコマンドラインマクロ_(Substitution)

文字列変数のマクロ置換 (Substitution macros)
--------------------------------------------




コマンドラインのマクロ置換はデフォルトでは無効になっていますが、*Note
macros:: で有効にできます。マクロ置換が有効である場合、文字 @ は、コマ
ンドライン上でその文字列変数の値への置換を行なうのに使われます。文字列
変数の値としての文は、複数の単語からなることも可能です。これにより文字
列変数をコマンドラインマクロとして使うことが可能になります。この機能に
より展開できるのは文字列定数のみで、文字列を値に取る数式を使うことはで
きません。例:

           set macros
           style1 = "lines lt 4 lw 2"
           style2 = "points lt 3 pt 5 ps 2"
           range1 = "using 1:3"
           range2 = "using 1:5"
           plot "foo" @range1 with @style1, "bar" @range2 with @style2


この @ 記号を含む行は、その入力時に展開され、それが実際に実行されるとき
には次のように全部打ち込んだ場合と同じことになります。

           plot "foo" using 1:3 with lines lt 4 lw 2, \
                "bar" using 1:5 with points lt 3 pt 5 ps 2


関数 exists() はマクロの評価に関して有用でしょう。以下の例は、C が安全
にユーザ定義変数の名前に展開できるかどうかをチェックします。

           C = "pi"
           if (exists(C)) print C," = ", @C


マクロの展開は、単一引用符内、または二重引用符内では行なわれませんが、
バッククォート内ではマクロ展開されます。

マクロの展開は、gnuplot が新しいコマンド行を見たときに非常に早い段階で
gnuplot が処理し、そしてただ一度だけそれを行います。よって、

          A = "c=1"
          @A


のようなコードは正しく実行しますが、以下のような行はだめです。それは、
マクロの定義が同じ行にあるため展開に間に合わないからです。

          A = "c=1"; @A   # will not expand to c=1


コマンドを完成させて実行するには、コマンド *Note evaluate:: も有用でしょ
う。



File: gnuplot.info, Node: 文字列変数、マクロ、コマンドライン置換_(mixing_macros_backquotes), Prev: 文字列変数のマクロ置換_(Substitution_macros), Up: 置換とコマンドラインマクロ_(Substitution)

文字列変数、マクロ、コマンドライン置換 (mixing_macros_backquotes)
-----------------------------------------------------------------


文字列変数やバッククォートによる置換、マクロによる置換の相互関係は少し
ややこしいです。バッククォートはマクロ置換を妨げないので、

           filename = "mydata.inp"
           lines = ` wc --lines @filename | sed "s/ .*//" `


は、mydata.ipn の行数を整数変数 lines に保存することになります。また、
二重引用符はバッククォートの置換を妨げないので、

           mycomputer = "`uname -n`"


は、システムコマンド `uname -n` の返す文字列を文字列変数 mycomputer に
保存することになります。

しかし、マクロ置換は二重引用符内では機能しないので、システムコマンドを
マクロとして定義してそれをマクロとして利用しかつバッククォート置換を行
なうことはでできません。

            machine_id = "uname -n"
            mycomputer = "`@machine_id`"  # うまくいかない !


この失敗は、二重引用符が @machine_id をマクロとして解釈することを妨げて
いるからです。システムコマンドをマクロとして保存し、その後それを実行す
るには、バッククォート自体もマクロ内に含める必要があります。これは以下
のようにマクロを定義することで実現できます。sprintf の書式には 3 種類の
引用符全てが入れ子になっていることに注意してください。

           machine_id = sprintf('"`uname -n`"')
           mycomputer = @machine_id




File: gnuplot.info, Node: 区切りやカッコの使い方_(Syntax), Next: 時間/日付データ_(Time/Date), Prev: 置換とコマンドラインマクロ_(Substitution), Up: gnuplot

区切りやカッコの使い方 (Syntax)
===============================




リストや座標がコンマ (,) 区切りであるのに対し、オプションやそれに伴うパ
ラメータはスペース ( ) 区切りです。範囲はコロン (:) で区切ってかぎかっ
こ ([]) でくくりますし、文字列やファイル名は引用符でくくり、他にいくつ
かカッコ (()) でくくるものがあります。

コンマは以下の区切りで使用されます。`set` コマンドの *Note arrow::,
`key`, `label` の座標; 当てはめ (fit) られる変数のリスト (コマンド
`fit` のキーワード `via` に続くリスト); コマンド *Note cntrparam:: で指
定されるとびとびの等高線の値やそのループパラメータのリスト; `set` コマ
ンドの*Note dgrid3d:: *Note dummy::, *Note isosamples::, *Note
offsets::, *Note origin::, *Note samples::, *Note size::, `time`,
*Note view:: の引数; 目盛りの位置やそのループパラメータのリスト; タイト
ルや軸の見出しの位置; *Note plot::, *Note replot::, `splot` コマンドの
x,y,z 座標の計算に使われる媒介変数関数のリスト; *Note plot::, *Note
replot::, `splot` コマンドの複数の描画 (データ、または関数) のそれぞれ
の一連のキーワードのリスト。

(丸) カッコは、目盛りの見出しを (ループパラメータではなく) 明示的に集合
与える場合の区切りとして、または `fit`, *Note plot::, *Note replot::,
`splot` コマンドの *Note using:: フィルタでの計算を指示するために使われ
ます。

(カッコやコンマは通常の関数の表記でも使われます。)

かぎかっこは、`set`, *Note plot::, `splot` コマンドでは範囲を区切るのに
使われます。

コロンは `range` (範囲) 指定 (`set`, *Note plot::, `splot` コマンドで使
われる) の両端の値を区切るのに、または *Note plot::, *Note replot::,
`splot`, `fit` コマンドの *Note using:: フィルタの各エントリを区切るの
に使われます。

セミコロン (;) は、一行のコマンド行内で与えられる複数のコマンドを区切る
のに使われます。

中カッコ ({}) は、拡張文字列処理モード (enhanced text mode) の記述や、
if/then/else 文のブロックの区切りとして使われますし、または複素数を記述
するのにも使われます: {3,2} = 3 + 2i となります。

EEPIC, Imagen, Uniplex, LaTeX, TPIC の各出力形式では、単一引用符内の\\
または二重引用符内の \\\\ で改行を示すことが可能です。

* Menu:

* 引用符_(Quotes)::



File: gnuplot.info, Node: 引用符_(Quotes), Prev: 区切りやカッコの使い方_(Syntax), Up: 区切りやカッコの使い方_(Syntax)

引用符 (Quotes)
---------------


gnuplot は、文字列を区切るのに、二重引用符 (ASCII コード 34 番)、単一引
用符 (ASCII コード 39 番)、およびバッククォート (ASCII コード 96 番)の
3 種類の引用符を使います。

ファイル名は単一引用符、あるいは二重引用符内で囲みます。このマニュアル
では一般にコマンドの例示では、わかりやすくするためにファイル名は単一引
用符でくくり、他の文字列は二重引用符でくくります。

見出し (label)、タイトル (title)、またはその他の描画要素で使用される文
字列定数や複数行文字列は単一引用符、あるいは二重引用符内で囲みます。引
用符で囲まれた文字列のさらなる処理の結果は、どの引用符記号を選ぶかによっ
て変わります。

\n (改行) や \345 (8 進表記の文字コード) のようなバックスラッシュ (\)に
よる特殊文字表現は、2 重引用符内の文字列では効力を持ちます。単一引用符
内では、バックスラッシュ自体が通常の文字と見なされます。単一引用符内の
文字列で単一引用符自体 (ASCII コード 39 番) を使うには、それを重ねて書
く必要があります。つまり、文字列 "d\" s' b\\" と、'd" s" b\' は完全に同
じものとなります。

1 つの複数行文字列に関する位置合わせは各行に同等に働きます。よって、中
央に位置合わせされた文字列
           "This is the first line of text.\nThis is the second line."

は次のように表示されます:
                            This is the first line of text.
                               This is the second line.

しかし
           'This is the first line of text.\nThis is the second line.'

だと次のようになります。
               This is the first line of text.\nThis is the second line.


拡張文字列処理 (enhanced text processing) は二重引用符に対しても単一引
用符に対しても機能します。しかし、そのモードをサポートしている出力形式
でのみ働きます。以下参照: `enhanced text`。

バッククォート (｀｀) はコマンドライン中の置換のためにシステムコマンド
を囲むのに使います。以下参照: `substitution`。



File: gnuplot.info, Node: 時間/日付データ_(Time/Date), Prev: 区切りやカッコの使い方_(Syntax), Up: gnuplot

時間/日付データ (Time/Date)
===========================


`gnuplot` は入力データとして時間/日付情報の使用をサポートしています。こ
の機能は `set xdata time`, `set ydata time` などのコマンドによって有効
になります。

内部では全ての時間/日付は 2000 年からの秒数に変換されます。コマンド
*Note timefmt:: は全ての入力書式を定義します。データファイル、範囲、軸
の目盛りの見出し、ラベルの位置。手短に言えば、データの値を受けとる全て
のものがこの書式にしたがって受けとらなければいけません。一時には一つの
入力書式のみが有効なので、同じときに入力される全ての時間/日付のデータは
同じ書式である必要があります。よって、ファイル内の x と y の両方が時間
/日付データである場合は、それらは同じ書式でなければいけません。

秒数へ (秒数から) の変換は国際標準時 (UT; グリニッジ標準時 (GMT) と同じ)
が使われます。各国標準時や夏時間への変換の機能は何も持ち合わせていませ
ん。もしデータがすべて同じ標準時間帯に従っているなら (そして全てが夏時
間か、そうでないかのどちらか一方にのみ従うなら) これに関して何も心配す
ることはありません。しかし、あなたが使用するアプリケーションで絶対的な
時刻を厳密に考察しなければいけない場合は、あなた自身が UT に変換すべき
でしょう。

*Note xrange:: のようなコマンドは、その整数値を *Note timefmt:: に従っ
て解釈し直します。*Note timefmt:: を変更してもう一度 `show` でその値を
表示させるとそれは新しい *Note timefmt:: に従って表示されます。このため、
もし機能を停止させるコマンド (*Note xdata:: のような) を与えると、その
値は整数値として表示されることになります。

コマンド *Note format:: または *Note format:: は、指定された軸が時間/日
付であるなしに関わらず目盛りの見出しに使われる書式を定義します。

時間/日付情報がファイルから描画される場合、*Note plot::, `splot` コマン
ドでは *Note using:: オプションを「必ず」使う必要があります。*Note
plot::, `splot` では各行のデータ列の分離にスペースを使いますが、時間/日
付データはその中にスペースを含み得るからです。もしタブ区切りを使用して
いるのなら、あなたのシステムがそれをどう扱うか確かめるために何度もテス
トする必要があるでしょう。

関数 `time` は、現在のシステム時刻を得るのに使えます。この値は、*Note
strftime:: 関数で日時文字列に変換できますし、*Note timecolumn:: と組み
合わせて相対的な日時グラフを作成するのにも使えます。引数の型はそれが返
すものを決定します。引数が整数の場合は time() は現在の時刻を 2000 年 1
月 1日からの整数として返し、引数が実数 (または複素数) ならば同様の値を
実数として返しますが、小数 (秒以下) 部分の精度は、オペレーティングシス
テムに依存します。引数が文字列ならば、それを書式文字列であるとみなし、
書式化された日時文字列を提供するようそれを *Note strftime:: に渡します。

次の例は時間/日付データの描画の例です。

ファイル "data" は以下のような行からなるとします:

           03/21/95 10:00  6.02e23


このファイルは以下のようにして表示されます:

           set xdata time
           set timefmt "%m/%d/%y"
           set xrange ["03/21/95":"03/22/95"]
           set format x "%m/%d"
           set timefmt "%m/%d/%y %H:%M"
           plot "data" using 1:3


ここで、x 軸の目盛りの見出しは "03/21" のように表示されます。

以下参照: `time_specifiers`。



File: gnuplot.info, Node: 描画スタイル_(plotting_styles), Next: コマンド_(Commands), Prev: gnuplot, Up: Top

描画スタイル (plotting styles)
******************************


gnuplot では、たくさんの描画スタイルが利用できます。それらは、アルファ
ベット順に以下に紹介されています。コマンド `set style data` と `set
style function` は、それ以降の*Note plot:: や `splot` コマンドに対して
デフォルトの描画スタイルを変更します。

描画スタイルは、コマンド *Note plot:: や `splot` の一部分として、明示的
にオプション指定することもできます。一つの描画の中で、複数の描画スタイ
ルを組み合わせたい場合は、各要素に対して描画スタイルを指定する必要があ
ります。

例:

          plot 'data' with boxes, sin(x) with lines


各描画スタイルは、それ自体がデータファイルからのいくつかのデータの組を
期待します。例えば、デフォルトでは `lines` スタイルは、y の値だけの1 列
のデータ (x の値は暗黙に順番に取られる)、または最初が x, 次が y の2 つ
の列を期待しています。ファイルの何列のデータを描画データと解釈させるう
まい方法に関する情報については、以下参照: *Note using::。


* Menu:

* boxerrorbars::
* boxes::
* boxplot::
* boxxyerrorbars::
* candlesticks::
* circles::
* ellipses::
* dots::
* filledcurves::
* financebars::
* fsteps::
* fillsteps::
* histeps::
* histograms::
* image::
* impulses::
* labels::
* lines::
* linespoints::
* points::
* polar::
* steps::
* rgbalpha::
* rgbimage::
* vectors::
* xerrorbars::
* xyerrorbars::
* yerrorbars::
* xerrorlines::
* xyerrorlines::
* yerrorlines::
* 3_次元_(曲面)_描画_(3D_(surface)_plots)::



File: gnuplot.info, Node: boxerrorbars, Next: boxes, Prev: 描画スタイル_(plotting_styles), Up: 描画スタイル_(plotting_styles)

boxerrorbars
============


描画スタイル *Note boxerrorbars:: は 2 次元のデータ描画でのみ利用可能で
す。これは *Note boxes:: と *Note yerrorbars:: スタイルの組合せです。こ
れは、3 列、または 4 列、または 5 列のデータを使用します:

          3 列:  x  y  ydelta
          4 列:  x  y  ydelta xdelta        # 箱の幅 != -2
          4 列:  x  y  ylow  yhigh          # 箱の幅 == -2
          5 列:  x  y  ylow  yhigh  xdelta


y の誤差が "ydelta" の形式で与えられて、箱の横幅があらかじめ -2.0 に設
定されて (`set boxwidth -2.0`) いなければ、箱の横幅は 4 列目の値で与え
られます。y の誤差が "ylow yhigh" の形式で与えられる場合は箱の横幅は 5
列目の値で与えられます。特別な場合として、"ylow yhigh" の誤差形式の 4列
のデータに対する `boxwidth = -2.0` という設定があります。この場合箱の横
幅は、隣接する箱にくっつくように自動的に計算されます。3 列のデータの場
合も、横幅は自動的に計算されます。

入力列を追加 (4,5,6 列目) すると、それらは各データ点毎の variable
color情報 (以下参照: `linecolor`, `rgbcolor variable`) として使われます。
誤差線は、箱の境界と同じ色で描画されます。

箱の高さは、*Note yerrorbars:: スタイル同様に y の誤差の値から決定され
ます。y-ydelta から y+ydelta まで、あるいは ylow から yhigh まで、これ
らは何列のデータが与えられているかによって決まります。以下も参照
errorbar デモ。 (http://www.gnuplot.info/demo/mgr.html)



File: gnuplot.info, Node: boxes, Next: boxplot, Prev: boxerrorbars, Up: 描画スタイル_(plotting_styles)

boxes
=====


*Note boxes:: スタイルは 2 次元描画でのみ利用可能です。これは与えられた
x 座標を中心とし、x 軸から (グラフの境界から、ではありません) 与えられ
た y座標までの箱を書きます。これは基本的に、2 列、または 3 列のデータを
使用します。余分な入力列は、variable 行や塗り潰し色の情報が提供されたも
のとして使用されます (以下参照: `rgbcolor variable`)。

          2 列:  x  y
          3 列:  x  y  x_width


箱の幅は 3 つのうち一つの方法で決定されます。入力データが 3 列目のデー
タを持っている場合は、それが箱の幅にセットされます。そうでなくて*Note
boxwidth:: コマンドで箱の幅がセットされていた場合は、それが使われます。
そのどちらでもない場合、箱の幅は、隣接する箱がくっつくように自動的に計
算されます。

箱の中身は現在の塗りつぶしスタイル (fillstyle) に従って塗りつぶされます。
詳細は、以下参照: `set style fill`。新しい塗りつぶしスタイルをplot コマ
ンド上で指定することもできます。

塗りつぶしスタイルが `empty` の場合は、箱は塗りつぶされません。

塗りつぶしスタイルが `solid` の場合は、箱は現在の描画色でベタ塗りされま
す。これには追加オプション <density> があり、それは塗りつぶし密度を意味
し、0 は背景色、1 は描画色そのものになります。

塗りつぶしスタイルが `pattern` の場合は、箱は現在の描画色であるパターン
で塗りつぶされますが、出力ドライバがサポートしている必要があります。

例:

データファイルを塗りつぶした箱で描画し、箱同士を少し垂直方向にスペース
を空ける (棒グラフ):

           set boxwidth 0.9 relative
           set style fill solid 1.0
           plot 'file.dat' with boxes


パターンでの塗りつぶしスタイルの箱で sin と cos のグラフを描画:

           set style fill pattern
           plot sin(x) with boxes, cos(x) with boxes


sin はパターン 0 で、cos はパターン 1 で描画されます。追加される描画は
出力ドライバがサポートするパターンを循環的に使用します。

それぞれのデータ集合で明示的に塗りつぶしスタイルを指定:

          plot 'file1' with boxes fs solid 0.25, \
               'file2' with boxes fs solid 0.50, \
               'file3' with boxes fs solid 0.75, \
               'file4' with boxes fill pattern 1, \
               'file5' with boxes fill empty





File: gnuplot.info, Node: boxplot, Next: boxxyerrorbars, Prev: boxes, Up: 描画スタイル_(plotting_styles)

boxplot
=======


boxplot は、値の統計的な分布を表現する一般的な方法です。四分位境界は、
1/4 の点が第一四分位境界以下の値を持つように、1/2 の点が第二四分位境界
(メジアン) 以下の値を持つように、等と決定されます。第一四分位と第三四分
位の間の領域を囲むように箱を描画し、メジアン値のところには水平線を描き
ます。箱ひげは、箱からユーザ指定限界まで延長されます。それらの限界の外
にある点は、ひとつひとつ描画されます。

例:

         # x 座標は 1.0、y は 5 列目の値のところに boxplot を配置
         plot 'data' using (1.0):5


         # 上と同じだが、範囲外の点は隠し、boxplot の幅を 0.3 にする
         set style boxplot nooutliers
         plot 'data' using (1.0):5:(0.3)


デフォルトでは、using 指定による 2 列目の y のすべての値に対する
boxplot を 1 つだけ生成します。しかし、追加の (4 つ目の) 列を指定すると、
その列の値をある因子変数の離散的なレベル値であると見なし、その離散値の
レベルの値の数だけの boxplot を描画します。それらの boxplot の間隔はデ
フォルトでは 1.0 ですが、これは `set style boxplot separation` で変更で
きます。デフォルトでは、因子変数の値は、各 boxplot の下 (または上) の目
盛のラベルに表示します。

例

         # 'data' の 2 列目は "control" か "treatment" のいずれかの文字列で
         # 以下の例は、その因子毎の 2 つの boxplot を生成する
         plot 'data' using (1.0):5:(0):2


その箱のデフォルトの幅は `set boxwidth <width>` で設定できますが、plot
コマンドの *Note using:: による 3 番目のオプション列でも指定できます。
1 番目と 3 番目の列 (x 座標と幅) は通常データ列ではなく定数として与えま
す。

デフォルトでは、箱ひげは箱の端から、y の値が四分位範囲の 1.5 倍の中に収
まっていて最も離れているような点まで延長されます。デフォルトでは、範囲
外の点 (outlier) は円 (pointtype 7) で描かれます。箱ひげの端の棒の幅は
*Note bars:: を使って制御できます。

これらのデフォルトの性質は *Note boxplot:: コマンドで変更できます。
以下参照: *Note boxplot::, *Note bars::, *Note boxwidth::, `fillstyle`,
*Note candlesticks::。




File: gnuplot.info, Node: boxxyerrorbars, Next: candlesticks, Prev: boxplot, Up: 描画スタイル_(plotting_styles)

boxxyerrorbars
==============


*Note boxxyerrorbars:: スタイルは 2 次元のデータ描画でのみ利用可能です。
これは、*Note xyerrorbars:: スタイルが単に線分の交差で表現するところを
長方形で表現することを除けば、ほぼ同じです。これは、入力データの 4 列、
または 6列を使用します。余分な入力列は、variable 行や塗り潰し色の情報が
提供されたものとして使用されます (以下参照: `rgbcolor variable`)。

          4 列:  x  y  xdelta  ydelta
          6 列:  x  y  xlow  xhigh  ylow  yhigh


箱の幅と高さは *Note xyerrorbars:: スタイル同様 x, y の誤差から決定され
ますつまり、xlow から xhigh までと ylow から yhigh まで、または
x-xdeltaから x+xdelta までと y-ydelta から y+ydelta まで。これらは何列
のデータが与えられているかによって決まります。

入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color情
報 (以下参照: `linecolor`, `rgbcolor variable`) であるとして使われます。

箱の内部は現在の塗りつぶしスタイル (fillstyle) に従って塗られます。詳細
は、以下参照: `set style fill`, *Note boxes::。plot コマンド上で新しい
塗りつぶしスタイルを指定することもできます。



File: gnuplot.info, Node: candlesticks, Next: circles, Prev: boxxyerrorbars, Up: 描画スタイル_(plotting_styles)

candlesticks
============


*Note candlesticks:: スタイルは、金融データの 2 次元のデータ描画、およ
び統計データのひげ付きの棒グラフを生成するのに使えます。記号は、水平方
向には x を中心とし、垂直方向には開始値 (open) と終値(close) を境界とす
る長方形が使われます。そして、その x 座標のところに長方形のてっぺんから
最高値 (high) までと、長方形の底から最安値 (low)までの垂直線が引かれま
すが、この垂直線は最高値と最安値が入れ替わっても変更されません。

基本的に 5 列のデータが必要です:

           金融データ:   date  open  low  high  close
           箱ひげ描画:   x  box_min  whisker_min  whisker_high  box_high


長方形の幅はコマンド *Note boxwidth:: で制御できますが、以前の gnuplot
への後方互換性として、boxwidth パラメータが設定されていない場合は`set
bars <width>` で制御されるようになっています。

これの代わりに、箱ひげ (box-and-whisker) のグループ化に関する明示的な幅
の指定を、追加の 6 番目のデータで指定できます。その幅は、x 座標と同じ単
位で与えなければいけません。

入力列を追加 (6 列目、または 6 列目がデータの幅として使れる場合は 7 列
目) すると、それらは各データ点毎の variable color 情報 (以下参照:
`linecolor`, `rgbcolor variable`) として使われます。

デフォルトでは、鉛直線分のてっぺんと底には垂直に交わる水平線は引かれま
せん。それを引きたい場合、例えば典型的な例は箱ひげ図 (box-and-whisker
plot) での使用ですが、描画コマンドにキーワード `whiskerbars` を追加して
ください。デフォルトでは、水平線は箱 (candlestick) の水平幅一杯に引かれ
ますが、それは全体の幅に対する割合を指定することで変更できます。

金融データの通常の慣習では、(開始値) < (終値) の場合は長方形は空で、(終
値) < (開始値) の場合は塗り潰されます。現在の fillstyle に "empty"をセッ
トしている場合は、実際にこうなります。以下参照: `fillstyle`。fillstyle
に塗り潰し、またはパターンをセットしている場合は、開始値、終値に関係な
く、すべての箱にそれが使われます。以下参照: *Note bars::, *Note
financebars::。また、以下も参照してください。candlestick
(http://www.gnuplot.info/demo/candlesticks.html)とfinance
(http://www.gnuplot.info/demo/finance.html)のデモ。

注意: 中央値を表すための記号などを追加したい場合、以下の例のように、ひ
げ付きの棒グラフに他の描画コマンドを追加する必要があります:

       # データ列:  X '最小値' '1/4 位の値' '中央値' '3/4 位の値' '最大値'
       set bars 4.0
       set style fill empty
       plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
            "         using 1:4:4:4:4 with candlesticks lt -1 notitle


       # ひげの上に水平線を伴う描画で、水平線の幅を全体幅の 50% にする
       plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5


以下参照: *Note boxwidth::, *Note bars::, `set style fill`, *Note
boxplot::。



File: gnuplot.info, Node: circles, Next: ellipses, Prev: candlesticks, Up: 描画スタイル_(plotting_styles)

circles
=======


スタイル *Note circles:: は、各データ点に明示された半径の円を描画します。
3列のデータを与えた場合は、それを x, y, 半径と解釈します。半径は、常に
描画の水平軸 (x または x2) の単位で解釈されます。y 方向の縮尺と描画のア
スペクト比は、いずれも無視されます。2 列のデータしか与えないと、半径は
`set style circle` から取ります。この場合、半径は graph か screenの座標
系で与えることができます。デフォルトでは完全な円を描画しますが、4 列目、
5 列目に開始角、終了角を指定することで扇形を描画することもできます。4
列目、あるいは 6 列目のデータを追加して部分円の色を指定することもできま
す。扇形の開始角、終了角の単位は度で指定する必要があります。


例:

         # 面積が 3 列目の値に比例するような円を描画
         set style fill transparent solid 0.2 noborder
         plot 'data' using 1:2:(sqrt($3)) with circles, \
              'data' using 1:2 with linespoints


         # 円の代わりにパックマンを描画
         plot 'data' using 1:2:(10):(40):(320) with circles


         # インランデータで円グラフを描画
         set xrange [-15:15]
         set style fill transparent solid 0.9 noborder
         plot '-' using 1:2:3:4:5:6 with circles lc var
         0    0    5    0    30    1
         0    0    5   30    70    2
         0    0    5   70   120    3
         0    0    5  120   230    4
         0    0    5  230   360    5
         e


これは、pointstyle 7 で点のサイズを variable とした `points` による描画
と似ていますが、circles は x 軸の範囲で伸縮される点が異なります。以下も
参照: `set object circle`, `fillstyle`。



File: gnuplot.info, Node: ellipses, Next: dots, Prev: circles, Up: 描画スタイル_(plotting_styles)

ellipses
========


スタイル *Note ellipses:: は、各データ点に楕円 (ellipse) を描画します。
このスタイルは、2 次元描画にのみ適用されます。各楕円は、中心、主軸直径、
副軸直径、x 軸と主軸のなす角、で表現されます。

          2 列: x y
          3 列: x y major_diam
          4 列: x y major_diam minor_diam
          5 列: x y major_diam minor_diam angle


2 列のデータのみが与えられた場合は、それらは中心の座標とみなされ、楕円
はデフォルトの大きさで描画されます (以下参照: `set style ellipse`)。楕
円の向きは、主軸と x 軸のなす角で定義されますが、それもデフォルトの
ellipse のスタイルから取られます (以下参照: `set style ellipse`)。3 列
のデータが与えられた場合は、3 列目は主、副両軸の直径 (幅) として使われ
ます。向きはデフォルトで 0 になります。4 列のデータが与えられた場合は、
それらは中心の座標、主軸直径 (幅)、副軸直径として使わわれます。これらは
直径であり、半径でないことに注意してください。5 列のデータが与えられた
場合は、5 列目の値は度単位の向きの角度の指定として使われます。楕円は、
3,4,5 列の値は負の値として指定することで、それらのデフォルトの値を利用
して楕円を書かせることもできます。

上のすべての場合で、variable color データを最後の列 (3,4,5,6 列目) とし
て追加できます。詳細は以下参照: `colorspec`。

デフォルトでは、主軸直径は水平軸 (x または x2) の単位、副軸直径は垂直軸
(y または y2) の単位であるとみなされます。これは、x 軸と y 軸の縮尺が異
なる場合、主軸と副軸の比は回転後には正しくはならない、ということを意味
しています。しかしこの挙動は、キーワード `units` で変更できます。

これに関しては、3 種類の代用品があります: `units xy` が描画指定に含まれ
ている場合、その軸は上に述べたように縮尺されます。`units xx` とすると、
直径は両軸とも x 軸の単位で計算され、`units yy` は両軸とも y 軸の単位で
計算されます。後の 2 つは、描画のサイズを変更しても、楕円は正しいアスペ
クト比を持ちます。

`units` を省略した場合は、デフォルトの設定が使用され、`units xy` となり
ますが、これは、`set style ellipse` で再定義可能です。

例 (楕円を有効な線種を周期的に使用して描画):

         plot 'data' using 1:2:3:4:(0):0 with ellipses


以下も参照: `set object ellipse`, `set style ellipse`, `fillstyle`。



File: gnuplot.info, Node: dots, Next: filledcurves, Prev: ellipses, Up: 描画スタイル_(plotting_styles)

dots
====


*Note dots:: スタイルは各点に小さなドットを描画します。これはたくさんの
点からなる散布図の描画に便利でしょう。2 次元描画では 1 列、または 2 列
の入力データが、3 次元描画では 3 列のデータが必要です。

出力形式によっては (post, pdf など)、ドットの大きさは linewidth を変更
することで制御できることもあります。

          1 列:  y         # x は行番号
          2 列:  x  y
          3 列:  x  y  z   # 3D のみ (splot)





File: gnuplot.info, Node: filledcurves, Next: financebars, Prev: dots, Up: 描画スタイル_(plotting_styles)

filledcurves
============


スタイル *Note filledcurves:: は 2 次元描画でのみ利用可能です。これは
3 種類の異なる指定が可能です。最初の 2 種類は関数描画、あるいは 2 列の
入力データ用のもので、後で紹介するようにオプションで更なる指定ができま
す。

書式:

         plot ... with filledcurves [option]


ここで、オプションは以下のうちのいずれかです:

         [closed | {above | below}
         {x1 | x2 | y1 | y2 | r}[=<a>] | xy=<x>,<y>]


最初のものは `closed` で、これは曲線それ自身を閉多角形と見なします。入
力データが 2 列の場合にはこれがデフォルトです。

2 種類目は指定された軸、あるいは水平線、垂直線、与えられた点などと、曲
線との間に作られる領域を塗りつぶします。

         filledcurves closed   ... 丁度閉曲線で囲まれる領域
         filledcurves x1       ... x1 軸
         filledcurves x2       ... x2 軸 (y1, y2 軸も同様)
         filledcurves y1=0     ... (y1 軸での) 直線 y=0 i.e. x1 軸と平行
         filledcurves y2=42    ... (y2 軸での) 直線 y=42 i.e. x2 軸と平行
         filledcurves xy=10,20 ... x1,y1 軸での点 10,20 (扇型のような形状)
         filledcurves above r=1.5  極座標での動径軸の 1.5 の外側の領域


3 種類目は 3 列の入力データを必要とし、それらは x 座標と、それに対する
2 つの y 座標からなり、それらは同じ x 座標の集合に対する 2 つの曲線のy
座標に対応します。そしてその 2 つの曲線の間の領域が塗りつぶされます。入
力データが 3 列以上の場合にはこれがデフォルトです。

          3 列:  x  y1  y2


入力された 2 つの曲線の間の領域の塗りつぶしの例:曲線間の塗りつぶしデモ。
(http://www.gnuplot.info/demo/fillbetween.html)

         plot 'data' using 1:2:3 with filledcurves


`above` と `below` オプションは
         ... filledcurves above {x1|x2|y1|y2|r}=<val>

および
         ... using 1:2:3 with filledcurves below

の形のコマンドに適用可能です。どちらの場合でも、これらのオプションは塗
りつぶし領域を、境界線、または境界曲線の片側に制限します。

注意: この描画モードは全ての出力形式でサポートされるとは限りません。

データファイルから描かれた曲線の塗りつぶしを拡大すると、何もなくなった
り正しくない領域になることがありますが、それは gnuplot が、領域ではなく
点や線をクリッピングしているからです。

<a>, <x>, <y> が描画領域の外にある場合、それらはグラフの境界へ移動され
ます。よって、オプション xy=<x>,<y> を指定した場合の実際の塗りつぶし領
域は、xrange や yrange に依存します。



File: gnuplot.info, Node: financebars, Next: fsteps, Prev: filledcurves, Up: 描画スタイル_(plotting_styles)

financebars
===========


*Note financebars:: スタイルは金融データの 2 次元のデータ描画でのみ利用
可能です。これは、x 座標 1 つ (通常日付) と、4 つの y 座標 (金額) を必
要とします。

          5 列:   date  open  low  high  close


入力列を追加 (6 列目) すると、それらは各行毎の variable color 情報 (以
下参照: `linecolor`, `rgbcolor variable`) として使われます。

記号は、水平方向にはその x 座標に置かれ、垂直方向には最高値 (high) と最
安値 (low) を端とする線分が使われます。そして、その線分に水平左側の刻み
が開始値 (open) の所に、水平右側の刻みが終り値 (close) の所につきます。
その刻みの長さは *Note bars:: で変更できます。記号は最高値と最安値が入
れ替わっても変わりません。以下参照: *Note bars::, *Note candlesticks::。
以下も参照してください。金融データデモ。
(http://www.gnuplot.info/demo/finance.html)



File: gnuplot.info, Node: fsteps, Next: fillsteps, Prev: financebars, Up: 描画スタイル_(plotting_styles)

fsteps
======


*Note fsteps:: スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線
分で隣り合う点をつなぎます: 1 本目は (x1,y1) から (x1,y2) まで、2 本目
は(x1,y2) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
るものと同じです。*Note fsteps:: と *Note steps:: の違いは、*Note
fsteps:: は、折れ線を先に y 方向に書いてから次に x 方向に書くのに対し、
*Note steps:: は先に x 方向に書いてから次に y 方向に書きます。

以下も参照steps デモ。 (http://www.gnuplot.info/demo/steps.html)



File: gnuplot.info, Node: fillsteps, Next: histeps, Prev: fsteps, Up: 描画スタイル_(plotting_styles)

fillsteps
=========


*Note fillsteps:: スタイルは、*Note steps:: とほぼ同じですが、曲線と
y=0 との間の領域を現在の fillstyle で塗り潰します。以下参照: *Note
steps::。



File: gnuplot.info, Node: histeps, Next: histograms, Prev: fillsteps, Up: 描画スタイル_(plotting_styles)

histeps
=======


*Note histeps:: スタイルは 2 次元描画でのみ利用可能です。これはヒストグ
ラムの描画での利用を意図しています。y の値は、x の値を中心に置くと考え、
x1 での点は ((x0+x1)/2,y1) から ((x1+x2)/2,y1) までの水平線として表現さ
れます。端の点では、その線はその x 座標が中心になるように延長されます。
隣り合う点同士の水平線の端は、その両者の平均値のところでの鉛直線、すな
わち ((x1+x2)/2,y1) から ((x1+x2)/2,y2) の線分で結ばれます。入力列の条
件は、`lines` や `points` に対するものと同じです。

*Note autoscale:: が有効である場合、x の範囲は、その延長された水平線の
範囲ではなく、データ点の範囲が選択されます。よって、端の点に関してはそ
の水平線は半分しか描かれないことになります。以下も参照steps デモ。
(http://www.gnuplot.info/demo/steps.html)

*Note histeps:: は単なる描画スタイルにすぎず、`gnuplot` には、ヒストグ
ラムの箱を生成する能力や、データ集合から母集団を決定する能力などはあり
ません。



File: gnuplot.info, Node: histograms, Next: image, Prev: histeps, Up: 描画スタイル_(plotting_styles)

histograms
==========


スタイル *Note histograms:: は 2 次元描画でのみ有効です。これは、データ
の各列の並びから平行な棒グラフを作ります。*Note plot:: コマンドの各要素
は、それに関する目盛りの値や説明のタイトルが付属するかも知れませんが、
単一の入力データを指定する必要があります (例えば入力ファイルの 1 つの
列)。現在は、4 種類のヒストグラム形式のスタイルがサポートされています。

           set style histogram clustered {gap <gapsize>}
           set style histogram errorbars {gap <gapsize>} {<linewidth>}
           set style histogram rowstacked
           set style histogram columnstacked


デフォルトのスタイルは `set style histogram clustered gap 2` に対応して
います。このスタイルでは、並列に指定されたデータの値の集合は、選択され
たデータ列のそのそれぞれの序列 (行番号) に対応する x 座標の場所に、各々
箱のグループとして固められて置かれます。よって、<n> 個のデータ列を並列
に指定した場合、最初の固まりは x=1 を中心とする <n> 個の箱の固まりから
なり、その各々の高さは、その <n> データ列各々の最初 (1 行目) の値が取ら
れます。その後に少し空白 (gap) が空けられ、次に各データ列の次 (2行目)
の値に対応する箱の固まりが x=2 を中心として置かれます。以下同様です。デ
フォルトの空白 (gap) 幅の 2 は、箱の固まり同士の間の空白が、箱2 つの幅
に等しいことを意味します。同じ列に対する箱は全て同じ色または同じパター
ンで与えられます (以下参照: `set style fill`)。

箱の固まりそれぞれは、データファイルの 1 つの行から得られます。そのよう
な入力ファイルの各行の最初の項目が見出し (ラベル) でることは良くあるこ
とです。その列にある見出し (ラベル) は、*Note using:: に `xticlabels`
オプションをつけることで、それに対応する箱の固まりの真下の x 軸に沿った
ところに置くことができます。

*Note errorbars:: スタイル は、各エントリに対して追加の入力列を必要とす
る以外は `clustered` スタイルにとても良く似ています。最初の列は、
`clustered` スタイルの場合と全く同様に箱の高さ (y の値) として保持され
ます。
          2 列:       y yerr          # 線は y-yerr から y+err へ伸びる
          3 列:       y ymin yman     # 線は ymin から ymax へ伸びる

誤差線の見た目は、現在の *Note bars:: の値と <linewidth> オプション指定
で制御できます。

積み上げ型のヒストグラムも 2 つの形式がサポートされています。それらはコ
マンド `set style histogram {rowstacked|columnstacked}` で選択できます。
これらのスタイルにおいて、選択された列のデータの値は積み上げられた箱と
して集められます。正の値は、y=0 から上の方へ積み上げられ、負の値は下へ
向かって積み上げられます。正の値と負の値が混じってい場合は、上向きと下
向きの両方の積み上げが生成されます。デフォルトの積み上げモードは
`rowstacked` です。

スタイル `rowstacked` は、まず最初に選択された列の各行の値を x 軸のそれ
ぞれの位置に配置します: 1 行目の値は x=1 の箱、2 行目のは x=2、以下同様
となります。2 番目以降に選択された列に対応する箱は、それらの上に積み重
ねられて行きます。そして結果として、x=1 にできる箱の積み重ねは、各列の
最初の値 (1 行目の値) からなり、x=2 の箱の積み重ねは各列の 2 行目の値、
などのようになります。同じ列に対する箱は全て同じ色または同じパターンで
与えられます (以下参照: `set style fill`)。

スタイル `columnstacked` も同様ですが、こちらは各箱の積み上げは (各行の
データからではなく) 各列のデータからなります。最初に指定された列の各行
のデータが x=1 の箱の積み上げを生成し、2 番目に指定した列の各行のデータ
が x=2 の箱の積み上げ、などのようになります。このスタイルでは、各箱の色
は、各データ項目の (列番号ではなく) 行番号から決定されます。

箱の幅はコマンド *Note boxwidth:: で変更できます。箱の塗りつぶしスタイ
ルはコマンド `set style fill` で設定できます。

histograms は x 軸は常に x1 軸を使いますが、y 軸に関しては y1 軸か y2軸
かを選択できます。plot 命令が、histograms と他のスタイルの描画の両方を
含む場合、histogram でない方は、x1 軸を使うか x2 軸を使うかを選択できま
す。

例:入力ファイルは、2, 4, 6, ... の列にデータ値を持ち、3, 5, 7, ...  の
列に誤差評価を持つとします。以下の例は、2 列目、4 列目の値を箱の固まり
型(clustered; デフォルトスタイル) のヒストグラムとして描画します。ここ
では、plot コマンドで繰り返し (iteration) を使用していますので、任意の
個数のデータ列を一つのコマンドで処理できます。以下参照: `iteration`。

           set boxwidth 0.9 relative
           set style data histograms
           set style histogram cluster
           set style fill solid 1.0 border lt -1
           plot for [COL=2:4:2] 'file.dat' using COL


これは、x 軸上の各整数値を中心とするそれぞれ 2 つの箱 (鉛直な棒) 毎の固
まりによる描画を生成します。入力ファイルの最初の列にラベルが含まれてい
るならそれを、以下の少し変更したコマンドで x 軸に沿って配置できます。

           plot for [COL=2:4:2] 'file.dat' using COL:xticlabels(1)


ファイルが、各データの測定値と範囲の情報の両方を含んでいる場合、描画に
誤差線を追加することができます。以下のコマンドは誤差線を (y-<error>)か
ら (y+<error>) に引き、その頭に箱と同じ幅の水平線をつけます。誤差線と誤
差線の端の線は、黒で線幅 2 で描画されます。

           set bars fullwidth
           set style fill solid 1 border lt -1
           set style histogram errorbars gap 2 lw 2
           plot for [COL=2:4:2] 'file.dat' using COL:COL+1


同じデータを行毎の積み上げ型 (rowstacked) のヒストグラムで描画する場合、
これまでとは違い、以下の例では繰り返しを使うのでなく、明示的に別々の列
を指定します。

           set style histogram rowstacked
           plot 'file.dat' using 2, " using 4:xtic(1)


これは、一つ一つの鉛直な棒が、データの一つの列に対応する描画を生成しま
す。各棒は、2 つの部分の積み上げの形であり、それぞれの部分の高さが、デー
タファイルの 2 列目と 4 列目の値に対応します。


最後に以下のコマンド

           set style histogram columnstacked
           plot 'file.dat' using 2, " using 4


は、一つ一つがそれぞれデータ列に対応する、2 つの鉛直な積み重ねの棒を生
成します。x=1 にある棒は、データファイルの 2 列目の各行の値に対応する箱
からなります。x=2 にある棒は、データファイルの 4 列目の各行の値に対応す
る箱からなります。これは、gnuplot の通常の入力の縦、横の解釈を入れ換え
ることになりますので、key タイトルや x 軸の目盛りの見出しの指定も変更す
る必要があります。以下のコメント部分を参照してください。

           set style histogram columnstacked
           plot " u 5:key(1)            # 1 列目を key タイトルに使用
           plot " u 5 title columnhead  #


この 2 つの例は、全く同じデータ値を与えているのですが、異なる書式である
ことに注意してください。

* Menu:

* newhistogram::
* 複数の列に渡る自動的な繰り返し_(automated)::



File: gnuplot.info, Node: newhistogram, Next: 複数の列に渡る自動的な繰り返し_(automated), Prev: histograms, Up: histograms

newhistogram
------------


書式:

          newhistogram {"<title>"} {lt <linetype>} {fs <fillstyle>} {at <x-coord>}


一回の描画に 2 つ以上のヒストグラムの組を作ることもできます。この場合コ
マンド *Note newhistogram:: を使うことで、それらを強制的に分離し、また
それぞれのラベルを分離することができます。例:

           set style histogram  cluster
           plot newhistogram "Set A", 'a' using 1, " using 2, " using 3, \
                newhistogram "Set B", 'b' using 1, " using 2, " using 3


ラベル "Set A" と "Set B" は、それぞれのヒストグラムの組の下、x 軸の全
てのラベルの下の位置に現われます。

コマンド newhistogram は、ヒストグラムの色付けを強制的に指定した色
(linetype) で始めるのにも使えます。デフォルトでは、色の番号はヒストグラ
ムの境界をまたいでさえも連続的に増加し続けます。次の例は、複数のヒスト
グラムに同じ色付けを施します。
           plot newhistogram "Set A" lt 4, 'a' using 1, " using 2, " using 3, \
                newhistogram "Set B" lt 4, 'b' using 1, " using 2, " using 3


同様に、次のヒストグラムを指定した fillstyle で始めさせることが可能です。
その fillstyle を `pattern` にセットした場合、塗り潰しに使用されるパター
ン番号は自動的に増加されていきます。

オプション `at <x-coord>` は、その後のヒストグラムの x 座標の位置を
<x-coord> に設定します。例:

            set style histogram cluster
            set style data histogram
            set style fill solid 1.0 border -1
            set xtic 1 offset character 0,0.3
            plot newhistogram "Set A", \
                 'file.dat' u 1 t 1, " u 2 t 2, \
                 newhistogram "Set B" at 8, \
                 'file.dat' u 2 t 2, " u 2 t 2


この場合、2 つ目のヒストグラムの位置は x=8 から始まります。



File: gnuplot.info, Node: 複数の列に渡る自動的な繰り返し_(automated), Prev: newhistogram, Up: histograms

複数の列に渡る自動的な繰り返し (automated)
------------------------------------------


一つのデータファイルのたくさんの列から、一つのヒストグラムを生成したい
場合、plot の繰り返し (iteration) 機能を使うと便利でしょう。以下参照:
`iteration`。例えば、3 列目から 8 列目までのデータを積み上げた形のヒス
トグラムを生成する例:

           set style histogram columnstacked
           plot for [i=3:8] "datafile" using i title columnhead




File: gnuplot.info, Node: image, Next: impulses, Prev: histograms, Up: 描画スタイル_(plotting_styles)

image
=====




描画スタイル `image`, *Note rgbimage::, *Note rgbalpha:: は、いずれも一
様に標本点を取った格子状データ値を、2 次元、または 3 次元中のある平面上
に射影します。入力データは、既にあるビッマップ画像ファイル (PNG のよう
な標準的なフォーマットから変換したものでよい) か、単純な数値配列です。


この図は、スカラー値の配列から温度分布を生成した例です。現在のパレット
を、各スカラー値から対応するピクセルの色への割り当てに使用します。
           plot '-' matrix with image
           5 4 3 1 0
           2 2 0 0 1
           0 0 0 1 0
           0 1 2 4 3
           e
           e


入力 2 次元画像の各ピクセル (データ点) は、描画グラフ中では長方形、また
は平行六面体となります。画像の各データ点の座標は、平行六面体の中心を決
定します。すなわち、M x N 個のデータ集合は M x N ピクセルの画像を生成し
ます。これは、M x N 個のデータ集合が (M-1) x (N-1) 要素を作成するpm3d
の構造とは異なります。バイナリ画像データの格子の走査方向は、追加キーワー
ドでさらに制御可能です。以下参照: `binary keywords flipx`, `keywords
center`, `keywords rotate`。

各ピクセルの x と y の大きさを示すことで、画像データを 2 次元描画座標系
内の特定の長方形に収まるように伸縮することができます。以下参照:
`binary keywords dx`, `dy`。右の画像を生成するのには、同じ入力画像を、
それぞれ dx, dy, origin を指定して複数回配置しました。入力 PNG 画像であ
るビルの絵は 50x128 ピクセルです。高いビルは、`dx=0.5 dy=1.5` で割り当
てて描画し、低いビルは、`dx=0.5 dy=0.35` としています (訳注: ここで述べ
ている画像とは、pdflatex を使用したマニュアルだけに現れますので、日本語
のマニュアルにはこの図は含まれていないでしょう。)

スタイル `image` は、グレイスケール (灰色階調)、またはカラーパレット値
を含んでいるピクセルの入力を処理します。よって 2 次元描画 (*Note
plot:: コマンド) では 3 列のデータ (x,y,value) を、3 次元描画 (`splot`
コマンド)では 4 列のデータ (x,y,z,value) が必要になります。

スタイル *Note rgbimage:: は、赤、緑、青の 3 つの色成分 (RGB) で記述さ
れたピクセルの入力を処理します。よって *Note plot:: では 5 次元データ
(x,y,r,g,b)が、`splot` では 6 次元データ (x,y,z,r,g,b) が必要になります。
赤、緑、青の各成分は [0:255] の範囲内にあると仮定されます。

スタイル *Note rgbalpha:: は、赤、緑、青の RGB 成分に加えて、アルファチャ
ネル (透過パラメータ) の情報も含んだピクセルの入力を処理します。よって、
*Note plot:: では 6 次元データ (x,y,r,g,b,a) が、`splot` では 7 次元デー
タ(x,y,z,r,g,b,a) が必要になります。赤、緑、青、およびアルファの各成分
は[0:255] の範囲内にあると仮定されます。

* Menu:

* 透明化_(transparency)::
* image_failsafe::



File: gnuplot.info, Node: 透明化_(transparency), Next: image_failsafe, Prev: image, Up: image

透明化 (transparency)
---------------------


描画スタイル *Note rgbalpha:: は、入力データの各ピクセルが [0:255] の範
囲内のアルファ値を持っている必要があります。alpha = 0 のピクセルは完全
な透明で、その下 (奥) の描画要素を全く変えません。alpha = 255 のピクセ
ルは完全な不透明です。すべての出力形式は、これら 2 つの両極端な値をサポー
トします。0 < alpha < 255 のピクセルは半透明で、これは 2,3 の出力形式し
か完全には対応しておらず、他の出力形式ではこれを 0 か 255 として扱うこ
とによる近似しか行いません。



File: gnuplot.info, Node: image_failsafe, Prev: 透明化_(transparency), Up: image

image failsafe
--------------


出力形式のドライバによっては、2 次元の長方形領域内での画像データのレン
ダリングを最適化するルーチンを提供している場合があります。しかし、その
ルーチンは不完全であることが知られています。この最適化ルーチンは、キー
ワード `failsafe` を使うことで無効化できます。例:

           plot 'data' with image failsafe




File: gnuplot.info, Node: impulses, Next: labels, Prev: image, Up: 描画スタイル_(plotting_styles)

impulses
========


*Note impulses:: スタイルは、2 次元描画では y=0 から各点の y の値への、
3 次元描画では z=0 から各点の z の値への、垂直な線分を表示します。y や
zの値は負の値でもよいことに注意してください。データの追加列を各垂直線分
の色の制御に利用できます。このスタイルを 3 次元描画で使用する場合、太い
線 (linewidth > 1) を利用するとより効果的でしょう。それは 3 次元の棒グ
ラフに似たものになります。

          1 列:  y
          2 列:  x  y     # [x,0] から [x,y] への線 (2D)
          3 列:  x  y  z  # [x,y,0] から [x,y,z] への線 (3D)





File: gnuplot.info, Node: labels, Next: lines, Prev: impulses, Up: 描画スタイル_(plotting_styles)

labels
======


スタイル *Note labels:: は、データファイルから座標と文字列を読み込み、
その文字列をその 2 次元、または 3 次元座標に置きます。これは基本的に 3
列、または 4 列の入力を必要とします。余分な入力列は、フォントサイズか文
字色の変数値のような情報が提供されたものとして使用されます (以下参照:
`rgbcolor variable`)。

          3 列:  x  y  string    # 2 次元版
          4 列:  x  y  z  string # 3 次元版


フォント、色、回転角やその他の描画テキストの属性は追加オプションとして
指定可能です (以下参照: `set label`)。次の例は、入力ファイルの 1 列目か
ら取った市の名前から作られる文字列を、4, 5 列目から取った地図座標に描画
します。フォントサイズは、3 列目の値から計算していて、この場合はそれは
人口を意味しています。

       CityName(String,Size) = sprintf("{/=%d %s}", Scale(Size), String)
       plot 'cities.dat' using 5:4:(CityName(stringcolumn(1),$3)) with labels


フォントを、個々の市に対して異なるサイズに合わせなくていいならば、コマ
ンドはもっと簡単です:

       plot 'cities.dat' using 5:4:1 with labels font "Times,8"


スタイル *Note labels:: は 3 次元描画でも使用できます。この場合 X,Y,Z
と文字列、の 4 つの入力列指定が必要です。

       splot 'datafile' using 1:2:3:4 with labels


以下も参照: `datastrings`, `set style data`。



File: gnuplot.info, Node: lines, Next: linespoints, Prev: labels, Up: 描画スタイル_(plotting_styles)

lines
=====


`lines` スタイルは隣接する点を真直な線分で結びます。これは、2 次元描画
でも、3 次元描画でも使用でき、基本的には、1 列か 2列か 3 列かの入力デー
タを必要とします。余分な入力列は、線の色の変更などの情報が提供されたも
のとして使用されます (以下参照: `rgbcolor variable`)。

2 次元の場合
          1 列:  y       # 行番号による暗黙の x
          2 列:  x  y

3 次元の場合
          1 列:  z       # x は暗黙の行番号、y は index から
          3 列:  x  y  z


以下も参照: `linetype`, `linewidth`, `linestyle`。



File: gnuplot.info, Node: linespoints, Next: points, Prev: lines, Up: 描画スタイル_(plotting_styles)

linespoints
===========




*Note linespoints:: スタイルは、隣接する点を真っ直ぐな線分で結び、その
後で最初に戻って各点に小さな記号を描きます。コマンド *Note pointsize::
を使って、その記号のデフォルトの大きさを変更できます。基本的に 2 次元描
画では 1 列、または 2 列の入力データが必要で、3 次元描画では 1 列、また
は 3 列のデータが必要です。以下参照: `style lines`。余分な入力列は、点
のサイズや線の色の変更などの情報が提供されたものとして使用されます。

線種 (linetype) の属性である `pointinterval` (省略形 `pi`) で、グラフの
すべての点を与えた記号にするかどうかを制御できます。例えば、`with lp
pi 3` は、すべてのデータ点間に線分を引きますが、点の記号は 3つおきにし
か書きません。`pointinterval` を負の値にした場合は、記号の下の線分の部
分を消します。消す部分のサイズは *Note pointintervalbox:: で制御できま
す。

*Note linespoints:: は `lp` と略すことが出来ます。



File: gnuplot.info, Node: points, Next: polar, Prev: linespoints, Up: 描画スタイル_(plotting_styles)

points
======


`points` スタイルは各点に小さな記号を表示します。その記号のデフォルトの
大きさを変更するにはコマンド *Note pointsize:: が使えます。基本的に 2
次元描画では 1 列、または 2 列の入力データが必要で、3 次元描画では 1 列、
または 3 列のデータが必要です。以下参照: `style lines`。余分な入力列は、
点のサイズや点色の変更などの情報が提供されたものとして使用されます。




File: gnuplot.info, Node: polar, Next: steps, Prev: points, Up: 描画スタイル_(plotting_styles)

polar
=====

極座標描画 (polar) は、実際には描画スタイルの一つではありませんが、完全
を期すためにこの一覧に上げておきます。オプション *Note polar:: は、入力
する 2 次元座標を <x>,<y> の代わりに <角>,<半径> と解釈することを
gnuplot に指示します。すべてではないが、多くの 2 次元描画スタイルが極座
標モードでも機能します。図は、描画スタイル `lines` と *Note
filledcurves::の組み合わせを示しています。(訳注: ここで述べている図とは、
pdflatex を使用したマニュアルだけに現れますので、日本語のマニュアルには
この図は含まれていないでしょう。) 以下参照: *Note polar::, *Note
rrange::, `set size square`。




File: gnuplot.info, Node: steps, Next: rgbalpha, Prev: polar, Up: 描画スタイル_(plotting_styles)

steps
=====


*Note steps:: スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線
分で隣り合う点をつなぎます: 1 本目は (x1,y1) から (x2,y1) まで、2 本目
は(x2,y1) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
るものと同じです。*Note fsteps:: と *Note steps:: の違いは、*Note
fsteps:: は、折れ線を先に y 方向に書いてから次に x 方向に書くのに対し、
*Note steps:: は先に x 方向に書いてから次に y 方向に書きます。曲線とベー
スラインである y=0 との間の領域を塗り潰すには、*Note fillsteps:: を使用
してください。以下も参照steps デモ。
(http://www.gnuplot.info/demo/steps.html)




File: gnuplot.info, Node: rgbalpha, Next: rgbimage, Prev: steps, Up: 描画スタイル_(plotting_styles)

rgbalpha
========

以下参照: `image`。



File: gnuplot.info, Node: rgbimage, Next: vectors, Prev: rgbalpha, Up: 描画スタイル_(plotting_styles)

rgbimage
========

以下参照: `image`。



File: gnuplot.info, Node: vectors, Next: xerrorbars, Prev: rgbimage, Up: 描画スタイル_(plotting_styles)

vectors
=======


2 次元の *Note vectors:: スタイルは (x,y) から (x+xdelta,y+ydelta) まで
のベクトルを書きます。3 次元の *Note vectors:: スタイルも同様ですが、デー
タは基本的に 6 列必要です。各ベクトルの先端には小さな矢先も書かれます。

          4 列:  x  y  xdelta  ydelta
          6 列:  x  y  z  xdelta  ydelta  zdelta


両方の場合で、入力列を追加 (2D では 5 列目、3D では 7 列目) すると、そ
れらは各データ点毎の variable color 情報 (以下参照: `linecolor`,
`rgbcolor variable`) として使われます。

vectors スタイルを使っての splot は `set mapping cartesian` のみでサポー
トされています。

キーワード "with vectors" は、その後ろに、インラインの arrow スタイル指
定や、あらかじめ定義されている arrow スタイルの参照、あるいは列から各ベ
クトルに対する必要な arrow スタイルのインデックスを読むような指定を伴う
ことができます。注意: "arrowstyle variable" を使用する場合、対応するベ
クトルが描画される際にはそれが arrow の属性値すべてを埋めるのでその
plot コマンド内に他の線属性や arrow スタイル指定をこのキーワードと混在
させることはできません。

          plot ... with vectors filled heads
          plot ... with vectors arrowstyle 3
          plot ... using 1:2:3:4:5 with vectors arrowstyle variable


詳細は、以下参照: `arrowstyle`。

例:
           plot 'file.dat' using 1:2:3:4 with vectors head filled lt 2
           splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2


`set clip one` と `set clip two` は 2 次元のベクトルの描画に影響を与え
ます。詳細は、以下参照: *Note clip::, `arrowstyle`。



File: gnuplot.info, Node: xerrorbars, Next: xyerrorbars, Prev: vectors, Up: 描画スタイル_(plotting_styles)

xerrorbars
==========


*Note xerrorbars:: スタイルは 2 次元のデータ描画のみで利用可能です。
*Note xerrorbars:: は、水平の誤差指示線 (error bar) が表示される以外は
*`points` と同じです。各点 (x,y) において (xlow,y) から (xhigh,y) まで、
*または (x-xdelta,y) から (x+xdelta,y) までの線分が引かれますが、これら
*はいくつのデータ列が与えられるかによって変わります。誤差指示線の端には
*刻みの印が付けられます (*Note bars:: が使われていなければ。詳細に関し
*ては、以下参照: *Note bars::)。このスタイルは基本的に、3 列か 4 列のデー
*タが必要です:

          3 列:  x  y  xdelta
          4 列:  x  y  xlow  xhigh


入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
使われます。




File: gnuplot.info, Node: xyerrorbars, Next: yerrorbars, Prev: xerrorbars, Up: 描画スタイル_(plotting_styles)

xyerrorbars
===========


*Note xyerrorbars:: スタイルは 2 次元のデータ描画のみで利用可能です。
*Note xyerrorbars:: は、水平、垂直の誤差指示線 (error bar) も表示される
*以外は `points` と同じです。各点 (x,y) において (x,y-ydelta) から
*(x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y) まで、または
*(x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y) までの線分が引
*かれますが、これらはいくつのデータ列が与えられるかによって変わります。
*誤差指示線の端には刻みの印が付けられます (*Note bars:: が使われていな
*ければ。詳細に関しては、以下参照: *Note bars::)。これは 4 列か、6 列の
*データが必要です。

          4 列:  x  y  xdelta  ydelta
          6 列:  x  y  xlow  xhigh  ylow  yhigh


データが、サポートされていない混合型の形式で与えられた場合、*Note
plot:: コマンドの *Note using:: フィルタを使って適切な形に直さないとい
けません。例えばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、
以下のようにします:

           plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars


入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color情
報として使われます。




File: gnuplot.info, Node: yerrorbars, Next: xerrorlines, Prev: xyerrorbars, Up: 描画スタイル_(plotting_styles)

yerrorbars
==========


*Note yerrorbars:: (または *Note errorbars::) スタイルは 2 次元のデータ
描画のみで利用可能です。*Note yerrorbars:: は、垂直の誤差指示線 (error
bar) が表示される以外は `points` に似ています。各点 (x,y) において
(x,y-ydelta) から(x,y+ydelta) まで、または (x,ylow) から (x,yhigh) まで
の線分が引かれますが、これらはいくつのデータ列が与えられるかによって変
わります。誤差指示線の端には刻みの印が付けられます (*Note bars:: が使わ
れていなければ。詳細に関しては、以下参照: *Note bars::)。これは、3 列か
4 列のデータが必要です。

          3 列:  x  y  ydelta
          4 列:  x  y  ylow  yhigh


入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
使われます。

以下も参照errorbar デモ。 (http://www.gnuplot.info/demo/mgr.html)



File: gnuplot.info, Node: xerrorlines, Next: xyerrorlines, Prev: yerrorbars, Up: 描画スタイル_(plotting_styles)

xerrorlines
===========


*Note xerrorlines:: スタイルは 2 次元のデータ描画のみで利用可能です。
*Note xerrorlines:: は *Note linespoints:: に似ていますが、水平の誤差線
*が描かれることが違います。各点 (x,y) で、データ列の個数に応じて
*(xlow,y) から(xhigh,y) まで、または (x-xdelta,y) から (x+xdelta,y) ま
*での線分が描かれ、そして刻の印が誤差線の端に置かれます (*Note bars::
*が使われていない場合。詳細は、以下参照: *Note bars::)。基本的には、3
*列か 4 列のデータが必要です:

          3 列:  x  y  xdelta
          4 列:  x  y  xlow  xhigh


入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
使われます。




File: gnuplot.info, Node: xyerrorlines, Next: yerrorlines, Prev: xerrorlines, Up: 描画スタイル_(plotting_styles)

xyerrorlines
============


*Note xyerrorlines:: スタイルは 2 次元のデータ描画のみで利用可能です。
*Note xyerrorlines:: は *Note linespoints:: に似ていますが、水平と垂直
*の誤差線も描かれることが違います。各点 (x,y) で、データ列の個数に応じ
*て、(x,y-ydelta) から (x,y+ydelta) までと (x-xdelta,y) から
*(x+xdelta,y)まで、あるいは (x,ylow) から (x,yhigh) までと (xlow,y) か
*ら (xhigh,y)までの線分が描かれ、そして刻の印が誤差線の端に置かれます
*(*Note bars::が使われていない場合。詳細は、以下参照: *Note bars::)。こ
*れは、4 列か 6列の入力データが必要です。

          4 列:  x  y  xdelta  ydelta
          6 列:  x  y  xlow  xhigh  ylow  yhigh


データが、サポートされていない混合型の形式で与えられた場合、*Note
plot:: コマンドの *Note using:: フィルタを使って適切な形に直さないとい
けません。例えばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、
以下のようにします:

           plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines


入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color情
報として使われます。




File: gnuplot.info, Node: yerrorlines, Next: 3_次元_(曲面)_描画_(3D_(surface)_plots), Prev: xyerrorlines, Up: 描画スタイル_(plotting_styles)

yerrorlines
===========


*Note yerrorlines:: (または *Note errorlines::) スタイルは 2 次元のデー
タ描画のみで利用可能です。*Note yerrorlines:: は *Note linespoints:: に
似ていますが、垂直の誤差線が描かれることが違います。各点 (x,y) で、デー
タ列の個数に応じて(x,y-ydelta) から (x,y+ydelta) まで、または (x,ylow)
から (x,yhigh)までの線分が描かれ、そして刻の印が誤差線の端に置かれます
(詳細は、以下参照: *Note bars::)。これは、3 列か 4 列の入力が必要です。

          3 列:  x  y  ydelta
          4 列:  x  y  ylow  yhigh


入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
使われます。

以下も参照。エラーバーのデモ (http://www.gnuplot.info/demo/mgr.html)



File: gnuplot.info, Node: 3_次元_(曲面)_描画_(3D_(surface)_plots), Prev: yerrorlines, Up: 描画スタイル_(plotting_styles)

3 次元 (曲面) 描画 (3D (surface) plots)
=======================================




曲面描画は、コマンド *Note plot:: ではなくコマンド `splot` を使って生成
します。スタイル `with lines` を使えば、曲面を格子線で生成できます。曲
面の塗り潰しは、スタイル `with pm3d` で行うことができます。曲面は通常、
それが 3 次元の曲面であるとはっきりわかるような視方向から表示されます。
その場合、X, Y, Z 軸はすべて描画内に表示されます。3 次元的な錯覚は、隠
線処理や、曲面要素の深さ整列により、より増幅されます。以下参照: *Note
hidden3d::, `pm3d depthorder`。コマンド `splot` は、定数の Z 値に対する
等高線を計算し描画することもできます。これらの等高線は、曲面それ自体の
上に書くこともできますし、XY平面へ射影することもできます。以下参照:
`set contour`。





* Menu:

* 2_次元射影_(set_view_map)::



File: gnuplot.info, Node: 2_次元射影_(set_view_map), Prev: 3_次元_(曲面)_描画_(3D_(surface)_plots), Up: 3_次元_(曲面)_描画_(3D_(surface)_plots)

2 次元射影 (set view map)
-------------------------


コマンド `splot` の特別な場合として、描画の Z 方向の射影による、Z 座標
の 2 次元曲面への地図作成 (map) があります。以下参照: `set view map`。
この描画モードは、等高線の描画や温度分布を生成するのに利用できます。





File: gnuplot.info, Node: コマンド_(Commands), Next: 出力形式_(Terminal), Prev: 描画スタイル_(plotting_styles), Up: Top

コマンド (Commands)
*******************


このセクションでは `gnuplot` が受け付けるコマンドをアルファベット順に並
べています。このドキュメントを紙に印刷したものは全てのコマンドを含んで
いますが、対話型で参照できるドキュメントの方は完全ではない可能性があり
ます。実際、この見出しの下に何のコマンドも表示されないシステムがありま
す。

ほとんどの場合、コマンド名とそのオプションは、紛らわしくない範囲で省略
することが可能です。すなわち、"`plot f(x) with lines`" の代わりに"`p
f(x) w li`" とすることができます。

書式の記述において、中カッコ ({}) は追加指定できる引数を意味し、縦棒
(|) は互いに排他的な引数を区切るものとします。

* Menu:

* cd::
* call::
* clear::
* Do::
* evaluate::
* exit::
* fit::
* help::
* history::
* if::
* 繰り返し_(iteration)::
* load::
* lower::
* pause::
* plot::
* print::
* pwd::
* quit::
* raise::
* refresh::
* replot::
* reread::
* reset::
* save::
* set-show::
* shell::
* splot::
* stats_(簡単な統計情報)::
* system_::
* test::
* undefine::
* unset::
* update::
* While::



File: gnuplot.info, Node: cd, Next: call, Prev: コマンド_(Commands), Up: コマンド_(Commands)

cd
==



*Note cd:: コマンドはカレントディレクトリを変更します。

書式:
             cd '<ディレクトリ名>'


ディレクトリ名は引用符に囲まれていなければなりません。

例:
             cd 'subdir'
             cd '..'


バックスラッシュ (\) は二重引用符内 (") では特別な意味を持ってしまうた
めにエスケープする必要がありますので、Windows ユーザには単一引用符を使
うことを勧めます。例えば、
             cd "c:\newdata"

では失敗しますが、
             cd 'c:\newdata'
             cd "c:\\newdata"

なら期待通りに動くでしょう。



File: gnuplot.info, Node: call, Next: clear, Prev: cd, Up: コマンド_(Commands)

call
====



*Note call:: コマンドは、1 つの機能以外は `load` コマンドと等価です。そ
の機能は、10 個までのパラメータをコマンドに追加できることです(パラメー
タは標準的な構文規則によって区切られます)。これらのパラメータは、ファイ
ルから読まれる行に代入することができます。*Note call:: した入力ファイル
から各行が読まれる時に、`$` (ドル記号) に続く数字 (0--9) の並びを走査し
ます。もし見つかれば、その並びは *Note call:: のコマンド行の対応するパ
ラメータで置き換えられます。*Note call:: の行でそのパラメータが文字列と
して指定されているならば、取り囲んでいる引用符が省かれて代入されます。
文字列 `$#` はパラメータの個数に置き換えられます。文字が後に続く `$`は
その文字になります。例えば、一つの `$` を得るには `$$` を使います。
*Note call:: のコマンド行に 10 個より多いパラメータを与えるとエラーが起
こります。与えられなかったパラメータは、何も無しとして扱われます。
*Note call::中のファイルの中にさらに `load` または *Note call:: コマン
ドがあっても構いません。

書式:
             call "<入力ファイル>" <パラメータ 0> <パ 1> ... <パ 9>


入力ファイル名は引用符で囲まなければなりません。そして、パラメータも引
用符で囲むことを推奨します (gnuplot の将来のバージョンでは引用符で囲ん
である部分と囲んでない部分に対しては違う取り扱いをする予定です)。

例:

ファイル 'calltest.gp' は以下の行を含んでいるとすると:
         print "argc=$# p0=$0 p1=$1 p2=$2 p3=$3 p4=$4 p5=$5 p6=$6 p7=x$7x"


次の行を入力すると:
         call 'calltest.gp' "abcd" 1.2 + "'quoted'" -- "$2"


以下のように表示されるでしょう:
         argc=7 p0=abcd p1=1.2 p2=+ p3='quoted' p4=- p5=- p6=$2 p7=xx


注意: *Note using:: を使用しているデータファイルでは文法的に重なってし
まいます。その場合、*Note call:: されたデータファイルからプロットすると
きは、データの n カラム目の指示には `$$n` または `column(n)` を使用して
ください。



File: gnuplot.info, Node: clear, Next: Do, Prev: call, Up: コマンド_(Commands)

clear
=====



*Note clear:: コマンドは、*Note output:: で選択された画面または出力装置
をクリアします。通常、ハードコピー装置に対しては改ページを行います。出
力装置を選択するには *Note terminal:: を使用して下さい。

いくつかの出力装置は *Note clear:: コマンドでは *Note size:: で定義され
た描画領域のみを消去します。そのため、*Note multiplot:: とともに使用す
ることで挿入図を一つ作ることができます。

例:
           set multiplot
           plot sin(x)
           set origin 0.5,0.5
           set size 0.4,0.4
           clear
           plot cos(x)
           unset multiplot


これらのコマンドの詳細については、以下参照: *Note multiplot::,
*Note size::, *Note origin::。



File: gnuplot.info, Node: Do, Next: evaluate, Prev: clear, Up: コマンド_(Commands)

Do
==


書式:
           do for <iteration-spec> {
                <commands>
                <commands>
           }

これは、コマンド列を複数回実行します。コマンドは中カッコ {} で囲み、か
つ開始カッコ "{" は、キーワード `do` と同じ行に置く必要があります。この
コマンドは、古い形式 (かっこなし) の if/else 構文と一緒に使うことはでき
ません。繰り返し指定 <iteration-spec> の例については、以下参照:
`iteration`。例:
           set multiplot layout 2,2
           do for [name in "A B C D"] {
               filename = name . ".dat"
               set title sprintf("Condition %s",name)
               plot filename title name
           }
           unset multiplot




File: gnuplot.info, Node: evaluate, Next: exit, Prev: Do, Up: コマンド_(Commands)

evaluate
========



コマンド *Note evaluate:: は、引数文字列として与えられたコマンドを実行
します。その文字列中に改行文字を入れてはいけません。

書式:
           eval <string expression>


これは、特に同様のコマンドの繰り返しに有用です。

例:
           set_label(x, y, text) \
             = sprintf("set label '%s' at %f, %f point pt 5", text, x, y)
           eval set_label(1., 1., 'one/one')
           eval set_label(2., 1., 'two/one')
           eval set_label(1., 2., 'one/two')


文字列からコマンドを実行する別の方法に関しては、以下参照:
*Note macros::。



File: gnuplot.info, Node: exit, Next: fit, Prev: evaluate, Up: コマンド_(Commands)

exit
====



*Note exit:: と *Note quit:: の両コマンドは END-OF-FILE 文字 (通常
Ctrl-D) 同様、現在の入力ストリーム、すなわち端末の対話やパイプ入力、ファ
イル入力 (パイプ) からの入力を終了させます。

入力ストリームが入れ子 (階層的な `load` のスクリプトで) になっている場
合、読み込みは親のストリームで継続されます。トップレベルのストリームが
閉じられると、プログラムはそれ自身終了します。

コマンド `exit gnuplot` は、直ちに、無条件に、そして例え入力ストリーム
が多段階にネストされていても、gnuplot を終了させます。その場合、開かれ
ていた全ての出力ファイルはきれいに完全な形では閉じられない可能性があり
ます。使用例:

           bind "ctrl-x" "unset output; exit gnuplot"


詳細は、以下参照: `batch/interactive`。



File: gnuplot.info, Node: fit, Next: help, Prev: exit, Up: コマンド_(Commands)

fit
===





`fit` コマンドはユーザの与えた式を (x,y) または (x,y,z) の形式のデータ
点の集合への当てはめを可能にします。それには Marquardt-Levenberg 法によ
る非線形最小自乗法 (NLLS) の実装が用いられます。式の内部に現われるユー
ザ定義変数はいずれも当てはめのパラメータとして使うことができます。ただ、
その式の返り値は実数である必要があります。

書式:
           fit {<ranges>} <expression>
               '<datafile>' {datafile-modifiers}
               via '<parameter file>' | <var1>{,<var2>,...}


範囲 (xrange,yrange) は、当てはめられるデータ点を一時的に制限するのに
使うことができ、その範囲を超えたデータは全て無視されます。その書式は
*Note plot:: コマンド同様
           [{dummy_variable=}{<min>}{:<max>}],

です。以下参照: `plot ranges`。

<expression> は通常はあらかじめユーザ定義された f(x) または f(x,y) の形
の関数ですが、`gnuplot` で有効な任意の数式を指定できます。

<datafile> は *Note plot:: コマンドと同様に扱われます。*Note
datafile:: の修飾子 (*Note using::, *Note every::,...) は、*Note
smooth:: とあまり勧められない *Note thru::を除いて、全て `fit` に使うこ
とができます。以下参照:*Note datafile::。

当てはめる 1 変数関数 z=f(x) へのデフォルトのデータの書式は z か x:zで
す。つまり、データが 1 列しかなければそれは従属変数値 (関数値) と見なさ
れ、行番号が独立変数値 (変数値) となり、2 列のデータがあれば、1 列目が
独立変数値、2 列目が従属変数値となります。

これらの形式はデータファイルへの *Note using:: 指定子で変更でき、例えば
z の値を他の列から取ったり、あるいは複数の列から計算した値とすることが
できます。3 番目の *Note using:: 指定 (列番号、または数式) が与えられた
場合は、それは対応する z の値の標準偏差として解釈され、それはそのデータ
への重み (=1/s**2) を計算するのに使われます。そうでなければ、全てのデー
タは同じ重み (1) で計算されます。*Note using:: オプションを全く指定しな
かった場合、3 列目のデータがあった場合でもデータから z の偏差は読まれま
せんので、その場合は重み 1 になります。

2 変数関数 z=f(x,y) を当てはめる場合、データの書式は *Note using:: による 4
つの項目 x:y:z:s が要求されます。これは完全に全てが与えられなければな
らず、不足する項目に対してはどの列もデフォルトは仮定されていません。各
データ点の重みは上と同様に 's' から計算されます。もし誤差評価を持って
いなければ、定数値を定数式として指定すればいいでしょう (以下参照:
*Note using::)。例えば `using 1:2:3:(1)` のように。

当てはめ関数には、独立変数を 5 つまで持たせられますが、1 変数以外の場合
は、その独立変数の個数よりも 2 つ多い *Note using:: 指定をしなければい
けません。許される書式、そしてデフォルトのダミー変数名は以下の通りです:

           z
           x:z
           x:z:s
           x:y:z:s
           x:y:t:z:s
           x:y:t:u:z:s
           x:y:t:u:v:z:s


ダミー変数名は、下にあげるように範囲指定によって変更できます。最初の範
囲は *Note using:: 指定の最初のものに対応し、以下同様です。z (従属変数)
の範囲も指定できますが、その名前は変更できません。

複数のデータ集合も複数の 1 変数関数に同時に当てはめることも、y を '仮変
数' とすれば可能です。例えばデータ行番号を使い、2 変数関数への当てはめ、
とすればいいでしょう。以下参照: `fit multi-branch`。

`via` 指定子は、パラメータの調節を直接か、またはパラメータファイルを参
照することによって行うかを指定します。

例:
           f(x) = a*x**2 + b*x + c
           g(x,y) = a*x**2 + b*y**2 + c*x*y
           FIT_LIMIT = 1e-6
           fit f(x) 'measured.dat' via 'start.par'
           fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
           fit f(x) './data/trash.dat' using 1:2:3 via a, b, c
           fit g(x,y) 'surface.dat' using 1:2:3:(1) via a, b, c
           fit a0 + a1*x/(1 + a2*x/(1 + a3*x)) 'measured.dat' via a0,a1,a2,a3
           fit a*x + b*y 'surface.dat' using 1:2:3:(1) via a,b
           fit [*:*][yaks=*:*] a*x+b*yaks 'surface.dat' u 1:2:3:(1) via a,b
           fit a*x + b*y + c*t 'foo.dat' using 1:2:3:4:(1) via a,b,c
           h(x,y,t,u,v) = a*x + b*y + c*t + d*u + e*v
           fit h(x,y,t,u,v) 'foo.dat' using 1:2:3:4:5:6:(1) via a,b,c,d,e


反復の個々のステップの後で、当てはめの現在の状態についての詳細な情報が
画面に表示されます。そし最初と最後の状態に関する同じ情報が "fit.log"と
いうログファイルにも書き出されます。このファイルは前の当てはめの履歴を
消さないように常に追加されていきます。これは望むなら削除、あるいは別な
名前にできます。コマンド `set fit logfile` を使ってログファイルの名前を
変更することもできます。

gnuplot が、`set fit errorvariables` を使えるようにインストールされてい
て、そのコマンドを使用した場合、各当てはめパラメータの誤差は、そのパラ
メータと似た名前 ("_err" が追加された名前) の変数に保存されます。よって
その誤差を更なる計算の入力として使用することができます。

当てはめの反復は Ctrl-C を押すことで中断できます。現在の反復が正常に終
了した後、(1) 当てはめを止めて現在のパラメータの値を採用する(2) 当ては
めを続行する(3) 環境変数 FIT_SCRIPT で指定した `gnuplot` コマンドを実行
するのいずれかを選ぶことができます。FIT_SCRIPT のデフォルトは *Note
replot:: であり、よってもしデータと当てはめ関数を一つのグラフにあらかじ
め描画してあれば、現在の当てはめの状態を表示することができます。

`fit` が終了した後は、最後のパラメータの値を保存するのに *Note
update:: コマンドを使います。その値は再びパラメータの値として使うことが
できます。詳細は、以下参照: *Note update::。

* Menu:

* パラメータの調整_(adjustable_parameters)::
* fit_の概略_(fit_beginners_guide)::
* 誤差評価_(error_estimates)::
* 制御_(control)::
* 複数の当てはめ_(multi-branch)::
* 初期値_(starting_values)::
* ヒント_(tips)::



File: gnuplot.info, Node: パラメータの調整_(adjustable_parameters), Next: fit_の概略_(fit_beginners_guide), Prev: fit, Up: fit

パラメータの調整 (adjustable parameters)
----------------------------------------


`via` はパラメータを調節するための 2 つの方法を指定できます。一つはコマ
ンドラインから直接指示するもので、もう一つはパラメータファイルを参照し
て間接的に行うものです。この 2 つは初期値の設定で違った方法を取ります。

調整するパラメータは、`via` キーワードの後ろにコンマで区切られた変数名
のリストを書くことで指定できます。定義されていない変数は初期値 1.0 とし
て作られます。しかし当てはめは、変数の初期値があらかじめ適切な値に設定
されている方が多分速く収束するでしょう。

パラメータファイルは個々のパラメータを、個別に 1 行に一つずつ、初期値を
次のような形で指定して書きます。
           変数名 = 初期値


'#' で始まるコメント行や空行も許されます。特別な形式として
           変数名 = 初期値       # FIXED


は、この変数が固定されたパラメータであることを意味し、それはこのファイ
ルで初期化されますが、調節はされません。これは、`fit` でレポートされる
変数の中で、どれが固定された変数であるかを明示するのに有用でしょう。な
お、`# FIXED` と言うキーワードは厳密にこの形でなくてはなりません。




File: gnuplot.info, Node: fit_の概略_(fit_beginners_guide), Next: 誤差評価_(error_estimates), Prev: パラメータの調整_(adjustable_parameters), Up: fit

fit の概略 (fit beginners_guide)
--------------------------------


`fit` は、与えられたデータ点を与えられたユーザ定義関数にもっとも良く当
てはめるようなパラメータを見つけるのに使われます。その当てはめは、同じ
場所での入力データ点と関数値との自乗誤差、あるいは残差 (SSR:Sum of the
Squared Residuals) の和を基に判定されます。この量は通常χ(カイ)自乗と呼
ばれます。このアルゴリズムは SSR を 最小化することをしようとします。も
う少し詳しく言うと、データ誤差 (または 1.0) の重みつき残差の自乗和
(WSSR) の最小化を行っています。詳細は、以下参照: `fit error_estimates`。

これが、(非線形) 最小自乗当てはめ法と呼ばれるゆえんです。`非線形` が何
を意味しているのかを見るための例を紹介しますが、その前にいくつかの仮定
について述べておきます。ここでは簡単のため、1 変数のユーザー定義関数は
z=f(x), 2 変数の関数は z=f(x,y) のようにし、いずれも従属変数として z を
用いることにします。パラメータとは `fit` が調整して適切な値を決定するユー
ザ定義変数で、関数の定義式中の未知数です。ここで言う、線形性/非線形性と
は、従属変数 z と `fit` が調整するパラメータとの関係に対するものであり、
z と独立変数 x (または x と y) との関係のことではありません (数学的に述
べると、線形最小自乗問題では、当てはめ関数のパラメータによる 2 階 (そし
て更に高階の) 導関数は 0、ということになります)。

線形最小自乗法 (LLS) では、ユーザ定義関数は単純な関数の和であり、それぞ
れは一つのパラメータの定数倍で他のパラメータを含まない項になります。非
線形最小自乗法 (NLLS) ではより複雑な関数を扱い、パラメータは色んな使わ
れ方をされます。フーリエ級数は線形と非線形の最小自乗法の違いを表す一つ
の例です。フーリエ級数では一つの項は
          z=a*sin(c*x) + b*cos(c*x).

のように表されます。もし、a と b が未知なパラメータで c は定数だとすれ
ばパラメータの評価は線形最小自乗問題になります。しかし、c が未知なパラ
メータならばそれは非線形問題になります。

線形の場合、パラメータの値は比較的簡単な線形代数の直接法によって決定で
きます。しかしそのような LLS は特殊な場合であり、'gnuplot' が使用する反
復法は、もちろんそれも含めて、より一般的な NLLS 問題を解くことができま
す。`fit` は検索を行うことで最小値を探そうとします。反復の各ステップは、
パラメータの新しい値の組に対して WSSR を計算します。Marquardt-
Levenberg のアルゴリズムは次のステップのパラメータの値を選択します。そ
してそれはあらかじめ与えた基準、すなわち、(1) 当てはめが "収束した"
(WSSR の相対誤差が FIT_LIMIT より小さくなった場合)、または (2) あらかじ
め設定された反復数の限界 FIT_MAXITER (以下参照: *Note variables::) に達
した場合、のいずれかを満たすまで続けられます。キーボードからその当ては
めの反復は中断できますし、それに続いて中止することもできます (以下参照:
`fit`)。ユーザ変数 FIT_CONVERGED は、直前の fit コマンドが収束により終
了した場合は 1 を含み、それ以外の理由で中断した場合は 0 を含みます。

当てはめに使われる関数はしばしばあるモデル (またはある理論) を元にして
いて、それはデータの振舞を記述したり、あるいは予測しようとします。よっ
て `fit` は、データがそのモデルにどれくらいうまく当てはまっているのかを
決定するため、そして個々のパラメータの誤差の範囲を評価するために、モデ
ルの自由なパラメータの値を求めるのに使われます。以下参照: `fit
error_estimates`。

そうでなければ、曲線による当てはめにおける関数は、モデルとは無関係に選
ばれています (それは十分な表現力と最も少ない数のパラメータを持ち、デー
タの傾向を記述しそうな関数として経験に基づいて選ばれるでしょう)。

しかし、もしあなたが全てのデータ点を通るような滑らかな曲線を欲しいなら
`fit` ではなく、むしろ *Note plot:: の *Note smooth:: オプションでそれ
を行うべきでしょう。



File: gnuplot.info, Node: 誤差評価_(error_estimates), Next: 制御_(control), Prev: fit_の概略_(fit_beginners_guide), Up: fit

誤差評価 (error estimates)
--------------------------

`fit` において "誤差" という用語は 2 つの異なった文脈で用いられます。一
つはデータ誤差、もう一つはパラメータ誤差です。

データ誤差は、平方残差の重み付きの和 WSSR、すなわちχ自乗を決定する際個々
のデータ点の相対的な重みを計算するのに用いられます。それらはパラメータ
の評価に影響を与えます。それは、それらが、当てはめられた関数からの個々
のデータ点の偏差が最終的な値に与える影響の大きさを決定することによりま
す。正確なデータ誤差評価が与えられている場合には、パラメータの誤差評価
等の `fit` が出力する情報はより役に立つでしょう。

'statistical overview' では `fit` の出力のいくつかを説明し、'practical
guidelines' に対する背景を述べています。

* Menu:

* 統計的な概要_(statistical_overview)::
* 実用的なガイドライン_(practical_guidelines)::



File: gnuplot.info, Node: 統計的な概要_(statistical_overview), Next: 実用的なガイドライン_(practical_guidelines), Prev: 誤差評価_(error_estimates), Up: 誤差評価_(error_estimates)

統計的な概要 (statistical overview)
...................................


非線形最小自乗法 (Non-Linear Least-Squares; NLLS) の理論は、誤差の正規
分布の点から一般的に記述されています。すなわち、入力データは与えられた
平均とその平均に対する与えられた標準偏差を持つガウス (正規) 分布に従う
母集団からの標本と仮定されます。十分大きい標本、そして母集団の標準偏差
を知ることに対しては、χ自乗分布統計を用いて、通常「χ自乗」と呼ばれる値
を調べることにより「当てはめの良さ」を述べることができます。減らされた
自由度のχ自乗 (χ自乗の自由度は、データ点の数から当てはめられるパラメー
タの個数だけ引いた数) が 1.0 である場合は、データ点と当てはめられた関数
との偏差の重みつき自乗和が、現在のパラメータ値に対する関数と与えられた
標準偏差によって特徴付けられた母集団の、ランダムなサンプルに対する自乗
和とが全く同じであることを意味します。

分散 = 総計である数え上げ統計学同様、母集団の標準偏差が定数でない場合、
各点は観測される偏差の和と期待される偏差の和を比較するときに個別に重み
づけされるべきです。

最終段階で `fit` は 'stdfit'、すなわち残差の RMS (自乗平均平方根) で求
められる当てはめの標準偏差と、データ点が重みづけられている場合に '減ら
されたχ自乗' とも呼ばれる残差の分散をレポートします。自由度 (データ点の
数から当てはめパラメータの数を引いたもの) はこれらの評価で使用されます。
なぜなら、データ点の残差の計算で使われるパラメータは同じデータから得ら
れるものだからです。これらの値は以下の変数に代入されます:
           FIT_NDF = 自由度の数
           FIT_WSSR = 重みつき残差の自乗和
           FIT_STDFIT = sqrt(WSSR/NDF)


パラメータに関する信頼レベルを評価することで、当てはめから得られる最小
のχ自乗と、要求する信頼レベルのχ自乗の値を決定するためのχ自乗の統計を用
いることが出来ます。しかし、そのような値を生成するパラメータの組を決定
するには、相当のさらなる計算が必要となるでしょう。

`fit` は信頼区間の決定よりむしろ、最後の反復後の分散-共分散行列から直ち
に得られるパラメータの誤差評価を報告します。これらの評価は、標準偏差と
して計算される量の指定に関する統計上の条件が、一般には非線形最小自乗問
題では保証されないのですが、線形最小自乗問題での標準誤差 (各パラメータ
の標準偏差) と同じ方法で計算されます。そしてそのため慣例により、これら
は "標準誤差" とか "漸近標準誤差" と呼ばれています。漸近標準誤差は一般
に楽観過ぎ、信頼レベルの決定には使うべきではありませんが、定性的な指標
としては役に立つでしょう。

最終的な解は、解の範囲におけるパラメータの相関を示す相関行列も生成しま
す: その主対角要素、すなわち自己相関は常に 1 で、全てのパラメータが独立
ならば非対角要素はすべて 0 に近い値になります。完全に他を補いあう 2つの
変数は、大きさが 1 で、関係が正の相関か負の相関かによって正か負になる符
号を持つ非対角要素を持ちます。非対角要素の大きさが小さいほど、各パラメー
タの標準偏差の評価は、漸近標準誤差に近くなります。



File: gnuplot.info, Node: 実用的なガイドライン_(practical_guidelines), Prev: 統計的な概要_(statistical_overview), Up: 誤差評価_(error_estimates)

実用的なガイドライン (practical guidelines)
...........................................



個々のデータ点への重みづけの割り当ての基礎を知っているなら、それが測定
結果に対するより詳しい情報を使用させようとするでしょう。例えば、幾つか
の点は他の点より当てになるということを考慮に入れることが可能です。そし
て、それらは最終的なパラメータの値に影響します。

データの重み付けは、最後の反復後の `fit` の追加出力に対する解釈の基礎を
与えます。各点に同等に重み付けを行なうにしても、重み 1 を使うことよりも
むしろ平均標準偏差を評価することが、χ自乗が定義によりそうであるように、
WSSR を 無次元変数とすることになります。

当てはめ反復の各段階で、当てはめの進行の評価に使うことが出来る情報が表
示されます ('*' はより小さい WSSR を見つけられなかったこと、そして再試
行していることを意味します)。'sum of squares of residuals' (残差の自乗
和) は、'chisquare' (χ自乗) とも呼ばれますが、これはデータと当てはめ関
数との間の WSSR を意味していて、`fit` はこれを最小化しようとします。こ
の段階で、重み付けされたデータによって、χ自乗の値は自由度 (= データ点の
数 - パラメータの数) に近付くことが期待されます。WSSR は補正されたχ自乗
値 (WSSR/ndf; ndf = 自由度)、または当てはめ標準偏差 (stdfit =
sqrt(WSSR/ndf)) を計算するのに使われます。それらは最終的な WSSR に対し
てレポートされます。

データが重み付けされていなければ、stdfit は、ユーザの単位での、データと
当てはめ関数の偏差の RMS (自乗平均平方根) になります。

もし妥当なデータ誤差を与え、データ点が十分多く、モデルが正しければ、補
正χ自乗値はほぼ 1 になります (詳細は、適当な統計学の本の 'χ自乗分布' の
項を参照してください)。この場合、この概要に書かれていること以外に、モデ
ルがデータにどれくらい良く当てはっているかを決定するための追加の試験方
法がいくつかあります。

補正χ自乗が 1 よりはるかに大きくなったら、それは不正なデータ誤差評価、
正規分布しないデータ誤差、システム上の測定誤差、孤立した標本値
(outliers)、または良くないモデル関数などのためでしょう。例えば`plot
'datafile' using 1:($2-f($1))` などとして残差を描画することは、それらの
システム的な傾向を知るための手がかりとなります。データ点と関数の両者を
描画することは、他のモデルを考えための手がかりとなるでしょう。

同様に、1.0 より小さい補正χ自乗は、WSSR が、正規分布する誤差を持つラン
ダムなサンプルと関数に対して期待されるものよりも小さいことを意味します。
データ誤差評価が大きすぎるのか、統計的な仮定が正しくないのか、またはモ
デル関数が一般的すぎて、内在的傾向に加えて特殊なサンプルによる変動の当
てはめになっているのでしょう。最後の場合は、よりシンプルな関数にすれば
うまく行くでしょう。

標準的なエラーを、パラメータの不確定性に関する、あるより現実的な評価に
関係付けること、および相関行列の重要性を評価することができるようになる
前に、あなたは `fit` と、それを適用しようとするある種の問題に慣れておく
必要があるでしょう。

`fit` は、大抵の非線形最小自乗法の実装では共通して、距離の自乗
(y-f(x))**2 の重み付きの和を最小化しようとすることに注意してください。
それは、x の値の "誤差" を計算に関してはどんな方法も与えてはおらず、単
に y に関する評価のみです。また、"孤立点" (正規分布のモデルのから外れて
いるデータ点) は常に解を悪化させる可能性があります。



File: gnuplot.info, Node: 制御_(control), Next: 複数の当てはめ_(multi-branch), Prev: 誤差評価_(error_estimates), Up: fit

制御 (control)
--------------

`fit` に影響を与えるために定義できるたくさんの `gnuplot` の変数がありま
す。それらは `gnuplot` の動作中に一度定義できますが、それは
`control_variable` で紹介し、`gnuplot` が立 ち上がる前に設定する変数は
`environment_variables` で紹介します。

* Menu:

* 制御変数_(control_variables)::
* 環境変数_(control_environment)::



File: gnuplot.info, Node: 制御変数_(control_variables), Next: 環境変数_(control_environment), Prev: 制御_(control), Up: 制御_(control)

制御変数 (control variables)
............................

デフォルトのもっとも小さい数字の限界 (1e-5) は、変数
           FIT_LIMIT

で変更できます。残差の平方自乗和が 2 つの反復ステップ間で、この数値より
小さい数しか変化しなかった場合、当てはめルーチンは、これを '収束した'と
見なします。

反復数の最大値は変数
           FIT_MAXITER

で制限されます。0 (または定義しない場合) は制限無しを意味します。

更にそのアルゴリズムを制御したい場合で、かつ Marquardt-Levenberg アルゴ
リズムを良く知っている場合は、さらにそれに影響を与える変数があります。
`lambda` (λ) の最初の値は、通常 ML 行列から自動的に計算されますが、もし
それをあらかじめ用意した値にセットしたければ
           FIT_START_LAMBDA

にセットしてください。FIT_START_LAMBDA を 0 以下にセットすると、自動的
に計算されるようになります。変数
           FIT_LAMBDA_FACTOR

は、χ自乗化された関数が増加、あるいは減少するにつれて `lambda` が増加あ
るいは減少する因数を与えます。FIT_LAMBDA_FACTOR を 0 とすると、それはデ
フォルトの因数 10.0 が使用されます。

`fit` には FIT_ から始まる変数が他にもありますから、ユーザ定義変数とし
てはそのような名前で始まる変数は使わないようにするのが安全でしょう。

変数 FIT_SKIP と FIT_INDEX は、以前の版の `gnuplot` の、`gnufit` と呼ば
れていた `fit` パッチで使われていたもので、現在は使用されていません。
FIT_SKIP の機能はデータファイルに対する *Note every:: 指定子で用意され
ています。FIT_INDEX は複数当てはめ法 (multi-branch fitting) で使われて
いたものですが、1 変数の複数当てはめ法は、今では 疑似 3 次元当てはめと
して行なわれていて、そこでは枝の指定には 2 変数と *Note using:: が使わ
れています。以下参照: `fit multi-branch`。



File: gnuplot.info, Node: 環境変数_(control_environment), Prev: 制御変数_(control_variables), Up: 制御_(control)

環境変数 (control environment)
..............................

環境変数は `gnuplot` が立ち上がる前に定義しなければなりません。その設定
方法はオペレーティングシステムに依存します。

           FIT_LOG

は、当てはめのログが書かれるファイル名 (およびパス) を変更します。デフォ
ルトでは、作業ディレクトリ上の "fit.log" となっています。そのデフォルト
の値はコマンド `set fit logfile` を使って上書きできます。

           FIT_SCRIPT

は、ユーザが中断した後に実行するコマンドを指定します。デフォルトでは
*Note replot:: ですが、*Note plot:: や `load` コマンドとすれば、当ては
めの進行状況の表示をカスタマイズするのに便利でしょう。



File: gnuplot.info, Node: 複数の当てはめ_(multi-branch), Next: 初期値_(starting_values), Prev: 制御_(control), Up: fit

複数の当てはめ (multi-branch)
-----------------------------



複数当てはめ法 (multi-branch fitting) では、複数のデータ集合を、共通の
パラメータを持つ複数の 1 変数の関数に、WSSR の総和を最小化することによっ
て同時に当てはめることが出来ます。各データ集合に対する関数とパラメータ
(枝) は '疑似変数' を使うことで選択できます。例えば、データ行番号(-1;
'データ列' の番号) またはデータファイル番号 (-2) を 2 つ目の独立変数と
します。

例: 2 つの指数減衰形 z=f(x) が与えられていて、それぞれ異なるデータ集合
を記述しているが、共通した減衰時間を持ち、そのパラメータの値を評価する。
データファイルが x:z:s の形式であったとすると、この場合以下のようにすれ
ばよい。
          f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
          fit f(x,y) 'datafile' using  1:-2:2:3  via a, b, tau


より複雑な例については、デモファイル "fit.dem" で使われる "hexa.fnc"を
参照してください。

もし従属変数のスケールに差がある場合、単位の重み付けでは 1 つの枝が支配
してしまう可能性があるので、適当な重み付けが必要になります。各枝をバラ
バラに当てはめるのに複数当てはめ法の解を初期値として用いるのは、全体を
合わせた解の各枝に対する相対的な影響に関する表示を与えることになるでしょ
う。



File: gnuplot.info, Node: 初期値_(starting_values), Next: ヒント_(tips), Prev: 複数の当てはめ_(multi-branch), Up: fit

初期値 (starting values)
------------------------


非線形当てはめは、大域的な最適値 (残差の自乗和 (SSR) の最小値を持つ解)
への収束は保証はしませんが、局所的な極小値を与えることはできます。その
サブルーチンはそれを決定する方法を何も持ち合わせていないので、これが起
こったかどうかを判断するのはあなたの責任となります。

`fit` は、解から遠くから始めると失敗するかも知れませんし、しばしばそれ
は起こり得ます。遠くというのは、SSR が大きく、パラメータの変化に対して
その変化が小さい、あるいは数値的に不安定な領域 (例えば数値が大きすぎて
浮動小数の桁あふれを起こす) に到達してしまって、その結果 "未定義値
(undefined value)" のメッセージか `gnuplot` の停止を引き起こしてしまう
ような場合を意味します。

大域的な最適値を見つける可能性を改善するには、最初の値をその解に少なく
ともほぼ近くに取るべきでしょう。例えば、もし可能ならば一桁分の大きさの
範囲内で。最初の値が解に近いほど他の解で終了してしまう可能性は低くなり
ます。最初の値を見つける一つの方法は、データと当てはめ関数を同じグラフ
の上に描画して適当な近さに達するまで、パラメータの値を変更して *Note
replot::することを繰り返すことです。その描画は、よくない当てはめの極小
値で当てはめが終了したかどうかをチェックするのにも有用です。

もちろん、適度に良い当てはめが、"それよりよい" 当てはめ (ある改良された
当てはめの良さの基準によって特徴付けられた統計学的な意味で、あるいはそ
のモデルのより適切な解である、という物理的な意味で) が存在しないことの
証明にはなりません。問題によっては、各パラメータの意味のある範囲をカバー
するような様々な初期値の集合に対して `fit` することが望ましいかも知れま
せん。



File: gnuplot.info, Node: ヒント_(tips), Prev: 初期値_(starting_values), Up: fit

ヒント (tips)
-------------


ここでは、`fit` を最大限に利用するためにいくつか覚えておくべきヒントを
紹介します。それらは組織的ではないので、その本質がしみ込むまで何回もよ
く読んでください。

`fit` の引数の `via` には、2 つの大きく異なる目的のための 2 つの形式が
あります。`via "file"` の形式は、バッチ処理 (非対話型での実行が可能)で
最も良く使われ、そのファイルで初期値を与え、またその後で結果を他の(また
は 同じ) パラメータファイルにコピーするために *Note update:: を使うこと
も出来ます。

`via var1, var2, ...` の形式は対話型の実行で良く使われ、コマンドヒスト
リの機構が使ってパラメータリストの編集を行い、当てはめを実行したり、あ
るいは新しい初期値を与えて次の実行を行なったりします。これは難しい問題
に対しては特に有用で、全てのパラメータに対して 1 度だけ当てはめを直接実
行しても、良い初期値でなければうまくいかないことが起こり得るからです。
それを見つけるには、いくつかのパラメータのみに対して何回か反復を行ない、
最終的には全てのパラメータに対する 1 度の当てはめがうまくいくところに十
分近くなるまでそれを繰り返すことです。

当てはめを行なう関数のパラメータ間に共通の依存関係がないことは確認して
おいてください。例えば、a*exp(x+b) を当てはめに使ってはいけません。それ
は a*exp(x+b)=a*exp(b)*exp(x) だからです。よってこの場合は a*exp(x)また
は exp(x+b) を使ってください。

技術的なお話: パラメータの大きさはあまり違いすぎてはいけません。絶対値
が最も大きいパラメータと最も小さいパラメータの比が大きい程当てはめの収
束は遅くなります。その比が、マシンの浮動小数の精度の逆数に近いか、また
はそれ以上ならば、ほとんど永久に収束しないか、拒否されるでしょう。よっ
てその関数をこれを避けるように改良しなければいけません。例えば、関数の
定義で 'parameter' を '1e9*parameter' にするとか、または最初の値を 1e9
で割るとか。

もし、関数を、当てはめるパラメータを係数とする、単純な関数の線形結合で
書けるなら、それはとてもいいので是非そうしてください。何故なら、問題が
もはや非線形ではないので、反復は少ない回数で収束するでしょう。もしかし
たらたった一回ですむかもしれません。

実際の実験の講義ではデータ解析に対するいくつかの指示が与えられ、それで
データへの最初の関数の当てはめが行なわれます。もしかすると、基礎理論の
複数の側面にひとつずつ対応する複数回のプロセスが必要かも知れませんが、
そしてそれらの関数の当てはめのパラメータから本当に欲しかった情報を取り
出すでしょう。しかし、`fit` を使えば、求めるパラメータの視点から直接モ
デル関数を書くことにより、それはしばしば 1 回で済むのです。時々はより難
しい当てはめ問題の計算コストがかかりますが、データ変換もかなりの割合で
避けることが出来ます。もしこれが、当てはめ関数の単純化に関して、前の段
落と矛盾してると思うなら、それは正解です。

"singular matrix" のメッセージは、この Marquardt-Levenberg アルゴリズム
のルーチンが、次の反復に対するパラメータの値の計算が出来ないことを意味
します。この場合、別な初期値から始めるか、関数を別な形で書き直すか、よ
り簡単な関数にしてみてください。

最後に、他の当てはめパッケージ (fudgit) のマニュアルから、これらの文書
を要約するようないい引用を上げます: "Nonlinear fitting is an art! (非線
形当てはめ法は芸術だ !)"



File: gnuplot.info, Node: help, Next: history, Prev: fit, Up: コマンド_(Commands)

help
====



*Note help::コマンドは、組み込みヘルプを表示します。ある項についての説
明を指定したいときには、次の書式を使って下さい:

             help {<項目名>}


もし <項目名> が指定されなかった場合は、`gnuplot` についての簡単な説明
が表示されます。指定した項目についての説明が表示された後、それに対する
細目のメニューが表示され、その細目名を入力することで細目に対するヘルプ
を続けることができます。そして、その細目の説明が表示された後に、さらな
る細目名の入力を要求されるか、または 1 つ前の項目のレベルへ戻ります。こ
れを繰り返すとやがて、`gnuplot` のコマンドラインへと戻ります。

また、疑問符 (?) を項目として指定すると、現在のレベルの項目のリストが表
示されます。



File: gnuplot.info, Node: history, Next: if, Prev: help, Up: コマンド_(Commands)

history
=======



コマンド `history` は、過去に編集したコマンドラインの履歴 (history) の
一覧を表示したり、その一部を保存したり、その一つを実行したりします。

具体例で使用法を紹介します:

           history               # 履歴全体を表示
           history 5             # 履歴内の直前の 5 つを表示
           history quiet 5       # エントリ番号なしで直前の 5 つを表示
           history "hist.gp"     # 履歴全体をファイル hist.gp に書き出す
           history "hist.gp" append # 履歴全体をファイル hist.gp に追加する
           history 10 "hist.gp"  # 直前の 10 個をファイル hist.gp に出力
           history 10 "|head -5 >>diary.gp" # パイプで履歴を 5 つ書き出す
           history ?load         # 履歴内の "load" で始まるものすべてを表示
           history ?"set c"      # 上と同様 (複数の語は引用符で囲む)
           hi !reread            # "reread" で始まる最も新しい行を実行
           hist !"set xr"        # 上と同様 (複数の語は引用符で囲む)
           hi !hi                # 当ててみて :-))


popen 関数をサポートするようなシステム (Unix など) では、履歴の出力をパ
イプ経由で他の外部プログラムに渡すことができます。その場合、上の例の一
つにあるように、ファイル名としてコマンド名の先頭に '|' をつけたものを使
います。



File: gnuplot.info, Node: if, Next: 繰り返し_(iteration), Prev: history, Up: コマンド_(Commands)

if
==



新しい書式:
           if (<condition>) { <command>; <command>
                  <commands>
                  <commands>
           } else {
                  <commands>
           }

以前の書式:
           if (<条件>) <コマンド行> [; else if (<条件>) ...; else ...]


このバージョンの gnuplot は、if/else のブロック形式をサポートしています。
キーワード `if`, `else` の後ろに開始カッコ "{" が続く場合、"}" で終了す
るブロックまでのすべての文 (複数の入力行も可) に条件的な実行が適用され
ます。if コマンドは入れ子にすることもできます。

古い形式の 1 行の if/else 文もまだサポートされていますが、新しいブロッ
ク形式の書式とは混ぜてはいけません。以下参照: *Note if-old::。

* Menu:

* if-old::



File: gnuplot.info, Node: if-old, Prev: if, Up: if

if-old
------


gnuplot バージョン 4.4 までは、if/else コマンドの通用範囲は 1 行内に留
まっていました。現在は中カッコ { } で囲むことで複数行にすることが可能に
なっています。その古い形式も残されていますが、それは中カッコのブロック
内で使うことはできません。

キーワード `if` が "{" をともなわない場合は、<条件> が真 (ゼロでない)な
らば <コマンド行> のコマンド (複数も可) が実行され、偽 (ゼロ) ならばス
キップされます。いずれの場合も入力行の最後になるか、`else` が現れるとこ
ろまでそれが行われます。`;` を使うと同じ行に複数のコマンド置くことが可
能ですが、条件付きのコマンド (`if` の構文自体) はそこでは終らないことに
注意してください。

例:
           pi=3
           if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi

を実行すると、
           ?Fixing pi!
           3.14159265358979

と表示されますが、
           if (1==2) print "Never see this"; print "Or this either"

とすると、何も表示されません。

その他:
           v=0
           v=v+1; if (v%2) print "2" ; else if (v%3) print "3" ; else print "fred"

(何度も最後の行を繰り返してみてください !)

if と reread を使ってループを構成する例は、以下参照: *Note reread::。



File: gnuplot.info, Node: 繰り返し_(iteration), Next: load, Prev: if, Up: コマンド_(Commands)

繰り返し (iteration)
====================



*Note plot::, `splot`, `set`, *Note unset:: コマンドでは、繰り返し節を
使うこともできます。これは、基本的なコマンドを複数回実行する効果を持ち、
そのおのおのの実行では繰り返し制御変数によって数式は再評価されます。
`do` コマンドでは、どんなコマンド列でも繰り返し実行させることができます。
繰り返し節は現在は以下の 2 つの形式をサポートしています:

           for [intvar = start:end{:increment}]
           for [stringvar in "A B C D"]


例:

           plot for [filename in "A.dat B.dat C.dat"] filename using 1:2 with lines
           plot for [basename in "A B C"] basename.".dat" using 1:2 with lines
           set for [i = 1:10] style line i lc rgb "blue"
           unset for [tag = 100:200] label tag


繰り返しの入れ子もサポートしています:

           set for [i=1:9] for [j=1:9] label i*10+j sprintf("%d",i*10+j) at i,j


さらなる説明については、以下参照: `plot iteration`, `do`。




File: gnuplot.info, Node: load, Next: lower, Prev: 繰り返し_(iteration), Up: コマンド_(Commands)

load
====



`load` コマンドは、指定された入力ファイルの各行を、それが対話的に入力さ
れたかのように実行します。*Note save:: コマンドでつくられたファイルは、
`load` することができます。有効なコマンドの書かれたテキストファイルをつ
くれば、それは、`load`コマンドによって、実行することができます。`load`
中のファイルの中にさらに `load` または *Note call:: コマンドがあっても
構いません。コマンド中のコメントについては、以下参照: `comments`。
`load` するときに引数を与える方法については、以下参照: *Note call::。

書式:
             load "<入力ファイル名>"


入力ファイル名は引用符で囲まなければなりません。

`load` コマンドは、標準入力からのコマンドの入力のために、特別なファイル
名 "-" を用意しています。これは、`gnuplot` のコマンドファイルが、いくつ
かのコマンドを標準入力から受け付けることを意味します。詳細については、
以下参照: `batch/interactive`。

Unix のように popen 関数をサポートするようなシステムでは、'<' で始まる
ファイル名にすることで、入力ファイルをパイプから読み込むことができます。

例:
             load 'work.gnu'
             load "func.dat"
             load "< loadfile_generator.sh"


`gnuplot` への引数として与えられたファイル名は、暗黙のうちに `load` コ
マンドによって実行されます。これらは、指定された順にロードされ、その後
`gnuplot` は終了します。



File: gnuplot.info, Node: lower, Next: pause, Prev: load, Up: コマンド_(Commands)

lower
=====



書式:
           lower {plot_window_nb}


コマンド *Note lower:: (*Note raise:: の反対) は、`pm`, `win`, `wxt`,
`x11` 等のgnuplot の対話型出力形式の実行中に、描画ウィンドウを下 (背後)
に下げます。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z
方向のウィンドウの重なりの下に置きます。

`x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デフォ
ルトではこのコマンドはそれらの複数のウィンドウを降順に下げ、最初に作ら
れたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べます。
オプション引数の描画番号が与えられた場合、それに対応する描画ウィンドウ
が存在すればそれのみが下げられます。

オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
`win` では無視されます。



File: gnuplot.info, Node: pause, Next: plot, Prev: lower, Up: コマンド_(Commands)

pause
=====



*Note pause:: コマンドは、コマンドに続く任意の文字列を表示した後、指定
された時間または、改行キーが押されるまで待ちます。*Note pause:: コマン
ドは、`load` 用のファイルと共に使用すると、便利になるでしょう。

書式:
           pause <time> {"<string>"}
           pause mouse {<endcondition>}{, <endcondition>} {"<string>"}


<time> は、任意の定数または式です。-1 を指定すると改行キーが押されるま
で待ちます。0 を指定すると一切待たず、正の数を指定するとその秒数だけ待
ちます。実行環境が秒以下の時間指定をサポートしていない場合、その時間は
整数の秒数に丸められます。`pause 0` は *Note print:: と同じです。

使用している出力形式が `mousing` (マウス機能) をサポートしている場合、
`pause mouse` は、マウスクリックがあるか ctrl-C が押されるまで待つよう
になります。そうでない出力形式、またはマウス機能が有効になってない場合
`pause mouse` は `pause -1` と同じです。

一つ、あるいは複数の終了条件 (endcondition) が `pause mouse` の後に与え
られた場合、そのうちのどの一つでも pause は終了します。指定できる終了条
件は、`keypress`, `button1`, `button2`, `button3`, `close`, `any`のいず
れかです。pause がキー入力によって終了した場合、押されたキーのASCII コー
ドは MOUSE_KEY に保存され、文字それ自身は、1 文字の文字列値として
MOUSE_CHAR に返されます。`keypress` が終了条件の一つであれば、ホットキー
(キー割り当てコマンド) は無効になります。`buttons3` が終了条件の一つで
あれば、拡大機能は無効になります。

どの場合でもマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2, MOUSE_Y2 に
保存されます。以下参照: *Note variables::。

注意: *Note pause:: コマンドは OS へのコマンドであり描画の一部ではない
ので、異なる出力装置では異なる動作をする可能性があります。(これは、テキ
ストとグラフィックスが、どのように混在するかによります。)

例:
           pause -1    # 改行キーが押されるまで待つ
           pause 3     # 3 秒待つ
           pause -1  "続けるには return を打ってください"
           pause 10  "これは美しくないですか ? 3 次の spline です"
           pause mouse "選択したデータ点上で任意のボタンをクリックしてください"
           pause mouse keypress "有効なウィンドウ内で A-F の文字を入力してください"
           pause mouse button1,keypress
           pause mouse any "任意のキー、ボタンで終了します"


亜種である "pause mouse key" は、有効な描画ウィンドウ内での任意のキー入
力によって再開されます。特別なキー入力まで待つようにしたい場合は、以下
のような reread によるループを使うことができます:

           print "描画ウィンドウ内で Tab キーを打つと復帰します。"
           load "wait_for_tab"


ファイル "wait_for_tab" は以下のようなものです:

           pause mouse key
           if (MOUSE_KEY != 9) reread





File: gnuplot.info, Node: plot, Next: print, Prev: pause, Up: コマンド_(Commands)

plot
====



*Note plot:: は `gnuplot` で図を描くための基本的なコマンドです。 それは
関数やデータを実に多くの方法で表示します。*Note plot:: は 2 次元の関数
やデータを描くのに使われ、`splot` は 3 次元の曲面やデータの 2 次元投影
を描きます。*Note plot:: と `splot` は多くの共通の機能を提供しますが、
その違いについては以下参照: `splot`。特に注意しておきますが、`binary
<binary list>` オプションは *Note plot::, `splot` の両方で動作しますが、
両者には小さな違いがあります。

書式:
           plot {<ranges>}
                {<iteration>}
                {<function> | {"<datafile>" {datafile-modifiers}}}
                {axes <axes>} {<title-spec>} {with <style>}
                {, {definitions{,}} <function> ...}


関数 <function>、または引用符で囲まれたデータファイル名 (<datafile>)の
どちらか一方を与えます。関数は通常は 1 本の数式ですが、媒介変数モード
(parametric) においては 2 つの数式の組です。関数は、組み込み関数、ユー
ザ定義関数、あるいはその plot コマンドの上で与えるもののいずれかを使用
できます。コンマで区切ることで、複数のデータや関数を 1 つのコマンドで描
画できます。以下参照: `data`, *Note functions::。

例:
           plot sin(x)
           plot sin(x), cos(x)
           plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
           plot "datafile.1" with lines, "datafile.2" with points
           plot [t=1:10] [-pi:pi*2] tan(t), \
                "data.1" using (tan($2)):($3/$4) smooth csplines \
                         axes x1y2 notitle with lines 5
           plot for [datafile in "spinach.dat broccoli.dat"] datafile


以下参照: *Note plot::。

* Menu:

* 軸_(axes)::
* binary::
* データ_(data)::
* errorbars::
* errorlines::
* 関数描画_(functions)::
* 媒介変数モード描画_(parametric)::
* 範囲_(ranges)::
* 繰り返し_(iteration)_::
* title::
* with::



File: gnuplot.info, Node: 軸_(axes), Next: binary, Prev: plot, Up: plot

軸 (axes)
---------


軸 (axes) は、4 種類の組が利用できます; キーワード <axes> は、特定の直
線をどの軸に尺度を合わせるか、ということを選択するのに使われます。
`x1y1` は下の軸と左の軸を指定; `x2y2` は上と右の軸の指定; `x1y2` は下と
右の軸の指定; `x2y1` は上と左の軸の指定です。*Note plot:: コマンドで指
定された範囲は、この最初の軸の組 (下と左) にのみ適用されます。



File: gnuplot.info, Node: binary, Next: データ_(data), Prev: 軸_(axes), Up: plot

binary
------


バイナリデータファイル:

以前の `gnuplot` バージョンでは、バイナリ形式のデータファイルを自動的に
検出するものもありましたが、現在はファイル名の後ろに *Note binary:: の
キーワードを与えることが必須となっています。ファイル形式に関する十分詳
細な情報は、ユーザがコマンドラインから与えるか、またはサポートしている
*Note filetype:: のバイナリ形式のファイルそれ自身から抜き出されるかする
必要があります。バイナリファイルには、大きく 2 つの形式、binary matrix
形式と binary general 形式があります。

*Note matrix:: 形式は、32 ビット IEEE 規格の浮動小数値 (float) が 2次元
配列の形で並び、それらの座標値を表す行と列が追加されています。ASCII
matrix 同様、*Note using:: リストにおいては、座標用の列の並び (1 列目)
が using の 1 番目の要素 (x 座標) に対応し、座標用の行の並び (1 行目)が
using の 2 番目の要素 (y 座標) に対応し、配列の各値が using の 3 番目の
要素 (z 座標) に対応します。

*Note general:: 形式は、任意個の列のデータを含み、それらの情報はコマン
ドラインで指定する必要があります。例えば *Note array::, *Note
record::, *Note format::, *Note using:: などでサイズや形式、データの次
元を指定できます。他にも、ファイルヘッダ読み飛ばしたり、エンディアン
(endian) を変更するための有用なコマンドがありますし、配置、データの変換
を行なうコマンドの組があります。それは、一様に標本化されたデータの場合、
その座標がファイルには含まれないことが良くあるからです。matrix バイナリ
や ASCII データと違っているところですが、general バイナリは 1,2,3 といっ
た *Note using:: リストで生成される列番号を使わず、むしろ 1 列目はファ
イルの 1 列目、あるいは *Note format::リストで指定されたもの、になりま
す。

さまざまな binary オプションに対する大域的なデフォルトの設定も可能で、
それは `(s)plot <filename> binary ...` コマンドに与えるオプションと全く
同じ書式で指定できます。その書式は `set datafile binary ...` です。一般
的な規則として、デフォルトのパラメータはファイルから抜き出されたパラメー
タで上書きされ、それはコマンドラインで指定された共通なパラメータで上書
きされます。

例えば *Note array::, *Note record::, *Note format::, *Note filetype::
の *Note general:: 形式を特定するようなキーワードが何もついていなければ、
デフォルトのバイナリ形式は *Note matrix:: です。

general バイナリデータは、特別なファイル名 '-' を使ってコマンドライン
から入力することもできます。しかし、これはキーボードからの入力を意図し
たものではなく、パイプを使ってプログラムにバイナリ形式を変換させるため
のものです。バイナリデータには最後を表す記号がありませんので、gnuplot
はパイプからデータを読み込む場合、*Note array:: 指定子で指定した数の点数にな
るまでデータを読み込み続けます。詳細に関しては、以下参照:
*Note matrix::, *Note general::。

*Note index:: キーワードは、ファイルフォーマットが 1 つのファイルにつき
1 つの曲面しか許さないため、サポートされません。*Note every:: や *Note
using:: フィルタはサポートされます。*Note using:: は、データがあたかも
上の 3 つ組の形で読まれたかのように働きます。バイナリファイルの splot
のデモ。 (http://www.gnuplot.info/demo/binary.html)

* Menu:

* general::
* array::
* record::
* skip::
* format::
* endian::
* filetype::
* keywords::



File: gnuplot.info, Node: general, Next: array, Prev: binary, Up: binary

general
.......

general バイナリデータは、その形式に関する情報が必ずしもファイル内には
なくても良く、ファイルの形式に関する詳細な情報をコマンドラインから与え
ることで、そのデータを読み込むことが可能になります。そのオプションの書
式は一時的なユーザにはやや難解ですが、general バイナリは特に gnuplotを
使い、多くのデータを送るようなアプリケーションに取っては有用です。

書式:
           plot '<file_name>' {binary <binary list>} ...
           splot '<file_name>' {binary <binary list>} ...


general バイナリ形式は、ファイル構造に関する情報に関連するキーワード、
すなわち *Note array::, *Note record::, *Note format::, *Note
filetype:: などを <binary list>内に与えることで有効になります。それ以外
の場合は matrix バイナリ形式と見なされます。(詳細に関しては、以下参照:
*Note matrix::。)

バイナリ形式に関する情報が自動的にファイルから読み取ることができるよう
な標準的なファイル形式もいくつかあります (その一覧を見るには、gnuplotの
対話画面から *Note binary:: してください)。それ以外の場合はコマンドライ
ン、あるいはデフォルトの値を設定する必要があります。キーワードに関して
は以下で説明します。

<binary list> に与えるキーワード *Note filetype:: は、ファイルを読み込
むのに使用されるルーチン、すなわちデータの形式の扱いを制御します。サポー
トしている filetype の一覧を見るには、`show datafile binary filetypes`
としてください。filetype を指定しない場合の規則は、`splot` 用に *Note
binary::キーワードが単独で与えられた場合は古典的な gnuplot バイナリ形式
だと見なされ、その他全ての状況、すなわち *Note plot:: 用かまたは少なく
とも一つの<binary list> キーワードが与えられたような場合は、raw バイナ
リファイルとみなされ、そのキーワードによってバイナリ形式が指定されます。

general バイナリデータファイルは 2 つの基本的なクラスに分かれますが、そ
れがどのように扱われるのかによって両方のクラスに入る場合もあります。一
つのクラスは、データは一様にサンプリングされていると見なされ、点の座標
は必然的にそこから生成されます。このクラスでは <binary list> キーワード
を用いて全ての制御が行なわれます。そして、このクラスでの設定の優先順位
は、コマンドラインパラメータがファイル内のパラメータを上書きし、それは
デフォルトの設定を上書きします。もう一つのクラスは、座標情報がファイル
内に含まれた複数のファイルの組のためのもの、あるいは gnuplot バイナリの
ような非一様な標本化を含み得る一つのファイルのためのものです。

gnuplot バイナリのような特殊なデータファイル以外では、一般にバイナリデー
タは概念上は ASCII データと同様に考えられます。各点は情報の列を持ってい
て、それは *Note using:: によって結びつけられる <using list> で選択され
ます。*Note format:: 文字列が何も指定されなかった場合、gnuplot はバイナ
リ変数の数を `<using list>` で与えられる最大の列番号に等しく取ります。
例えば `using 1:3` の場合は 3 列ずつデータが読み取られ、2 番目のものは
無視されます。各描画スタイルにはその典型的なパラメータの個数があり、そ
れに基づく `<using list>` がデフォルトとして選択されます。例えば`with
image` では デフォルトで `using 1` が、*Note rgbimage:: ではデフォルト
で `using 1:2:3` が使われます。*Note using:: で 点/線/index を表す特別
な文字は、一般にはバイナリデータでは使うべきではないことに注意してくだ
さい。これを制御する <binary list> のキーワードがあります。



File: gnuplot.info, Node: array, Next: record, Prev: general, Up: binary

array
.....

バイナリファイルの標本の配列の大きさを設定します。座標は gnuplot が生成
してくれます。各方向の次元を表す数を指定しなければいけません。例えば
`array=(10,20)` は、2 次元で最初の次元方向 (x) には 10 点、2 番目の次元
方向 (y) には 20 点の標本化データがあることを意味します。ファイルの終了
までデータが続くことを示すのに負の値を使えます。データ次元が 1 の場合は、
カッコは省略できます。複数のデータのサイズ指定を分離するのに、コロンを
使うことができます。例えば `array=25:35` は 2 つの 1 次元データがファイ
ルの中にあることを意味します。
           注意:  gnuplot version 4.2 では array=(128,128) という書式ではな
                  く、array=128x128 という書式を使用していました。古い書式
                  は推奨されていませんが、あなたの gnuplot が後方互換性をサ
                  ポートするようコンパイルされていれば一応今でも使えます。




File: gnuplot.info, Node: record, Next: skip, Prev: array, Up: binary

record
......

このキーワードは *Note array:: と同じ書式で、同じ機能を提供します。しか
し*Note record:: は gnuplot に座標情報を自動生成させません。これは、そ
のような座標情報が、バイナリデータファイルのある列に含まれている場合の
ためのものです。



File: gnuplot.info, Node: skip, Next: format, Prev: record, Up: binary

skip
....

このキーワードは、バイナリファイルのある区画のスキップを可能にします。
例えば、そのファイルがデータ領域の開始位置の前に 1024 バイトのヘッダを
持つような場合には、以下のようにしたいと思うでしょう:
           plot '<file_name>' binary skip=1024 ...

ファイルに複数のレコードがある場合、そのそれぞれに対する先頭のずらし位
置を指定することができます。例えば、最初のレコードの前の 512 バイトをス
キップし、2 番目、3 番目のレコードの前の 256 バイトをスキップするには以
下のようにします:
           plot '<file_name> binary record=356:356:356 skip=512:256:256 ...




File: gnuplot.info, Node: format, Next: endian, Prev: skip, Up: binary

format
......

デフォルトのバイナリ形式は、単精度浮動小数 (float) が一つ、です。それを
より柔軟に設定するために、この format で変数のサイズに関する詳細な情報
を指定できます。例えば `format="%uchar%int%float"` は、最初の using列と
して符号なし文字型変数 (unsigned char) を、2 番目の列は符号つき整数
(int) を、3 番目の列は単精度浮動小数 (float) を指定しています。もしサイ
ズ指定子の数が最大列数より小さい場合は、残りの列の変数サイズは暗黙のう
ちに最後に与えた変数サイズに等しく取られます。

さらに *Note using:: 指定同様、`*` 文字がついた読み捨てる列を書式に指定
することもできますし、繰り返しフィールドへの回数指定によって暗黙の繰り
返しを指定することもできます。例えば、`format="%*2int%3float"` は、3 つ
の実数データを読む前に、2 つの整数データを読み捨てます。使用できる変数
サイズの一覧は、`show datafile binary datasizes` で見ることができます。
それらは、それぞれのコンパイルによってそのバイトサイズとともにマシンに
依存する変数名のグループと、マシンに依存しない変数名のグループに分かれ
ています。



File: gnuplot.info, Node: endian, Next: filetype, Prev: format, Up: binary

endian
......

ファイルのバイナリデータのエンディアンは、gnuplot が動作するプラットホー
ムのエンディアンとは異なる場合も良くあります。いくつかの指定でgnuplot
がバイトをどのように扱うかを制御できます。例えば`endian=little` は、バ
イナリファイルを、そのバイトの並びが小さい桁から大きい桁へ並んでいると
見なされます。オプションは以下のものが使えます。

                   little:  小さい桁から大きな桁へ並ぶ
                      big:  大きな桁から小さな桁へ並ぶ
                  default:  compiler と同じエンディアンと見なす
              swap (swab):  エンディアンを変更する (おかしいようならこれを
                            使ってみてください)


gnuplot は、コンパイル時にオプションが指定されていれば、"middle" (や
pdp") エンディアンもサポートできます。



File: gnuplot.info, Node: filetype, Next: keywords, Prev: endian, Up: binary

filetype
........


gnuplot は、いくつか標準的なバイナリファイル形式については必要な情報を
そのファイルから抜き出すことができます。例えば "format=edf" は ESRF ヘッ
ダーファイル形式のファイルとして読み込みます。現在サポートしているファ
イル形式については、`show datafile binary filetypes` で見てください。

特別なファイル形式として `auto` があり、この場合 gnuplot はバイナリファ
イルの拡張子が、サポートされている形式の標準的な拡張子であるかをチェッ
クします。

コマンドラインキーワードはファイルから読み取る設定を上書きするのに使わ
れ、ファイルから読み取る設定はデフォルトの設定を上書きします (詳細は以
下参照: *Note binary::)。


@noindent -- AVS ---


`avs` は、自動的に認識される画像イメージに対するバイナリファイルの型の
一つです。AVS は非常単純なフォーマットで、アプリケーション間でやりとり
するのに最も適しています。これは、2 つの long (xwidth と ywidth) と、そ
の後続くピクセルの列から成り、その各ピクセルは alpha/red/green/blueの
4 バイトから成ります。


@noindent -- EDF ---



`edf` は、自動的に認識される画像イメージに対するバイナリファイルの型の
一つです。EDF は ESRF データフォーマット (ESRF Data Format) を意味して
いて、それは edf と ehf の両方の形式をサポートしています (後者は ESRF
Header Format)。画像の使用に関する詳しい情報は以下で見つかるでしょう:

       http://www.edfplus.info/specs



@noindent -- PNG ---

gnuplot が png/gif/jpeg 出力用に libgd ライブラリを使うようにインストー
ルされている場合、それらの画像形式をバイナリファイルとして読み込むこと
もできます。以下のような明示的なコマンド
           plot 'file.png' binary filetype=png

を使うこともできますし、あらかじめ以下のように設定して、拡張子から自動
的に画像形式を自動的に認識させることもできます。
           set datafile binary filetype=auto




File: gnuplot.info, Node: keywords, Prev: filetype, Up: binary

keywords
........

以下のキーワード (keyword) は、バイナリファイルから座標を生成するときに
のみ適用されます。つまり、binary array, matrix, image の個々の要素を特
定の x,y,z の位置への配置の制御のためのものです。


@noindent -- SCAN ---

gnuplot がバイナリファイルをどのように走査するか、ということと実際の描
画で見られる軸の方向との間の関係については多くの混乱が起こり得ます。そ
の混乱を減らすには、gnuplot はバイナリファイルを "常に" 点/線/面、また
は速い/普通/遅い、と走査すると考えるといいでしょう。このキーワードは
gnuplot に、その走査の方向を描画内のどの座標方向 (x/y/z) に割り当てるか
を指定します。指定は 2 つ、または 3 つの文字の並びで表現し、最初の文字
が点に、次の文字が線に、3 つ目の文字が面に対応します。例えば、
`scan=yx` は、最も速い走査 (点の選択) は y 方向に対応し、普通の速さの走
査 (線の選択) が x 方向に対応することを意味します。

描画モードが *Note plot:: の場合、指定には x と y の 2 つの文字を使うこ
とができ、`splot` に対しては x, y, z の 3 つの文字を使うことができます。

割り当てに関しては、点/線/面から直交座標方向へのみに制限する内部事情は
別にありません。この理由で、円柱座標への割り当てのための指定子も用意さ
れていて、それらは直交座標の x, y, z に類似した形で t (角度), r, z となっ
ています。


@noindent -- TRANSPOSE ---

`scan=yx`、または `scan=yxz` と同じです。


@noindent -- DX, DY, DZ ---



gnuplot が座標を生成する場合、その間隔はこれらのキーワードで指定された
ものが使用されます。例えば `dx=10 dy=20` は x 方向に 10、y 方向に 20の
間隔で標本化されたことを意味します。`dy` は `dx` がなければ使えません。
同様に `dz` は `dy` がなければ使えません。もしデータの次元が指定したキー
ワードの次元よりも大きい場合、残りの次元方向の間隔は、指定された最も高
い次元のものと同じ値が使用されます。例えば画像がファイルから読み込まれ、
`dx=3.5` のみ指定された場合、gnuplot は x 方向の間隔も y 方向の間隔も
3.5 を使用します。

以下のキーワードも座標の生成時にのみ適用されます。しかし、以下のものは
matrix バイナリファイルにも使われます。


@noindent -- FLIPX, FLIPY, FLIPZ ---

バイナリデータファイルの走査方向が gnuplot の走査方向と一致しないことが
たまにあります。これらのキーワードは、それぞれ x, y, z 方向のデータの走
査方向を逆向きにします。


@noindent -- ORIGIN  ---

gnuplot は転置 (transpose) や反転 (flip) において座標を生成する場合、常
に配列の左下の点が原点になるようにします。すなわち、データが、転置や反
転の行なわれた後の直交座標系の第 1 象限に来るようにします。

配列をグラフのその他の場所に配置したい場合、*Note origin:: キーワードで
指定した場所に gnuplot は配列の左下の点を合わせます。その指定は、*Note
plot:: では 2 つの座標の組、`splot` では 3 つの座標の組を指定してくださ
い。例えば `origin=(100,100):(100,200)` は、一つのファイルに含まれる 2
つのデータに対する指定で、2 次元の描画に対する指定です。2 つ目の例とし
て`origin=(0,0,3.5)` をあげると、これは 3 次元描画用の指定です。


@noindent -- CENTER ---

*Note origin:: と似ていますが、このキーワードは、配列の中心がこのキーワー
ドで指定した点になるように配置します。例えば `center=(0,0)` のようにし
ます。配列のサイズが `Inf` のときは center は適用されません。


@noindent -- ROTATE ---

転置 (transpose) と反転 (flip) コマンドは座標の生成と座標軸の方向にある
種の柔軟性を与えてくれます。しかし、角度に関する完全な制御は、2 次元の
回転角を記述した回転角ベクトルを与えることにより行なうことが可能になり
ます。

キーワード `rotate` は, *Note plot::, `splot` の両方で、2 次元面に対し
て適用されます。回転は座標平面の正の角度に関して行なわれます。

角度は、ラジアン単位ですが、pi や degrees の倍数としてのラジアンでも表
現できます。例えば、`rotate=1.5708`, `rotate=0.5pi`, `rotate=90deg` は
すべて同じ意味です。

*Note origin:: が指定された場合、回転は平行移動の前に左下の点を中心にし
て行なわれます。それ以外では回転は配列の中心 (`center`) に関して行なわ
れます。


@noindent -- PERPENDICULAR ---

`splot` に関して回転ベクトルの設定が、ベクトルを表現する 3 つの数字の組
を指定することで実装されていて、このベクトルは 2 次元の xy 平面に対して
向き付けられた法線ベクトル (perpendicular) を表しています。もちろんその
デフォルトは (0,0,1) です。rotate と perpendicular の両方を指定すること
により、3 次元空間内で無数の方向へデータを向き付けられることになります。

まず最初に 2 次元の回転が行なわれ、その次に 3 次元の回転が行なわれます。
つまり、R' をある角による 2 x 2 の回転行列とし、P を (0,0,1) を
(xp,yp,zp) へ子午線方向に回転させる 3 x 3 の行列とし、R' を左上の部分行
列として持ち 3,3 成分が 1 でその他の成分が 0 であるような行列 (つまり
z 軸周りの回転行列) とすれば、この変換を表す行列による関係式はv' = P R
v となります。ここで、v はデータファイルから読み込まれた3 x 1 の位置ベ
クトルです。ファイルのデータが 3 次元的なものでない場合は、論理的なルー
ルが適用されて 3 次元空間内のデータと見なされます (例えば、通常は z 座
標は 0 とされ、xy 平面内の 2 次元データと見なされます)。



File: gnuplot.info, Node: データ_(data), Next: errorbars, Prev: binary, Up: plot

データ (data)
-------------






ファイルに納められた離散的なデータは、*Note plot:: コマンドライン上で、
そのデータファイル名 (<datafile>) を単一引用符または二重引用符で囲んで
指定することによって表示できます。

書式:
           plot '<file_name>' {binary <binary list>}
                              {{nonuniform} matrix}
                              {index <index list> | index "<name>"}
                              {every <every list>}
                              {thru <thru expression>}
                              {using <using list>}
                              {smooth <option>}
                              {volatile} {noautoscale}


修正子の *Note binary::, *Note index::, *Note every::, *Note thru::,
*Note using::, *Note smooth:: は、それぞれに分けて説明します。簡単に言
うと、*Note binary:: はデータ列をバイナリファイルから取得できるようにし
(デフォルトは ASCII ファイル)、*Note index::はマルチデータ集合ファイル
からどのデータ集合を表示するのかを選び、*Note every:: が、一つのデータ
集合からどの点を表示するのかを選び、*Note using:: は一行からどの列を解
釈するのかを決定し (*Note thru:: は、*Note using:: の特別な場合である)、
そして *Note smooth:: が、単純な補間と近似を行います。(`splot` は、よく
似た書式を持っていますが、*Note smooth:: オプションと *Note thru:: オプ
ションはサポートしていません)

キーワード `noautoscale` は、自動的に軸の範囲が決定される機能が有効であ
る場合に、この描画を構成するデータ点については、それを無視させる (自動
縮尺機能の計算対象から外す) ようにします。

ASCII データファイル:

データファイルは、一行につき少なくとも一つのデータ点を含む必要がありま
す (*Note using:: は一行から一つのデータポイントを選ぶことができます)。
`#` (VMS では `!`) で始まる行は、コメントとして扱われ、無視されます。各
データ点は、(x,y) の組を表します。エラーバー、または折れ線表示付エラー
バーの *Note plot:: では (以下参照: *Note errorbars::, *Note
errorlines::)、各データ点は、(x,y,ydelta), (x,y,ylow,yhigh),
(x,y,xdelta), (x,y,xlow,xhigh), (x,y,xlow,xhigh,ylow,yhigh) のいずれか
を意味します。

どんな場合でも、書式の指定子が *Note using:: オプションによって与えられ
ていなければ、データファイルの各行の数字は、ホワイトスペース (一つまた
は複数の空白かタブ) によって区切られている必要があります。このホワイト
スペースは、各行を列の項目に区切ります。ただし、二重引用符で囲まれたホ
ワイトスペースは列の勘定では無視され、よって次のようなデータ行は 3 列、
と見なされます:
           1.0 "second column" 3.0


データは、指数部に e, E の文字をつけた指数表記で書かれていても構いませ
ん。コマンド `set datafile fortran` が有効な場合は、fortran の指数指定
子 d, D, q, Q も使えます。

必要であるのはただ一つの列 (y の値) のみです。もし x の値が省略されたら、
`gnuplot` はそれを 0 で始まる整数値として用意します。

データファイルにおいて、ブランク行 (空白と改行、復帰以外に文字を含まな
い行) は重要です。

1 行のブランク行は、*Note plot:: に不連続を指示します; ブランク行によっ
て区切られた点は線で結ばれることはありません (line style で書かれている
場合には)。

2 行のブランク行は、別々のデータ集合間の区切りを示します。以下参照:
*Note index::。

もし autoscale の状態であれば (以下参照: *Note autoscale::)、軸は全ての
データポイントを含むように自動的に引き伸ばされて、目盛りが書かれる状態
ならば全ての目盛りがマークされます。これは、2 つの結果を引き起こします:
i) `splot` では、曲面の角は底面の角に一致していないことがあります。この
場合、縦の線は書かれることはありません。ii) 2 種類の軸での、同じ xの範
囲のデータの表示の際、もし x2 の軸に対する目盛りが書かれていない場合は、
x 座標があっていないことがあります。これは x 軸 (x1) は全ての目盛りにま
で自動的に引き延ばされるのに対し、x2 軸はそうではないからです。次の例で
その問題を見ることができます:

           reset; plot '-', '-' axes x2y1
           1 1
           19 19
           e
           1 1
           19 19
           e


これを避けるには、*Note autoscale:: コマンドの `fixmin`/`fixmax` オプショ
ンを使うことができます。これは、次の目盛りの刻みに合うように軸の範囲を
自動的に拡張する機能を無効にします。

ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
照: *Note labels::)。


* Menu:

* every::
* データファイルの例_(example)::
* index::
* smooth::
* 特別なファイル名_(special-filenames)::
* thru::
* using::
* volatile::



File: gnuplot.info, Node: every, Next: データファイルの例_(example), Prev: データ_(data), Up: データ_(data)

every
.....


キーワード *Note every:: は、描画するデータをデータ集合から周期的にサン
プリングすることを可能にします。

ここでは 「ポイント」はファイル中の 1 つの行によって定義されるデータと
し、ここでの「ブロック」は「データ・ブロック」(以下参照: `glossary`)と
同じものを意味することとします。

書式:
              plot 'file' every {<ポイント増分>}
                                {:{<ブロック増分>}
                                  {:{<開始ポイント>}
                                    {:{<開始ブロック>}
                                      {:{<終了ポイント>}
                                        {:<終了ブロック>}}}}}


描画するデータポイントは、<開始ポイント> から <終了ポイント> まで <ポイ
ント増分> の増加で選び、ブロックは <開始ブロック> から <終了ブロック>ま
で <ブロック増分> の増加で選びます。

各ブロックの最初のデータは、ファイル中の最初のブロックと同じように、
「0 番」と数えます。

プロットできない情報を含む行もカウントすることに注意して下さい。

いくつかの数字は省略できます; 増分のデフォルトは 1 、開始の値は最初のポ
イントか最初のブロック、そして終了の値は最後のポイントか最後のブロック
に設定します。*Note every:: のオプションが ':' で終わるのは許されていま
せん。*Note every:: を指定しなければ、全ての行の全てのポイントをプロッ
トします。

例:
            every :::3::3   # 4 番目のブロックだけ選びます (0 番が最初)
            every :::::9    # 最初の 10 ブロックを選びます
            every 2:2       # 1 つおきのブロックで 1 つおきのポイントを選び
                            # ます
            every ::5::15   # それぞれのブロックでポイント 5 から 15 までを
                            # 選びます


参照:単純な plot デモ (simple.dem)
(http://www.gnuplot.info/demo/simple.html) ,非パラメータモードでの
splot デモ (http://www.gnuplot.info/demo/surface1.html) ,パラメータモー
ドでの splot デモ (http://www.gnuplot.info/demo/surface2.html)。



File: gnuplot.info, Node: データファイルの例_(example), Next: index, Prev: every, Up: データ_(data)

データファイルの例 (example)
............................


次の例は、ファイル "population.dat" 中のデータと理論曲線を図にするもの
です。

           pop(x) = 103*exp((1965-x)/10)
           set xrange [1960:1990]
           plot 'population.dat', pop(x)


ファイル "population.dat" は次のようなファイルです。

           # Gnu population in Antarctica since 1965
              1965   103
              1970   55
              1975   34
              1980   24
              1985   10



binary の例:

           # 2 つの float の値を選択し (2 つ目の値は無意味)、一方を読み捨て、
           # 一つおきの float 値を無限に長く続く 1 次元データとして使用
           plot '<file_name>' binary format="%float%*float" using 1:2 with lines


           # データファイルから座標を生成するのに必要な情報をすべてそのヘッ
           # ダに含んでいる EDF ファイルの場合
           plot '<file_name>' binary filetype=edf with image
           plot '<file_name>.edf' binary filetype=auto with image


           # 3 つの符号なし文字型整数値 (unsigned char) を生の RGB 画像の色
           # 成分として選択し、y 方向は反転させ画像の方向を座標平面上で変更
           # する (左上が原点になるように)。ピクセルの間隔も指定し、ファイ
           # ルには 2 つの画像が含まれていて、そのうち一つは origin で平行
           # 移動する。
           plot '<file_name>' binary array=(512,1024):(1024,512) format='%uchar' \
                dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage


           # 4 つの別のデータからなり、座標情報もデータファイルに含まれてい
           # る。ファイルは gnuplot が実行されているシステムとは異なるエン
           # ディアンで生成されている。
           splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3


           # 同じ入力ファイルで、今回は 1 番目と 3 番目のレコードをスキップ
           splot '<file_name>' binary record=30:26 skip=360:348 endian=swap u 1:2:3



以下参照: *Note matrix::。



File: gnuplot.info, Node: index, Next: smooth, Prev: データファイルの例_(example), Up: データ_(data)

index
.....


キーワード *Note index:: は、描画用に複数のデータ集合を持つファイルから、
特定のデータ集合を選択することを可能にします。

書式:
           plot 'file' index { <m>{:<n>{:<p>}} | "<name>" }


データ集合は 2 行の空白で分離されています。`index <m>` は <m> 番目の集
合だけを選択します; `index <m>:<n>` は <m> から <n> までのデータ集合の
選択; `index <m>:<n>:<p>` は、<m>, <m>+<p>, <m>+2<p>, など、<p> おきの
集合を選択し、集合 <n> で終了します。C 言語の添字 (index) の付け方に従
い、index 0 はそのファイルの最初のデータ集合を意味します。大きすぎる
index の指定にはエラーメッセージが返されます。<p> を指定し、<n> を空欄
にした場合、<p> 毎のデータをファイルの最後まで読み込みます。*Note
index:: を指定しない場合は、ファイルのデータ全体を単一のデータ集合とし
て描画します。

例:
           plot 'file' index 4:5


ファイルの各点に対して、それが含まれるデータ集合の index 値は、疑似列
`column(-2)` で利用できます。これは、以下に見るように、そのファイル内の
個々のデータ集合を区別する別の方法を提供します。これは、描画用に 1つの
データ集合の選択しかしない場合は *Note index:: コマンドよりも不恰好です
が、個々のデータ集合に異なる属性を割り当てたい場合にはとても便利です。
以下参照: `pseudocolumns`, `lc variable`。

例:
           plot 'file' using 1:(column(-2)==4 ? $2 : NaN)        # とても不恰好
           plot 'file' using 1:2:(column(-2)) linecolor variable # とても便利 !


`index '<name>'` は、データ集合を名前 '<name>' で選択します。名前はコメ
ント行に書いてデータ集合に割り当てます。コメント文字とそれに続く空白を
そのコメント行から取り除いて、その結果が <name> から始まっていれば、そ
れに続くデータ集合に <name> という名前がつけられて、それを指定できます。

例:
           plot 'file' index 'Population'


<name> で始まるすべてのコメントがそれに続くデータ集合の名前になることに
注意してください。問題を避けるために、例えば '== Popolation =='
や'[Population]' などの命名法を選択すると便利でしょう。

index を使った splot のデモ
(http://www.gnuplot.info/demo/multimsh.html)</p>



File: gnuplot.info, Node: smooth, Next: 特別なファイル名_(special-filenames), Prev: index, Up: データ_(data)

smooth
......


`gnuplot` は、データの補間と近似を行う汎用的なルーチンをいくつか持って
います。これ *Note smooth:: オプションの中にグループ化されています。よ
り洗練されたデータ処理をしたければ、外部においてデータの前処理をするか、
または適切なモデルで fit を使うのがいいでしょう。

書式:
           smooth {unique | frequency | cumulative | cnormal | kdensity | unwrap
                          | csplines | acsplines | mcsplines | bezier | sbezier}


`unique`, `frequency`, `cumulative`, `cnormal` は、データを単調に揃えた
後でそれらを plot します。`unwrap` は、連続する点の y の値がπより大きな
ジャンプをしないような操作をします。他のルーチンはいずれも、データの両
端の点の間を結ぶ、ある連続曲線の係数を決定するためにデータを使います。
この曲線は、関数として同じ方法で描画されます。すなわち、それらの値は x
座標に沿う同じ幅の区間ごとに選ばれ (以下参照: *Note samples::)、それら
の点を線分でつなぐことにより (もし line style が選ばれているのならば)
描画されます。

もし *Note autoscale:: の状態であれば、描画範囲はグラフの境界線の中に曲
線が収まるように計算されます。

もし *Note autoscale:: の状態でなく、smooth のオプションが `acsplines`
か`csplines` であれば、生成する曲線の標本化は、入力データを含むような
xの範囲と、*Note xrange:: などで定義される固定された横座標の範囲の共通
部分の上で行なわれます。

選択されたオプションを適用するのにデータの点数が少なすぎる場合は、エラー
メッセージが表示されます。その最小のデータ数は `unique` と`frequency`
では 1 つ、`acsplines` では 4 つ、他のオプションでは 3 つです。

*Note smooth:: オプションは、関数の描画のときには無視されます。


@noindent -- ACSPLINES ---


`acsplines` オプションは「自然な滑らかなスプライン」でデータを近似しま
す。データが x に関して単調にされた後 (以下参照: `smooth unique`)、1つ
の曲線が、いくつかの 3 次多項式の一部分により区分的に構成されます。それ
らの 3 次式の係数は、いくつかのデータポイントの重み付けによって求められ
ます。重みは、データファイルの 3 列目に与えます。そのデフォルトの値は、
*Note using:: の 3 番目の項目によって変更することができます。例えば次の
ようにします。
           plot 'data-file' using 1:2:(1.0) smooth acsplines


性質上、重みの絶対的な大きさは、曲線を構成するのに使われる区分の数を決
定します。もし重みが大きければ、個々のデータの影響は大きくなり、そして
その曲線は、隣り合う点同志を自然 3 次スプラインでつないで得られるものに
近づきます。もし重みが小さければ、その曲線はより少ない区分で構成され、
それによってより平滑的になります。その最も極端な場合はただ 1 つの区分か
らなる場合であり、それは全てのデータに重みの付き線形最小 2 乗近似によっ
て作られます。誤差の立場から言えば、平滑さの重みは、その曲線に対する
「平滑化因子」によって分割された各点への、統計的な重みと見ることができ
ます。それにより、そのファイル中の (標準的な) 誤差は平滑さの重みとして
使うことができます。

例:
           sw(x,S)=1/(x*x*S)
           plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines



@noindent -- BEZIER ---


`bezier` オプションは、n 次 (データ点の個数) のベジェ曲線でデータを近似
します。この曲線は両端の点をつなぎます。


@noindent -- CSPLINES ---


`csplines` オプションはデータを単調に揃えた後で (以下参照: `smooth
unique`) 自然 3 次スプライン曲線で引き続く点をつなぎます。


@noindent -- MCSPLINES ---


`mcsplines` オプションは、平滑化された関数が元の点の単調性と凸性を保存
するような 3 次スプライン曲線で引き続く点をつなぎます。FN Fritsch & RE
Carlson (1980) "Monotone Piecewise Cubic Interpolation", SIAM Journal
on Numerical Analysis 17: 238-246.


@noindent -- SBEZIER ---


`sbezier` オプションは、最初にデータを単調に揃え (以下参照: `unique`)そ
して `bezier` アルゴリズムを適用します。


@noindent -- UNIQUE ---


`unique` オプションは、データを x 方向に単調にします。同じ x を持つデー
タ点は y の値を平均して一つの点で置き換えます。そしてその結果として得ら
れる点を線分で結びます。


@noindent -- UNWRAP ---


`unwrap` オプションは、2 つの続く点がπを越える違いが出ないようにデータ
を修正します: y の値がその範囲を越えるような点に対しては、前の点との差
がπの範囲に収まるように 2πの整数倍を加えます。この操作は、巻き戻しを持
つ系の値を時間的に連続にさせるのに有用です。


@noindent -- FREQUENCY ---


オプション `frequency` は、データを x に関して単調にします。x 座標が同
じ点は、それらの y の値の合計を y の値として持つ一つの点に置き換えられ
ます。結果としてそれらの点は真っすぐな線分で結ばれることになります。以
下も参照。smooth.dem (http://www.gnuplot.info/demo/smooth.html)


@noindent -- CUMULATIVE ---


オプション `cumulative` は、データを x に関して単調にします。x 座標が同
じ点は、それ以下の x の値を持つすべての点 (すなわち現在のデータ点の左側
の点) に対する y の値の累積的な合計を y の値として持つ一つの点に置き換
えられます。これは、データから累積分布関数を得るのに利用できます。以下
も参照。smooth.dem (http://www.gnuplot.info/demo/smooth.html)


@noindent -- CNORMAL ---


オプション `cnormal` は、x に関して単調で、y の値は [0:1] に正規化され
たデータを生成します。同じ x の値を持つ点が複数ある場合は、それより小さ
い x の値を持つすべてのデータ点 (すなわち現在のデータ点よりも左にある点)
の累積和を、すべての y の値の和で割った値を y の値として持つような一点
のデータに置き変えられます。これは、データから正規化された累積分布関数
を得るのに使えます (特に標本点数の異なるデータ集合を比較するのに有用で
す)。以下も参照。smooth.dem (http://www.gnuplot.info/demo/smooth.html)



@noindent -- KDENSITY ---


オプション `kdensity` は、ガウス核を用いた、ランダム選択点の核密度評価
(それは滑らかなヒストグラムになります) を描画する方法の一つです。ガウス
核が第 1 列の各点の位置に置かれ、これらのガウス核すべての和が関数として
描画されます。2 列目の値は、ガウス核の重みとして使用されます。(正規化さ
れたヒストグラムを得るには、これを 1/(点の個数) とすべきです。) 3 列目
の値があれば、それはガウス核のバンド幅として使用されます。2 列しか指定
しない、あるいは 3 列目の値が 0 以下であれば、gnuplot は入力データが正
規分布である場合に最適となるようなバンド幅を計算します。(これは通常はと
ても保守的で、すなわち幅広いバンド幅です。)



File: gnuplot.info, Node: 特別なファイル名_(special-filenames), Next: thru, Prev: smooth, Up: データ_(data)

特別なファイル名 (special-filenames)
....................................


特別な意味を持つファイル名として、次のものがあります: ", '-', '+',
'++'

空のファイル名 " は、同じ plot コマンド上で、直前の入力ファイルを再び使
用することを gnuplot に指示します。よって、同じ入力ファイルの 2 つのデー
タ列を描画するには以下のようにします:

           plot 'filename' using 1:2, " using 1:3


'+' と '++' という特別なファイル名は、*Note using:: 指定の全体と描画ス
タイルにインライン関数を使えるようにするための仕組みです。通常、関数描
画はサンプル点毎に単一の y (または z) の値しか持てません。しかし疑似ファ
イル'+' はそれがあたかも実際の入力ファイルであるように、*Note using::
指定による1 列目の値を標本点として扱い、さらに追加の列の値を指定するこ
とも可能です。返される標本点の数は、*Note samples:: で制御できます。例:

           plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves


同様に、疑似ファイル '++' は、x 方向は *Note samples:: で制御される点の
数、y 方向は *Note isosamples:: で制御される点の数の、標準的な [x,y] 座
標の格子を生成する 2 列のデータを返します。媒介変数モードではサンプル点
は x と y に関してではなく、u と v に関して取られます。'++' の描画の前
に、xrange と yrange (または urange と vrange) を設定する必要があります。
例:

           splot '++' using 1:2:(sin($1)*sin($2)) with pm3d
           plot '++' using 1:2:(sin($1)*sin($2)) with image


`'-'` という特別なファイル名は、データがインラインであることを指示しま
す。すなわち、データをコマンドの後に続けて指定します。このときはデータ
のみがコマンドに続き得ます。よって、*Note plot:: コマンドに対するフィル
ター、タイトル、ラインスタイルといったオプションは、*Note plot:: のコマ
ンドラインの方に書かないといけません。これは、unix シェルスクリプトにお
ける << (ヒアドキュメント)、あるいは VMS DCL における $DECK と同様です。
そのデータは、それらがファイルから読み込まれたかのように、1 行につき1
つずつのデータ点が入力されます。そしてデータの終りは、1 列目の始めに文
字 "e" を置くことで指示します。*Note using:: オプションをこれらのデータ
に適用することは可能です。ある関数を通しデータをフィルターすることに使
うのは意味があるでしょうが、列を選ぶのに使うことは多分意味がないでしょ
う。

`'-'` は、データとコマンドを一緒に持つことが有用である場合のためにあり
ます。例えば、`gnuplot` があるフロントアプリケーションのサブプロセスと
して起動される場合などがこれにあたります。例として、デモンストレーショ
ンでこの機能を使うものがあるでしょう。*Note index:: や *Note every:: の
ような *Note plot:: のオプションが与えられていると、それらはあなたに使
われることのないデータを入力する事を強要します。次の例を見てください。

           plot '-' index 0, '-' index 1
           2
           4
           6



           10
           12
           14
           e
           2
           4
           6



           10
           12
           14
           e


これは、実際に動作しますが、

           plot '-' , '-'
           2
           4
           6
           e
           10
           12
           14
           e


とタイプする方が楽でしょう。

もし、*Note replot:: コマンドで `'-'` を使うなら、あなたは 1 度以上デー
タを入力する必要があるでしょう。以下参照: *Note replot::, *Note
refresh::。

空のファイル名 (") は、直前のファイル名が再び使われることを指示します。
これは、

           plot 'ある/とても/長い/ファイル名' using 1:2, " using 1:3, " using 1:4


のようなときに便利です。(もし同じ plot コマンド上で、`'-'` と `"` の両
方を使用すると、上の例にあるように、インラインデータの 2 つの集合を与え
る必要があります。)

popen 関数を持っているシステム上では、データファイルは、'<' で始まるファ
イル名によって、シェルコマンドからパイプ入力することができます。例えば

           pop(x) = 103*exp(-x/10)
           plot "< awk '{print $1-1965, $2}' population.dat", pop(x)


は、最初の人口の例と同じ情報を描画します。ただし、x 座標は 1965 年から
の経過年を表すようになります。この例を実行するときは、上のデータファイ
ルのコメント行をすべて削除しなければなりませんが、または上のコマンドの
最初の部分を次のように変えることもできます (コンマに続く部分):

           plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"


このアプローチは最も柔軟性がありますが、*Note using:: あるいは *Note
thru:: キーワードを用いた単純なフィルタリングで行うことも可能です。

fdopen() 関数を持つシステムでは、データを、ファイルかパイプに結びつけら
れた任意のファイルデスクリプタから読み込むことができます。`n` 番のファ
イルデスクリプタから読み込むには、`'<&n'` としてください。これにより、
1 回の POSIX shell からの呼び出しの中で、複数のデータファイルからのパイ
プ入力が容易に行えるようになります:

           $ gnuplot -p -e "plot '<&3', '<&4'" 3<data-3 4<data-4
           $ ./gnuplot 5< <(myprogram -with -options)
           gnuplot> plot '<&5'




File: gnuplot.info, Node: thru, Next: using, Prev: 特別なファイル名_(special-filenames), Up: データ_(data)

thru
....


*Note thru:: 関数は前のバージョンとの互換性のために用意されています。

書式:
           plot 'file' thru f(x)


これは次と同様です:

           plot 'file' using 1:(f($2))


後者の方がより複雑に見えますが、この方が柔軟性を持っています。さらに自
然な

           plot 'file' thru f(y)


も動作します (すなわち、y をダミー変数として使うことができます)。

*Note thru:: は `splot` と `fit` でも通りますが、何の効果も持ちません。



File: gnuplot.info, Node: using, Next: volatile, Prev: thru, Up: データ_(data)

using
.....


最もよく使われるデータファイルの修飾子は *Note using:: で、これは入力ファ
イルのどの行を描画するのかを指示します。

書式:
           plot 'file' using <entry> {:<entry> {:<entry> ...}} {'format'}


format を指定すると、それを C ライブラリ関数 'scanf' に適用してデータファ
イルの各行を読みます。そうでなければ、各行はホワイトスペース (スペース
やタブ) で区切られたデータの列 (フィールド) からなるとみなしますが以下
も参照: `datafile separator`。

各 <entry> は、入力ファイルの一つのフィールドを選択するための単なる列の
番号か、一つのデータ集合の最初の行の列のラベルに一致する文字列、カッコ
で囲まれた数式、xticlabels(2) のようにカッコで囲まない特別な関数、のい
ずれかです。

そのエントリがカッコで囲まれた数式の場合、N 列目の値を指定するのに関数
column(N) を使用できます。つまり、column(1) は読み込まれた最初の項目を
参照し、column(2) は次の項目、といった具合です。column(1), column(2),
... の略記として、特別な記号 $1, $2, ... を使用できます。関数
`valid(N)` で、N 番目の列が有効な数字であるかどうかテストできます。


入力ファイルの最初の行の各列に、データの値ではなくラベルを持っている場
合、このラベルを入力列の特定や plot タイトルに使用できます。関数
column() は、列番号以外にラベルで入力列を選択できます。例えば、データファ
イルが以下のような場合:
           Height    Weight    Age
           val1      val1      val1
           ...       ...       ...

以下の plot コマンドは同じ意味になります:
           plot 'datafile' using 3:1, " using 3:2
           plot 'datafile' using (column("Age")):(column(1)), \
                        " using (column("Age")):(column(2))
           plot 'datafile' using "Age":"Height", " using "Age":"Weight"


指定文字列が完全に一致する必要がありますし、大文字小文字も区別します。
列のラベルを plot タイトルに使うには、*Note columnhead::としてください。

入力データファイルの 1...N という実際の列に加えて、gnuplot は管理情報を
持ついくつかの "疑似列" を提供します。例えば、$0 または column(0) は、
データ集合内のそのデータ行の行番号を返します。以下参照:
`pseudocolumns`。

<entry> に何も書かなければ、そのエントリのリストの順にデフォルトの値が
使われます。例えば `using ::4` は、`using 1:2:4` と解釈されます。

*Note using:: にただ一つのエントリを指定した場合は、その <entry> は y
の値として使われ、データ点の番号 (疑似列 $0) が x として使われます。例
えば"`plot 'file' using 1`" は "`plot 'file' using 0:1`" と同じ意味です。
*Note using:: に 2 つのエントリを与えた場合、それらは x, y として使われ
ます。さらにエントリを追加して、入力からのデータを利用するような描画ス
タイルの詳細については、以下参照: *Note style::, `fit`。

'scanf' 関数では色々なデータ形式の数値入力が使えますが、`gnuplot` は全
ての入力データを倍精度浮動小数とみなしますから、`gnuplot` では `%lf`が
本質的に唯一の数値入力指定、ということになります。書式文字列には、少な
くとも一つ、そして 7 つ以下の、そのような入力指定子を入れる必要がありま
す。'scanf' は数と数の間にホワイトスペース、すなわち空白、タブ ("\t")、
改行("\n")、または改ページ ("\f") があると期待します。それ以外の入力は
明示的にスキップされるべきです。

"\t", "\n", "\f" を使うときはシングルクォートよりむしろダブルクォートを
使うべきであることに注意してください。


@noindent -- USING の例 (USING_EXAMPLES) ---


次の例は、1 番目のデータに対する 2 番目と 3 番目の和の値を plot します。
書式文字列は、各列データがスペース区切りでなく、カンマ区切りであること
を指示していますが、同じことが `set datafile separator ","` を指定する
ことでも可能です。
           plot 'file' using 1:($2+$3) '%lf,%lf,%lf'


次の例は、より複雑な書式指定でデータをファイル "MyData" から読み込みま
す。
           plot 'MyData' using "%*lf%lf%*20[^\n]%lf"


この書式指定の意味は以下の通りです:

           %*lf        数値を無視
           %lf         倍精度浮動小数を読み込む (デフォルトでは x の値)
           %*20[^\n]   20 個の改行以外の文字を無視
           %lf         倍精度浮動小数を読み込む (デフォルトでは y の値)


3 項演算子 `?:` を使ってデータをフィルタする一つの芸当を紹介します。

           plot 'file' using 1:($3>10 ? $2 : 1/0)


これは、1 列目のデータに対して、3 列目のデータが 10 以上であるような2
列目のデータを plot します。`1/0` は未定義値であり、`gnuplot` は未定義
の点を無視するので、よって適切でない点は隠されることになります。または、
あらかじめ定義されている値 NaN を使っても同じことになります。


カッコで始まっていない限りは定数式を列番号として使うことができます。例
えば `using 0+(複雑な式)` の様なことができます。そして、その数式は、カッ
コでスタートしていなければ数式の値が一度評価され、カッコでスタートして
いれば個々のデータ点を読み込むためにその値が一度評価される、という点が
重要です。

時系列フォーマットデータを使っている場合、その時間のデータは複数の列に
渡らせることができます。その場合、他のデータの開始位置を計算するとき、
時間のデータに空白が含まれていることに注意してください。例えば、データ
行の最初の要素がスペースが埋め込まれた時間データであるならば、y の値は
3 列目の値として指定されるべきです。

`plot 'file'` と `plot 'file' using 1:2`、そして`plot 'file' using
($1):($2)` には微妙な違いがあることに注意してください。1) `file` が 1
列と 2 列のデータを持つ行をそれぞれ含んでいるとすると、データが 1 列の
みの行に対しては、最初のものは x の値を作り出し、2番目のものはその行は
無視し、3 番目のものはそれを未定義の値として保存します (折れ線で plot
している場合 (plot with lines)、その未定義の点を通過する線を結ばないよ
うに)。2) 1 列目に文字列を含んでいるような行がある場合、最初のものはエ
ラーとして plot を中止しますが、2 番目と 3 番目のものはその不要な行を読
みとばします。

実際、最初に単に

           plot 'file' using 1:2


と指定することで、大抵の場合どんなにゴミのデータを含む行を持つファイル
をも plot することが可能になります。しかし、どうしてもデータファイルに
文字列を残しておきたいならば、そのテキスト行の第一列にコメント文字 (#)
を置く方がより安全でしょう。


@noindent -- 疑似列 (PSEUDOCOLUMNS) ---


plot 文の *Note using:: 項目内の式では、入力ファイルに含まれる実際のデー
タ値に加えて管理情報も参照でき、これらは "疑似列" (pseudocolumns) に含
まれています。
           column(0)   データ集合内での各点の順番。順番は 0 から始まり、2
                       行のブランク行でリセットされます。略記 $0 も使用可。
           column(-1)  この番号は 0 から始まり、1 行のブランク行でリセット
                       されます。これは、行列、または格子状データ内のデータ
                       行に対応します。
           column(-2)  複数のデータ集合を持つファイル内の、現在のデータ集合
                       の index 番号。以下参照: *Note index::。



@noindent -- XTICLABELS ---


軸の刻みの見出し (ticlabel) は文字列関数によって作ることもでき、それは
通常は引数としてデータ列から取得します。最も単純な形式は、データ列自身
の文字列としての利用で、xticlabels(N) は xticlabels(stringcolumn(N))の
省略形として使えます。以下の例は 3 列目の要素を x 軸の刻みの見出しとし
て使用します。

           plot 'datafile' using <xcol>:<ycol>:xticlabels(3) with <plotstyle>


軸の目盛りの見出しは、任意の描画軸 x,x2,y,y2,z 用に生成できます。
`ticlabels(<labelcol>)` 指定は、*Note using:: 指定の中で、そのデータの
座標指定が全て済んだ後に行う必要があります。有効な X,Y[,Z] 座標の組を持
つ各データ点に対して、xticlabels() に与える文字列値は、それに対応する点
のx 座標と同じ場所の x 軸の見出しのリストに追加されます。
`xticlabels()`は `xtic()` と省略することもでき、他の軸に関しても同様で
す。

例:

           splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)


この例では、x 軸、y 軸の見出しは x,y 座標値とは別の列から取り出されます
が、z 軸の見出しは、対応する点の z 座標値から生成されます。

例:

           plot "data" using 1:2:xtic( $3 > 10. ? "A" : "B" )


この例は、x 軸の見出しの生成に文字列値関数を使用したもので、データファ
イルの各点の x 軸の刻みの見出しは、3 列目の値によって "A" か "B" かのい
ずれかとなります。


@noindent -- X2TICLABELS ---

以下参照: `plot using xticlabels`。


@noindent -- YTICLABELS ---

以下参照: `plot using xticlabels`。


@noindent -- Y2TICLABELS ---

以下参照: `plot using xticlabels`。


@noindent -- ZTICLABELS ---

以下参照: `plot using xticlabels`。



File: gnuplot.info, Node: volatile, Prev: using, Up: データ_(data)

volatile
........


plot コマンドのキーワード *Note volatile:: は、入力ストリームかファイル
から以前に読み込んだデータが、再読み込み時には有効ではないことを意味し
ます。これは、*Note replot:: コマンドの代わりに、可能な限り *Note
refresh:: コマンドを使うよう gnuplot に指示します。以下参照: *Note
refresh::。



File: gnuplot.info, Node: errorbars, Next: errorlines, Prev: データ_(data), Up: plot

errorbars
---------


エラーバーは、1 から 4 個の追加されたデータを読む (またはエントリを
*Note using:: で追加選択する) ことにより、2 次元データの描画において実
現されています。これら追加される値は、それぞれのエラーバースタイルで異
なった形で使われます。

デフォルトでは、`gnuplot` はデータファイルの各行に以下のような 3 つ、4
つ、あるいは 6 つの列があることを期待しています:

           (x, y, ydelta),
           (x, y, ylow, yhigh),
           (x, y, xdelta),
           (x, y, xlow, xhigh),
           (x, y, xdelta, ydelta),
           (x, y, xlow, xhigh, ylow, yhigh)


x 座標は必ず指定しなければいけません。各数値を書く順序も上で挙げた通り
でなくてはなりません。ただ、*Note using:: 修飾子を使えばその順序を操作
できますし、欠けている列の値も補うことは可能ですが。例えば、

           plot 'file' with errorbars
           plot 'file' using 1:2:(sqrt($1)) with xerrorbars
           plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars


最後の例は、相対的な x の誤差と絶対的な y の誤差、という、サポートされ
ていない組のファイルに対するものです。*Note using:: エントリが相対的な
x の誤差から絶対的な x の最小値と最大値を生成しています。

y のエラーバーは、(x, ylow) から (x, yhigh) への鉛直な線として描かれま
す。ylow と yhigh の代わりに ydelta が指定されたときは、ylow = y -
ydelta, yhigh = y + ydelta となります。ある行にデータが 2 つしかなけれ
ば、ylow とyhight はともに y となります。x エラーバーは同様に計算された
水平線です。データの各点を結ぶ折れ線を引きたい場合は、with errorbars と
with lines を指定して、同じデータファイルを 2 回 *Note plot:: して下さ
い (ただし、キーの中に2 つのエントリを作らないように、その一方には
`notitle` オプションを使うことを忘れないで下さい)。他の選択肢として、
errorlines コマンドもあります(以下参照: *Note errorlines::)。

エラーバーには、もし *Note bars:: を使っていなければ、そのそれぞれの端
に垂直な線分がつきます (詳細は、以下参照: *Note bars::)。

自動範囲指定が有効であれば、その描画範囲はエラーバーも含むように調整さ
れます。

以下も参照エラーバーのデモ (http://www.gnuplot.info/demo/mgr.html)

更なる情報に関しては、以下参照: *Note using::, *Note with::, *Note
style::。



File: gnuplot.info, Node: errorlines, Next: 関数描画_(functions), Prev: errorbars, Up: plot

errorlines
----------


誤差線 (errorbar) を伴う線描画は、2 次元データファイルの描画でサポート
されていて、それは 1 個から 4 個の追加の (または *Note using:: で指定す
る)列データを与えることで行なわれます。これらの追加される値は、様々な
errorline スタイルのそれぞれで異なった形で使われます。

デフォルトの状態では、`gnuplot` は、データファイルの各行に 3 個、4 個、
6 個のいずれかの個数のデータがあることを期待し、それぞれ以下のいずれか
に対応します。

           (x, y, ydelta),
           (x, y, ylow, yhigh),
           (x, y, xdelta),
           (x, y, xlow, xhigh),
           (x, y, xdelta, ydelta),
           (x, y, xlow, xhigh, ylow, yhigh)


x 座標は指定する必要がありますし、データの順番も上の形式である必要があ
りますが、*Note using:: 修飾子でその順番を操作したり、欠けている列に対
する値を与えたりすることができます。例えば

           plot 'file' with errorlines
           plot 'file' using 1:2:(sqrt($1)) with xerrorlines
           plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines


最後の例は、相対的な x の誤差と絶対的な y の誤差、というサポートされて
いない組合せのデータのファイルに対するもので、*Note using:: で相対的な
誤差から絶対的な x の最小値と最大値を生成しています。

y 誤差線は (x, ylow) から (x, yhigh) へ描画される縦線です。ylow, yhigh
代わりに ydelta が指定された場合は、ylow = y - ydelta, yhigh = y +
ydeltaと扱われます。ある行に 2 つのデータしかない場合、yhigh, ylow は両
方とも y になります。x 誤差線は同様の方法で計算される水平線です。

誤差線には、*Note bars:: が指定されていない場合、その両端で垂直に交わる
線分が付きます (詳細は、以下参照: *Note bars::)。

自動縮尺 (autoscaling) が ON の場合、描画範囲は誤差線が入るように調整さ
れます。

更なる情報については、以下参照: *Note using::, *Note with::, *Note
style::。



File: gnuplot.info, Node: 関数描画_(functions), Next: 媒介変数モード描画_(parametric), Prev: errorlines, Up: plot

関数描画 (functions)
--------------------



コマンド *Note plot::, `splot` では、ファイルから読み込んだデータの描画
だけでなく、組み込み関数やユーザ定義関数を描画することもできます。関数
の値は、独立な軸の通常の範囲に渡ってデータサンプルを取ることで評価しま
す。以下参照: *Note samples::, *Note isosamples::。

例:
           approx(ang) = ang - ang**3 / (3*2)
           plot sin(x) title "sin(x)", approx(x) title "approximation"


関数のデフォルトの描画スタイルを設定する方法については、以下参照: `set
style function`。組み込み関数の情報については、以下参照: *Note
functions::。自前で関数を定義する方法については、以下参照:
`user-defined`。



File: gnuplot.info, Node: 媒介変数モード描画_(parametric), Next: 範囲_(ranges), Prev: 関数描画_(functions), Up: plot

媒介変数モード描画 (parametric)
-------------------------------

媒介変数モード (*Note parametric::) では、*Note plot:: では 2 つの数式
の組を、`splot` では 3 つの数式の組を与える必要があります。

例:
           plot sin(t),t**2
           splot cos(u)*cos(v),cos(u)*sin(v),sin(u)


データファイルは前と同じように描画されます。ただし、データファイルが描
画のために与えられる前に、任意の媒介変数関数が先に完全に指定された場合
を除いてです。言い換えると、x の媒介変数関数 (上の例では `sin(t)`)と y
の媒介変数関数 (上の例では `t**2`) との間に、他の修飾子やデータ関数をは
さみこんではいけません。そのようなことをすると、構文エラーになり、媒介
変数関数が完全には指定されていない、と表示されます。

*Note with:: や *Note title:: のような他の修飾子は、媒介変数関数の指定
が完了した後に指定しなければいけません。

           plot sin(t),t**2 title 'Parametric example' with linespoints


以下も参照媒介変数モードのデモ。
(http://www.gnuplot.info/demo/param.html)



File: gnuplot.info, Node: 範囲_(ranges), Next: 繰り返し_(iteration)_, Prev: 媒介変数モード描画_(parametric), Up: plot

範囲 (ranges)
-------------


plot コマンドの最初に置くオプションの軸の範囲 (range) は、表示するグラ
フの範囲を指定します。その範囲は、それ以前のどの `set range` による範囲
指定よりも優先して扱います。

書式:
           [{<dummy-var>=}{{<min>}:{<max>}}]
           [{{<min>}:{<max>}}]


最初の範囲指定は独立変数の範囲 (*Note xrange:: またはパラメトリックモー
ドでは *Note trange::) で、2 番目のものは従属変数の範囲 *Note yrange::
(パラメトリックモードでは *Note xrange::) となります。<dummy-var> には
独立変数の新しい別名を指定します (デフォルトの変数名は *Note dummy:: で
変更できます)。<min>, <max> には定数式、あるいは * を書くことができます。

パラメトリックモードでなければ、与えられるべき範囲指定は *Note xrange::,
*Note yrange:: の順になります。

パラメトリックモードでは、*Note plot:: コマンドに対してはその順序は
*Note trange::, *Note xrange::, *Note yrange:: になります。以下の
*Note plot:: コマンドは、*Note trange:: を[-pi:pi], *Note xrange:: を
[-1.3:1.3], *Note yrange:: を [-1:1] に設定する例です。

           plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2


x2 の範囲と y2 の範囲はここでは指定できないことに注意してください。それ
には *Note x2range:: や *Note y2range:: が使われます。

範囲は適切なモードに対して、上に示した順序で解釈されます。必要な範囲指
定が一度全て指定されると、再び指定し直すことはありませんが、必要ない部
分を全く指定しないようにはできません。その代わり、そこに空の範囲指定
`[]` を置きます。

`*` は、min (最小値) や max (最大値) に自動範囲指定 (autoscale) の機能
を使うことを可能にします。以下も参照: *Note autoscale::。

*Note plot:: や `splot` のコマンド行で指定された範囲はそのグラフにのみ影響を
及ぼします。よって、その後のグラフのデフォルトの範囲を変更するには、
*Note xrange:: や *Note yrange:: を使用してください。

時間データに対しては、範囲はクォートで囲んで指定する必要があります (デ
ータファイルに現われる時間データと同じ形式の)。`gnuplot` はその範囲を
読みこむのに時間書式文字列 (*Note timefmt::) を使用します。詳しくは以下参照:
*Note timefmt::。

例:

以下は現在の範囲を使用します:
           plot cos(x)


以下は x の範囲のみの指定です:
           plot [-10:30] sin(pi*x)/(pi*x)


以下は上と同じですが、仮変数として t を使います:
           plot [t = -10 :30]  sin(pi*t)/(pi*t)


以下は x と y の両方の範囲の指定です:
           plot [-pi:pi] [-3:3]  tan(x), 1/x


以下は、y の範囲のみの指定で、両方の軸の自動範囲指定機能を無効にします:
           plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)


以下は x の最大値と y の最小値のみの指定です。
           plot [:200] [-pi:]  exp(sin(x))


以下は x の範囲を時系列データとして指定しています:
           set timefmt "%d/%m/%y %H:%M"
           plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'





File: gnuplot.info, Node: 繰り返し_(iteration)_, Next: title, Prev: 範囲_(ranges), Up: plot

繰り返し (iteration)
--------------------


多くの同等のファイルや関数を同時に描画する場合は、それぞれの plot コマ
ンドの繰り返し (iteration) でそれを行うのが便利です。

書式:
           plot for [<variable> = <start> : <end> {:<increment>}]
           plot for [<variable> in "string of words"]


繰り返しの適用範囲 (scope) は、次のコンマ (,) かコマンドの終わり、のい
ずれか先に現れたところまでです。繰り返しは入れ子 (nest) にすることはで
きません。

繰り返し文がコンマまでなので、以下は一つの曲線 sin(3x) を描画します。
           plot for [i=1:3] j=i, sin(j*x)

j の後にコンマがないので、以下は 3 つの曲線を描画します。
           plot for [i=1:3] j=i sin(j*x)


例:
           plot for [dataset in "apples bananas"] dataset."dat" title dataset


この例では、繰り返しはファイル名と対応するタイトルの生成の両方で使われ
ています。

例:
           file(n) = sprintf("dataset_%d.dat",n)
           splot for [i=1:10] file(i) title sprintf("dataset %d",i)


この例は、ファイル名で生成される文字列値関数を定義し、そのような 10 個
のファイルを同時に描画します。繰り返しの変数 (この例では 'i') は一つの
整数として扱われ、それを 2 度以上使用できます。

例:
           set key left
           plot for [n=1:4] x**n sprintf("%d",n)


この例は、関数の組を描画します。

例:
           list = "apple banana cabbage daikon eggplant"
           item(n) = word(list,n)
           plot for [i=1:words(list)] item(i).".dat" title item(i)
           list = "new stuff"
           replot


この例では、リストに従って各ステップが進行し、その各項目に対して一つの
描画が行われます。この各項目は動的に取得されますので、そのリストを変更
し、そのまま replot することができます。

例:
           list = "apple banana cabbage daikon eggplant"
           plot for [i in list] i.".dat" title i
           list = "new stuff"
           replot


この例は、整数の繰り返し変数ではなく、文字列の繰り返し変数形式を用いて
いること以外は前の例と全く同じです。




File: gnuplot.info, Node: title, Next: with, Prev: 繰り返し_(iteration)_, Up: plot

title
-----


デフォルトでは各曲線は、対応する関数やファイル名でキーの中に一覧表示さ
れますが、plot のオプション *Note title:: を使うことで、明示的なタイト
ルを与えることもできます。

書式:
           title <text> | notitle [<ignored text>]
           title columnheader | title columnheader(N)


ここで <text> は、引用符で囲まれた文字列か、文字列と評価される式のいず
れかです。引用符はキーには表示されません。

入力データの列の最初の項目 (すなわち列の先頭) を文字列フィールドと解釈
し、それをキータイトルとして利用するオプションもあります。以下参照:
`datastrings`。これは、*Note columnhead:: を指定すればデフォルトの挙動
となります。

曲線タイトルとサンプルは予約語 `notitle` を使うことでキーから削除できま
す。何もないタイトル (`title "`) は `notitle` と同じ意味を持ちます。サ
ンプルだけが欲しいときは、一つ以上の空白をタイトルの後ろに入れてくださ
い (`tilte ' '`)。`notilte` の後ろに文字列をつけた場合、その文字列は無
視されます。

`key autotitles` が設定されて (デフォルト)、かつ *Note title:: も
`notitle`も指定されなかった場合、曲線のタイトルは *Note plot:: コマンド
上にある関数名かデータファイル名になります。ファイル名の場合は、指定さ
れる任意のデータファイル修飾子もそのデフォルトタイトルに含まれます。

位置やタイトルの位置揃えなどのキーのレイアウトは、`set key` で制御でき
ます。詳細は、以下参照: `set key`。

例:

以下は y=x をタイトル 'x' で表示します:
           plot x


以下は、x の 2 乗をタイトル "x^2" で、ファイル "data.1" をタイトル
measured data" で表示します:
           plot x**2 title "x^2", 'data.1' t "measured data"


以下は、極座標グラフの周りに円形の境界を書き、タイトルなしで表示します:
           set polar; plot my_function(t), 1 notitle


以下は、ファイルの各列にタイトルを含む複数列のデータを描画します:
           plot for [i=1:4] 'data' using i title columnhead





File: gnuplot.info, Node: with, Prev: title, Up: plot

with
----




関数やデータの表示にはたくさんのスタイルのうちの一つを使うことができま
す。キーワード *Note with:: がその選択のために用意されています。

書式:
           with <style> { {linestyle | ls <line_style>}
                          | {{linetype  | lt <line_type>}
                             {linewidth | lw <line_width>}
                             {linecolor | lc <colorspec>}
                             {pointtype | pt <point_type>}
                             {pointsize | ps <point_size>}
                             {fill | fs <fillstyle>}
                             {nohidden3d} {nocontours} {nosurface}
                             {palette}}
                        }



ここで、<style> は以下のいずれか:

          lines        dots       steps     errorbars     xerrorbar    xyerrorlines
          points       impulses   fsteps    errorlines    xerrorlines  yerrorbars
          linespoints  labels     histeps   financebars   xyerrorbars  yerrorlines
                                            vectors

または、
           boxes            candlesticks   image      circles
           boxerrorbars     filledcurves   rgbimage   ellipses
           boxxyerrorbars   histograms     rgbalpha   pm3d
           boxplot


最初のグループのスタイルは、線、点、文字の属性を持ち、第 2 のグループの
スタイルは、さらに塗り潰し属性も持っています。以下参照: `fillstyle`。さ
らにサブスタイルを持つスタイルもあります。個々のスタイルの詳細について
は、以下参照: `plotting styles`。

デフォルトのスタイルは、`set style function` と `set style data` で選択
できます。

デフォルトでは、それぞれの関数やデータファイルは、使うことができる型の
最大数に達するまで異なる線種、点種を使います。すべての端末用ドライバは
最低 6 つの異なる点種をサポートしていて、もしたくさん要求された場合、そ
れらを順に再利用していきます。使用中の出力形式での線種、点種の集合全体
を見たければ、*Note test:: としてください。

一つの描画で線種や点種を選びたいならば、<line_type> や <point_type> を
指定してください。これらの値は、その描画で使われる線種や点種を指定する
正の整定数 (または数式) です。使用する端末で使える線種、点種を表示する
には *Note test:: コマンドを使ってください。

描画の線の幅や点の大きさは <line_width> や <point_size> で変更できます。
これらはその各々の端末のデフォルトの値に対する相対的な値として指定しま
す。点の大きさは全体に通用するように変更できます。詳細は、以下参照:
*Note pointsize::。しかし、ここでセットされる <point_size> と、*Note
pointsize:: でセットされる大きさは、いずれもデフォルトのポイントサイズ
に掛けられることに注意してください。すなわち、それらの効果は累積はしま
せん。例えば、`set pointsize 2; plot x w p ps 3` は、デフォルトのサイズ
の 3 倍であって、6 倍ではありません。

ラインスタイルの一部分、あるいは各 plot において `pointsize variable`と
いう指定も可能です。この場合、入力には追加の 1 列が要求されます。例えば
2D 描画では 3 列、3D 描画では 4 列のデータが必要になります。個々の点の
サイズは、全体を通しての pointsize に、データファイルからの入力による値
をかけたものとして決定されます。

`set style line` を使って線種/線幅、点種/点幅の組を定義すれば、そのスタ
イルの番号を <line_style> にセットすることでそれらを使うことができます。

gnuplot が `pm3d` をサポートするようにインストールされているならば、
`splots` において lines, points, dots の色を滑らかに変化させるための特
別なキーワード *Note palette:: が使えます。その色は、コマンド *Note
palette::であらかじめ設定された滑らかに変化するカラーパレットから選択し
ます。色の値は、点の z 座標の値か、または *Note using:: で 4 番目のパラ
メータとして指定される色座標に対応します。2 次元、3 次元の描画 (*Note
plot:: と `splot`コマンド) の両方で、パレット色を小数値かまたはカラーボッ
クスの範囲へ対応づけられた値のいずれかで指定することができます。パレッ
ト色の値は、*Note using:: 指定で明示的に指定された入力列から読み込むこ
とも可能です。以下参照: `colors`, *Note palette::, `linetype`。

キーワード `nohidden3d` は、`splot` コマンドで生成される描画にのみ適用
されます。通常、グローバルなオプション *Note hidden3d:: はグラフ上の全
ての描画に適用されますが、各々の描画に `nohidden3d` オプションをつける
ことで、それを hidden3d の処理から除外することができます。
`nohidden3d`がマークされた曲面以外の個々の描画要素 (線分、点、ラベル等)
は、通常は他の何らかの描画要素で隠されてしまう場合も全て描画されます。

同様に、キーワード `nocontours` は、グローバルに `set contour` 指定が有
効な場合でも、個別の plot に対する等高線描画機能をオフにします。

同様に、キーワード `nosurface` は、グローバルに *Note surface:: 指定が
有効な場合でも、個別の plot に対する 3 次元曲面描画をオフにします。

キーワードは暗示するような形で省略可能です。

`linewidth`, *Note pointsize::, *Note palette:: オプションは全ての端末
装置でサポートされているわけではないことに注意してください。

例:

以下は、sin(x) を鉛直線で描画します:
           plot sin(x) with impulses


以下は、x を点で描画し、x**2 をデフォルトの方式で描画します:
           plot x w points, x**2


以下は、tan(x) を関数のデフォルトの方式で、"data.1" を折れ線で描画しま
す:
           plot [ ] [-2:5] tan(x), 'data.1' with l


以下は、"leastsq.dat" を鉛直線で描画します:
           plot 'leastsq.dat' w i


以下は、データファイル "population" を矩形で描画します:
           plot 'population' with boxes


以下は、"exper.dat" をエラーバー付きの折れ線で描画します (エラーバーは
3 列、あるいは 4 列のデータを必要とします):
           plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars


もう一つの "exper.dat" のエラーバー付きの折れ線 (errorlines) での描画方
法 (エラーバーは 3 列、あるいは 4 列のデータが必要):
           plot 'exper.dat' w errorlines


以下は、sin(x) と cos(x) をマーカー付きの折れ線で描画します。折れ線は同
じ線種ですが、マーカーは異なったものを使います:
           plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4


以下は、"data" を点種 3 で、点の大きさを通常の 2 倍で描画します:
           plot 'data' with points pointtype 3 pointsize 2


以下は、"data" を描画しますが、4 列目から読んだデータを pointsize の値
として使用します:
           plot 'data' using 1:2:4 with points pt 5 pointsize variable


以下は、2 つのデータ集合に対して、幅のみ異なる線を用いて描画します:
           plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1


以下は、x*x の曲線の内部の塗りつぶしと色の帯を描画します:
           plot x*x with filledcurve closed, 40 with filledcurve y1=10


以下は、x*x の曲線と色の箱を描画します:
           plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y1=10 lt 8


以下は、滑らかに変化する色の線で曲面を描画します:
           splot x*x-y*y with line palette


以下は、2 つの色のついた曲面を、異なる高さで表示します:
           splot x*x-y*y with pm3d, x*x+y*y with pm3d at t





File: gnuplot.info, Node: print, Next: pwd, Prev: plot, Up: コマンド_(Commands)

print
=====



*Note print:: コマンドは <式> の値を画面に表示します。これは `pause 0`
と同じです。<式> は、数を生成する `gnuplot` の数式か、または文字列です。

書式:
             print <式> {, <式>, ...}


以下参照: `expressions`。出力ファイルは *Note print:: で設定できます。



File: gnuplot.info, Node: pwd, Next: quit, Prev: print, Up: コマンド_(Commands)

pwd
===



*Note pwd:: コマンドはカレントディレクトリの名前を画面に表示します。

カレントディレクトリを文字列変数に保存したり、文字式の中で使いたい場合
は、変数 GPVAL_PWD を使うことができることに注意してください。以下参照:
`show variables all`。



File: gnuplot.info, Node: quit, Next: raise, Prev: pwd, Up: コマンド_(Commands)

quit
====



*Note exit:: と *Note quit:: の両コマンドと END-OF-FILE 文字は、
`gnuplot` を終了させます。これらのコマンドは、出力装置を (*Note
clear:: コマンドと同様に)クリアしてから終了させます。



File: gnuplot.info, Node: raise, Next: refresh, Prev: quit, Up: コマンド_(Commands)

raise
=====



書式:
           raise {plot_window_nb}


コマンド *Note raise:: (*Note lower:: の反対) は、`pm`, `win`, `wxt`,
`x11` 等のgnuplot の対話型出力形式の実行中に、描画ウィンドウを上 (前面)
に上げます。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z
方向のウィンドウの重なりの前 (上) に置きます。

`x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デフォ
ルトではこのコマンドはそれらの複数のウィンドウを降順に上げ、最初に作ら
れたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べます。
オプション引数の描画番号が与えられた場合、それに対応する描画ウィンドウ
が存在すればそれのみが上げられます。

オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
`win` では無視されます。

ウィンドウが X11 で前面に出ない場合、もしかすると描画ウィンドウは、異な
る X11 セッションで動作している (例えば telnet や ssh セッションなどに
よって) か、または前面に出すことがウィンドウマネージャの設定によって防
害されている可能性があります。



File: gnuplot.info, Node: refresh, Next: replot, Prev: raise, Up: コマンド_(Commands)

refresh
=======



コマンド *Note refresh:: は、*Note replot:: に似ていますが、主に 2 つの
点で違いがあります。*Note refresh:: は、既に読み込んだデータを用いて、
現在の描画を再整形し再描画します。これは、*Note refresh:: を (疑似デバ
イス '-' からの) インラインデータの描画、および内容が変化しうるデータファ
イルからの描画に使えるということを意味します。ただし、コマンド *Note
refresh:: は、既に存在する描画に新しいデータを追加するのには使えません。

マウス操作、特にズームインとズームアウトでは、適切な場合は *Note
replot:: の代わりにむしろ *Note refresh:: を使用します。例:

           plot 'datafile' volatile with lines, '-' with labels
           100 200 "Special point"
           e
           # 色んなマウス操作をここで実行
           set title "Zoomed in view"
           set term post
           set output 'zoom.ps'
           refresh





File: gnuplot.info, Node: replot, Next: reread, Prev: refresh, Up: コマンド_(Commands)

replot
======



*Note replot:: コマンドを引数なしで実行すると、最後に実行した *Note
plot:: または`splot` コマンドを再実行します。これは、あるプロットを異な
る `set` オプションでみたり、同じプロットを異なる装置に出力したりすると
きに便利でしょう。

*Note replot:: コマンドに対する引数は最後に実行した *Note plot:: または
`splot`コマンドの引数に (暗黙の ',' と共に) 追加され、それから再実行さ
れます。*Note replot:: は、範囲 (range) を除いては、*Note plot:: や
`splot` と同じ引数をとることができます。よって、直前のコマンドが
`splot` ではなく *Note plot::の場合は、関数をもう一つの軸刻でプロットす
るのに *Note replot:: を使うことができます。

注意:

           plot '-' ; ... ; replot


という使い方は推奨されません。それは、これがあなたに再び同じデータすべ
ての入力を要求することになるからです。たいていの場合、代わりにコマンド
*Note refresh:: を使えます。これは、以前に読み込んだデータを使ってグラ
フを再描画します。

*Note replot:: コマンドは *Note multiplot:: モードでは働きません。それ
は、それが画面全体にではなく直前のプロットのみを再実行するものだからで
す。

最後に実行した *Note plot:: (`splot`) コマンドの内容を修正する方法につ
いては以下も参照: `command-line-editing`。

直前の描画コマンドの全体を表示させることや、それを `history` の中にコピー
する方法については、以下も参照: *Note plot::。



File: gnuplot.info, Node: reread, Next: reset, Prev: replot, Up: コマンド_(Commands)

reread
======



*Note reread:: コマンドは、`load` コマンドまたはコマンドラインで指定し
た`gnuplot` のコマンドファイルを、その次のコマンドが読まれる前に、開始
点に再設定します。これは、コマンドファイルの最初から *Note reread:: コ
マンドまでのコマンドの無限ループを本質的に実装していることになります。
(しかし、これは何も悪いことではありません。*Note reread:: は `if` と組
み合わせることでとても有用なコマンドとなります。)標準入力からの入力の場
合は、*Note reread:: コマンドは何も影響を与えません。

例:

ファイル "looper" が次のようなファイルで
           a=a+1
           plot sin(x*a)
           pause -1
           if(a<5) reread

そして、`gnuplot` から次のように実行するとします。
           a=0
           load 'looper'

すると、pause のメッセージで分割された 5 回のプロットが行われることにな
ります。

ファイル "data" が、各行に、0 から 10 までの範囲 (yrange) の 6 つのデー
タ を持ち、最初が x 座標で、その他は 5 つの異なる関数の、その x での値
であるとします。そして、ファイル "plotter" が
           c_p = c_p+1
           plot "$0" using 1:c_p with lines linetype c_p
           if(c_p <  n_p) reread

で、`gnuplot` から次のように実行するとします。
           n_p=6
           c_p=1
           unset key
           set yrange [0:10]
           set multiplot
           call 'plotter' 'data'
           unset multiplot

すると、5 つのプロットを合わせた 1 つのグラフができます。yrange は、
multiplot モードで最初のものに続けて書かれる 5 つのグラフが、同じ軸を持
つように、明示的に指定する必要があります。線種も指定しなければなりませ
ん。さもないと、全てのグラフが同じ線種で書かれることになります。アニメー
ションのサンプルとして、demo ディレクトリの animate.dem も参照してくだ
さい。




File: gnuplot.info, Node: reset, Next: save, Prev: reread, Up: コマンド_(Commands)

reset
=====



コマンド *Note reset:: は `set` コマンドで定義できる、グラフに関する全
てのオプションをデフォルトの値に設定します。このコマンドは、例えばコマ
ンドファイルの最後にグラフのデフォルトの設定に復帰する、あるいはコマン
ドファイル内でたくさんの設定を行なった場合に元の状態に戻すときなどに便
利です。様々なオプションの取るデフォルトの値を知るには、`set` コマンド
の結果を参照してください。

以下のものは、*Note reset:: の影響を受けません。
          `set term` *Note output:: *Note loadpath:: *Note fontpath:: `set linetype`
          *Note encoding:: *Note decimalsign:: *Note locale:: *Note psdir::



`reset errors` は、エラー状態変数 GPVAL_ERRNO と GPVAL_ERRMSG のみをク
リアします。



`reset bind` は、キー定義をデフォルトの状態に復帰します。



File: gnuplot.info, Node: save, Next: set-show, Prev: reset, Up: コマンド_(Commands)

save
====



*Note save:: コマンドは、ユーザ定義関数、変数、`set term` の状態、
`set` で設定する全てのオプションのいずれかか、あるいはこれらすべてと、
それに加えて最後に実行した *Note plot:: (または `splot`) コマンドを、指
定したファイルに保存します。

書式:
             save  {<オプション>} '<ファイル名>'


ここで、<オプション> は、*Note functions::, *Note variables::, *Note
terminal::, `set`のいずれかです。どれも指定されなかった場合には、
`gnuplot` は、ユーザ定義関数、変数、set で設定するオプション、最後に実
行した *Note plot:: (または`splot`) コマンドの全てを保存します。

*Note save:: は、テキスト形式で出力します。また、このファイルは `load`
コマンドで読み込むことができます。`set` オプション付き、または何もオプ
ションをつけずに *Note save:: を実行した場合、*Note terminal:: の選択と
*Note output:: のファイル名はコメント記号つきで書き出されます。これはそ
の出力ファイルを他の環境にインストールされた gnuplot 上で動かす場合に、
修正なしに使えるようにする、あるいはうっかりファイルを上書きしてしまっ
たりする危険性を避ける、といった意味があります。

*Note terminal:: は、*Note terminal:: の状態を、コメント記号をつけずに
書き出します。これは主に、ちょっとの間だけ *Note terminal:: の設定を入
れ替え、その後保存しておいた *Note terminal:: の状態を読み込むことで以
前の terminal の設定に戻す場合などに役立ちます。ただ、単一の gnuplot セッ
ションでは、現在の terminal を保存/復元する他の方法であるコマンド `set
term push` と`set term pop` を使う方がむしろいいかもしれません。以下参
照: `set term`。

ファイル名は引用符に囲われていなければなりません。

特別なファイル名 "-" により *Note save:: コマンドに標準出力に出力させる
ことができます。popen 関数をサポートするようなシステム (Unix など) では、
save の出力をパイプ経由で他の外部プログラムに渡すことができます。その場
合、ファイル名としてコマンド名の先頭に '|' をつけたものを使います。これ
は、`gnuplot` とパイプを通して通信するプログラムに、`gnuplot` の内部設
定に関する首尾一貫したインターフェースを提供します。詳細は、以下参照:
`batch/interactive`。

例:
           save 'work.gnu'
           save functions 'func.dat'
           save var 'var.dat'
           save set 'options.dat'
           save term 'myterm.gnu'
           save '-'
           save '|grep title >t.gp'




File: gnuplot.info, Node: set-show, Next: shell, Prev: save, Up: コマンド_(Commands)

set-show
========



`set` コマンドは実に多くのオプションを設定するのに使われます。しかし、
*Note plot::, `splot`, *Note replot:: コマンドが与えられるまで何も表示しません。

`show` コマンドはそれらの設定値を表示します。`show all` でそれら全てを
表示します。

`set` コマンドで変更されたオプションは、それに対応する *Note unset:: コマン
ドを実行することでデフォルトの状態に戻すことができます。以下も参照:
*Note reset::。これは全てのパラメータの設定をデフォルトの値に戻します。

もし変数が日時のデータを含むならば、`show` は、*Note timefmt:: によって
現在設定されている書式に従って表示します。それは変数が最初に設定されて
いてその書式が効果を持たなかったとしてもです。

`set` と *Note unset:: コマンドには繰り返し節も利用できます。以下参照:
`iteration`。


* Menu:

* angles::
* arrow::
* autoscale::
* bars::
* bind_::
* bmargin::
* border::
* boxwidth::
* clabel::
* clip::
* cntrparam::
* カラーボックス_(colorbox)::
* 色名_(colornames)::
* 等高線_(contour)::
* data_style::
* datafile::
* decimalsign::
* dgrid3d::
* dummy::
* encoding::
* fit_::
* fontpath::
* format_::
* function_style::
* functions::
* grid::
* hidden3d::
* historysize::
* isosamples::
* key::
* ラベル_(label)::
* 線種_(linetype)::
* lmargin::
* loadpath::
* locale::
* logscale::
* macros::
* mapping::
* margin::
* mouse::
* multiplot::
* mx2tics::
* mxtics::
* my2tics::
* mytics::
* mztics::
* object::
* offsets::
* origin::
* output::
* parametric::
* plot_::
* pm3d::
* palette::
* pointintervalbox::
* pointsize::
* polar_::
* print_::
* psdir::
* raxis::
* rmargin::
* rrange::
* rtics::
* samples::
* size::
* style::
* surface::
* table::
* terminal::
* termoption::
* tics::
* ticslevel::
* ticscale::
* timestamp::
* timefmt::
* title_::
* tmargin::
* trange::
* urange::
* variables::
* version::
* view::
* vrange::
* x2data::
* x2dtics::
* x2label::
* x2mtics::
* x2range::
* x2tics::
* x2zeroaxis::
* xdata::
* xdtics::
* xlabel::
* xmtics::
* xrange::
* xtics::
* xyplane::
* xzeroaxis::
* y2data::
* y2dtics::
* y2label::
* y2mtics::
* y2range::
* y2tics::
* y2zeroaxis::
* ydata::
* ydtics::
* ylabel::
* ymtics::
* yrange::
* ytics::
* yzeroaxis::
* zdata::
* zdtics::
* zzeroaxis::
* cbdata::
* cbdtics::
* zero::
* zeroaxis::
* zlabel::
* zmtics::
* zrange::
* ztics::
* cblabel::
* cbmtics::
* cbrange::
* cbtics::



File: gnuplot.info, Node: angles, Next: arrow, Prev: set-show, Up: set-show

angles
------




デフォルトでは `gnuplot` は極座標グラフの独立変数の単位はラジアンを仮定
します。*Note polar:: の前に `set angles degrees` を指定すると、その単
位は度になり、デフォルトの範囲は [0:360] となります。これはデータファイ
ルの描画で特に便利でしょう。角度の設定は、*Note mapping:: コマンドを設
定することにより 3 次元でも有効です。

書式:
           set angles {degrees | radians}
           show angles


*Note polar:: で指定される角度も、*Note angles:: で指定した単位で読まれ
表示されます。

*Note angles:: は組み込み関数 sin(x), cos(x), tan(x) の引数や asin(x),
acos(x), atan8x), atan2(x), arg(x) の出力にも影響を与えます。双曲線関数
や、ベッセル関数の引数には影響を与えません。しかし、複素数を引数とする
逆双曲線関数の出力には影響が出ます。それらの関数が使われるときは、`set
angles radians` は入出力の引数の間に一貫性を持った管理を実現していなけ
ればなりません。

           x={1.0,0.1}
           set angles radians
           y=sinh(x)
           print y         #{1.16933, 0.154051} と表示
           print asinh(y)  #{1.0, 0.1} と表示

しかし、
           set angles degrees
           y=sinh(x)
           print y         #{1.16933, 0.154051} と表示
           print asinh(y)  #{57.29578, 5.729578} と表示

以下も参照poldat.dem: *Note angles:: を用いた極座標描画のデモ
(http://www.gnuplot.info/demo/poldat.html)



File: gnuplot.info, Node: arrow, Next: autoscale, Prev: angles, Up: set-show

arrow
-----




*Note arrow:: コマンドを使うことにより、グラフ上の任意の位置に矢印を表
示することができます。

書式:
           set arrow {<tag>} {from <position>} {to|rto <position>}
                     { {arrowstyle | as <arrow_style>}
                       | { {nohead | head | backhead | heads}
                           {size <length>,<angle>{,<backangle>}}
                           {filled | empty | nofilled}
                           {front | back}
                           { {linestyle | ls <line_style>}
                             | {linetype | lt <line_type>}
                               {linewidth | lw <line_width} } } }


           unset arrow {<tag>}
           show arrow {<tag>}


タグ <tag> は各矢印を識別する整数です。タグを指定しない場合は、その時点
で未使用の最も小さい数が自動的に割り当てられます。タグを使うことで、特
定の矢印を変更したり、削除したりできます。既に存在する矢印の属性を変更
する場合は、タグを明示した *Note arrow:: コマンドで変更箇所を指定してく
ださい。

<position> は x,y あるいは x,y,z で指定します。そしてその前に座標系を選
択するために `first`, `second`, `graph`, `screen`, `character` を置くこ
とができます。座標を指定しなければデフォルトでは 0 と見なされます。矢印
の端点は、5 つの座標系、すなわち `first` か `second` の軸、あるいは
`graph`, `screen`, `character` のうちの 1 つを選択して指定できます。詳
細は、以下参照: `coordinates`。"from" の場所の座標系指定子は、"to"の場
所に影響を及ぼすことはありません。グラフの枠をはみ出る矢印を書くことも
できますが、出力端末によってはエラーを生ずることがあります。終点が"to"
の代わりに "rto" で指定されている場合、始点からの相対的な位置に描かれま
す。この場合、線形軸 (非対数軸)、および `graph`, `screen` 座標に対して
は、始点と終点の距離が与えられた相対的な値に対応します。一方、対数軸に
対しては、与えられた相対的な値は、始点から終点への倍数に対応します。よっ
て、対数軸の場合、相対的な値として 0 や負の値を与えることは許されません。

`nohead` を指定することで、矢先のない矢、すなわち線分を書くこともできま
す。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1つの
矢は 1 つの矢先をその終端に持っています。`backhead` は始点に矢先を描き、
`heads` は線分の両端に矢先を描きます。全ての出力形式が両端の矢先の描画
をサポートしているわけではありません。

矢先の大きさは `size <length>,<angle>` または`size
<length>,<angle>,<backangle>` で制御できます。`<length>` は矢先の各枝の
長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
`<length>` の単位は x 軸と同じですが、それは `<length>` の前に`first`,
`second`, `graph`, `screen`, `character` をつけることで変更できます。詳
細は、以下参照: `coordinates`。`<backangle>` は、`filled` かまたは
`empty` がともに使われた場合のみ効力を持ち、その場合、`<backangle>` は
矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方向;単位は度) になり
ます。出力形式 `fig` は、制限された切り角関数を持っていて、それは 3 つ
の異なる形をサポートしていて、それは 2 つの閾値で決定します: 70 度未満
の場合、矢先はへこんだ切り角を持ち、110 度を超える場合、後ろの部分に尖っ
た角を持ち、その間の角では、矢先の後ろは直線になります。

`filled` を指定すると、塗りつぶされた矢先を作ります (`heads` が使われて
いる場合)。塗りつぶしは、多角形の塗りつぶしが行えるような出力形式でサポー
トされていて、そのリストについては、以下参照: `pm3d`。他の出力形式では
矢先は閉じられますが塗りつぶされません。それと同じ効果 (閉じらるが塗ら
れない) は、`empty` を指定しても得られます。また、`metafont`,
`metapost`, `latex`, `tgif` のように、矢をそれら自身の独自のルーチンで
描くような出力形式では、矢先の塗りつぶしや矢先の枠線描きはもちろんサポー
トされません。

線種はユーザの定義したラインスタイルのリストから選ぶこともできますし(以
下参照: `set style line`)、用意されている <line_type> の値 (デフォルト
のラインスタイルのリストの番号) そして <linewidth> (デフォルトの幅の倍
数) を使ってここで定義することもできます。

しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
幅) は、単に他の *Note arrow:: コマンドで適当な番号や `lt`, `lw` などを
指定しても、変更はできないことに注意して下さい。

`front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指定
された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`を
使えば、密集したデータで矢が見えなくなることを防ぐことができます。

例:

原点から (1,2) への矢印をユーザ定義済のスタイル 5 で描くには:
           set arrow to 1,2 ls 5


描画領域の左下角から (-5,5,3) へタグ番号 3 の矢印を描くには:
           set arrow 3 from graph 0,0 to -5,5,3


矢印の端を 1,1,1 に変更し、矢先を外して幅を 2 にするには:
           set arrow 3 to 1,1,1 nohead lw 2


x=3 の所へグラフの下から上まで鉛直線を描くには:
           set arrow from 3, graph 0 to 3, graph 1 nohead


T 字型の矢先を両端に持つ鉛直方向の矢を描くには:
           set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90


始点からの相対的な距離をグラフ座標で与えて矢を描くには:
           set arrow from 0,-5 rto graph 0.1,0.1


x の対数軸に相対的な終点を指定して矢を描く場合:
           set logscale x
           set arrow from 100,-5 rto 10,10

これは 100,-5 から 1000,5 までの矢を描きます。線形軸 (y) に対しては相対
的な座標 10 が "差 10" を意味するのに対し、対数軸 (x) に対しては相対的
な座標 10 は "倍数 10" として働きます。

2 番の矢印を消すには:
           unset arrow 2


全ての矢印を消すには:
           unset arrow


全ての矢印の情報を (タグの順に) 見るには:
           show arrow


矢印のデモ (http://www.gnuplot.info/demo/arrowstyle.html)




File: gnuplot.info, Node: autoscale, Next: bars, Prev: arrow, Up: set-show

autoscale
---------




自動縮尺機能 (autoscale) は x, y, z の各軸に対して独立に、または一括し
て指定できます。デフォルトでは全ての軸に対して自動縮尺設定を行います。
図の中の一部の描画 (*Note plot::) の組のみを元に autoscale したい場合は、
その対象でない *Note plot:: にフラグ `noautoscale` をつけることができま
す。以下参照: *Note datafile::。

書式:
           set autoscale {<axes>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
           unset autoscale {<axes>}
           show autoscale


ここで、<axes> (軸) は `x`, `y`, `z`, `cb`, `x2`, `y2`, `xy` のいずれか
です。`min` または `max` を軸に追加指定すると (`xy` では使えませんが)そ
れは `gnuplot` にその軸の最小値、または最大値のみを自動縮尺させることに
なります。軸も何も指定されていない場合は全ての軸が対象となります。

`fixmin` や `fixmax` や `fix` を追加指定すると、等間隔の目盛りの自動縮
尺時の、次の目盛り位置までの範囲の自動拡大を gnuplot に行わせないように
します。`set autoscale fix` はこれを全ての軸に対して設定します。コマン
ド `set autoscale keepfix` は、直前の `fix` の設定を維持したまま全ての
軸を自動縮尺にします。

自動縮尺機能を使うときは、描画範囲は自動的に割り出され、従属変数軸
(*Note plot:: のときは y 軸、`splot` のときは z 軸) は、関数やデータの
値域が収まるように設定されます。

従属変数軸 (y または z) の自動縮尺機能が指定されていない場合は、現在の
y や z の描画範囲がそのまま使われます。

独立変数軸 (*Note plot:: のときは x 軸、`splot` のときは x,y 軸) の自動
縮尺機能が指定されている場合は、描画される全てのデータファイルの点が収
まるように定義域をとるようになります。データファイルが 1 つも指定されて
いない場合は、自動縮尺機能はなんの効果もありません。つまり、関数のみが
指定されていてデーターファイルを使わない場合は、x 軸の描画範囲(z =
f(x,y) を描画しているときは y 軸も) は影響をうけません。

範囲に関するより詳しい情報に関しては、以下参照: *Note xrange::。

媒介変数モード (parametric) でも自動縮尺機能は有効です (以下参照:
*Note parametric::)。この場合、より多くの従属変数があるので、x, y, z 各
軸に関して、より多くの制御が行われます。媒介変数モードでの独立変数 (仮
変数) は *Note plot:: では t で `splot` では u, v です。そして媒介変数
モードでは、自動縮尺機能は (t, u, v, x, y, z) の全ての描画範囲を制御し、
x, y, z の範囲の自動設定を完全に行います。

自動縮尺機能は、極座標モード (polar mode) でも *Note plot:: の媒介変数
モードと同様に機能しますが、極座標モードでは *Note dummy:: で独立変数を
t から変更するできる (以下参照: *Note dummy::) という拡張があります。

目盛りが第二の軸に表示され、しかもこれらの軸に対する描画が行われなかっ
た場合には、x2range と y2range は xrange と yrange の値を受け継ぎます。
これは、xrange と yrange が整数個の目盛り幅に自動縮尺される「前」に行わ
れますので、場合によって予期しない結果をもたらす可能性があります。それ
を避けるために `fixmin`, `fixmax` オプションを使うことができます。

例:

以下は y 軸の自動縮尺機能を指定します (他の軸には影響を与えません):
           set autoscale y


以下は y 軸の最小値に対してのみ自動縮尺機能を指定します (y 軸の最大値、
および他の軸には影響を与えません):
           set autoscale ymin


以下は x2 軸の隣の目盛りへの自動範囲拡大機能を無効にし、よって描画デー
タ内、または関数に対する丁度の描画範囲を維持します:
           set autoscale x2fixmin
           set autoscale x2fixmax


以下は x, y 両軸の自動縮尺機能を指定します:
           set autoscale xy


以下は x, y, z, x2, y2 全軸の自動縮尺機能を指定します:
           set autoscale


以下は x, y, z, x2, y2 全軸の自動縮尺機能を禁止します:
           unset autoscale


以下は z 軸のみについて自動縮尺機能を禁止します:
           unset autoscale z


* Menu:

* 媒介変数モード_(parametric)::
* 極座標モード_(polar)::



File: gnuplot.info, Node: 媒介変数モード_(parametric), Next: 極座標モード_(polar), Prev: autoscale, Up: autoscale

媒介変数モード (parametric)
...........................

媒介変数表示モード (*Note parametric::) においては、xrange も yrange と
同様に縮尺を変えることができます。つまり、媒介変数モードにおいては、x
軸方向も自動的に縮尺が調整され、描こうとしている媒介変数表示の関数が収
まるようになります。もちろん、y 軸方向も媒介変数モードでない時同様に自
動的に縮尺を変えます。x 軸について自動縮尺機能が設定されていない場合は、
現在の x の範囲が使われます。

データファイルは媒介変数モードでもそうでない状態でも同様に描画されます。
しかし、データファイルと関数が混在している場合には、違いがあります: 媒
介変数モードでなければ、x の自動縮尺機能は、関数の範囲をデータの描画範
囲に合わせます。しかし媒介変数モードではデータの範囲は関数の範囲に影響
しません。

それには、片手落ちにならないように `set autoscale t` というコマンドも用
意されています。しかしその効果は非常に小さいものです。自動縮尺機能が設
定されていると、`gnuplot` が t の範囲が無くなってしまうと判断した場合に
範囲を少し調整します。自動縮尺機能が設定されていないとこのようなときに
はエラーとなります。このような動作は実はあまり意味がなく、よって `set
autoscale t` というコマンドは存在意義に疑問があります。

`splot` では上記の発想の元に拡張されています。自動縮尺機能が設定されて
いる場合、x, y, z の各描画範囲は計算結果が収まるように設定され縮尺調整
されます。



File: gnuplot.info, Node: 極座標モード_(polar), Prev: 媒介変数モード_(parametric), Up: autoscale

極座標モード (polar)
....................

極座標モード (*Note polar::) では、xrange と yrange は自動縮尺モードで
はなくなります。動径軸の範囲制限用に *Note rrange:: を使用した場合、
xrangeと yrange はそれに合うように自動的に調整されます。しかし、さらに
それを調整したければ、その後に明示的に xrange や yrange コマンドを使う
ことができます。以下参照: *Note rrange::。trange は自動範囲設定がなされ
ます。もし、trange がある象限 (四分円) に収まるならば、自動縮尺機能によ
りその象限のみの描画が行われることに注意してください。

1 つ、あるいは 2 つの範囲は明示的に設定してその他のものを指定しない場合
は予期しない結果を引き起こすかも知れません。以下も参照極座標のデモ。
(http://www.gnuplot.info/demo/poldat.html)



File: gnuplot.info, Node: bars, Next: bind_, Prev: autoscale, Up: set-show

bars
----



コマンド *Note bars:: は誤差グラフ (errorbar) の両端、および boxplot に
つく箱ひげの両端のマークを制御します。

書式:
           set bars {small | large | fullwidth | <size>} {front | back}
           unset bars
           show bars


`small` は 0.0, `large` は 1.0 と同じです。サイズを指定しなければデフォ
ルトの値は 1.0 です。

キーワード `fullwidth` は、errorbar を伴う boxplots と histograms にの
み関連します。これは errorbar の両端の幅を、対応する箱の幅と同じに設定
しますが、箱の幅自体を変更することはありません。

キーワード `front`, `back` は、塗り潰し長方形のついた errorbar のみに関
連します (boxes, candlesticks, histograms)。



File: gnuplot.info, Node: bind_, Next: bmargin, Prev: bars, Up: set-show

bind
----



現在のホットキーの割り当て (binding) を表示します。以下参照: `bind`。



File: gnuplot.info, Node: bmargin, Next: border, Prev: bind_, Up: set-show

bmargin
-------



コマンド *Note bmargin:: は、下部の余白のサイズを設定します。詳細は以下
参照: *Note margin::。



File: gnuplot.info, Node: border, Next: boxwidth, Prev: bmargin, Up: set-show

border
------




*Note border:: と *Note border:: は *Note plot:: や `splot` でのグラフの枠の
表示を制御します。枠は必ずしも軸とは一致しないことに注意してください。
*Note plot:: では大抵一致しますが、`splot` では大抵一致していません。

書式:
           set border {<integer>} {front | back} {linewidth | lw <line_width>}
                      {{linestyle | ls <line_style>} | {linetype | lt <line_type>}}
           unset border
           show border


`set view 56,103` のように任意の方向で表示されうる `splot` では、 x-y平
面上の 4 つの角は 手前 (`front`), 後ろ (`back`) , 左 (`left`), 右
(`right`) のように呼ばれます。もちろんこの同じ 4 つの角は天井の面にもあ
ります。よって、例えば x-y 平面上の後ろと右の角をつなぐ境界を"底の右後
ろ (bottom right back)" と言い、底と天井の手前の角をつなぐ境界を "鉛直
手前 (front vertical)" と呼ぶことにします (この命名法は、読者が下の表を
理解するためだけに使われます)。

枠は、12 ビットの整数に符号化されています: 下位 4 ビットは *Note
plot:: に対する外枠、`splot` に対しては底面の外枠、次の 4 ビットは
`splot` の鉛直な外枠、そして上位 4 ビットは `splot` の天井面の外枠を制
御します。その`<整数>` 値は次の表の対応する項目の数字の和になります:


              ビット     plot        splot
                   1      下      底の左手前
                   2      左      底の左後ろ
                   4      上      底の右手前
                   8      右      底の右後ろ
                  16    効果なし  鉛直左
                  32    効果なし  鉛直後ろ
                  64    効果なし  鉛直右
                 128    効果なし  鉛直手前
                 256    効果なし  天井の左後ろ
                 512    効果なし  天井の右後ろ
                1024    効果なし  天井の左手前
                2048    効果なし  天井の右手前




ビットは一つ一つ、あるいはいくつかをまとめて一緒にこのコマンドで付加で
きます。

デフォルトの値は 31 で、これは *Note plot:: では 4 方向の外枠全て、
`splot`では底面の枠線全部と z 軸を描くことを意味します。

2 次元描画では境界はすべての描画要素の一番上に描かれます (`front`)。も
し境界を描画要素の下に描かせたい場合は、`set border back` としてくださ
い。

<line_style>, <line_type>, <line_width> を指定して、枠線の描画にそれら
を反映させることができます (現在の出力装置がサポートするものに限定され
ます)。

*Note plot:: では、第 2 軸を有効にすることで、下と左以外の境界に目盛り
を描くことができます。詳細は、以下参照: `xtics`。

"`unset surface; set contour base`" などによって `splot` で底面にのみ描
画する場合、鉛直線や天井はそれらが指定されていても描画されません。

*Note grid:: のオプション 'back', 'front', 'layerdefault' でも、描画出
力の境界線を書く順番を制御できます。

例:

以下は、デフォルトの枠線を描きます:
           set border


以下は、*Note plot:: では左と下、`splot` では底面の左手前と左後ろの枠線
を描きます:
           set border 3


以下は、`splot` で周りに完全な箱を描きます:
           set border 4095


以下は、手前の鉛直面と天井のない箱を描きます:
           set border 127+256+512 # または set border 1023-128


以下は、*Note plot:: に対して上と右枠線のみを描き、それらを軸として目盛
りづけします:
           unset xtics; unset ytics; set x2tics; set y2tics; set border 12





File: gnuplot.info, Node: boxwidth, Next: clabel, Prev: border, Up: set-show

boxwidth
--------



コマンド *Note boxwidth:: は *Note boxes::, *Note boxerrorbars::,
*Note boxplot::, *Note candlesticks::, *Note histograms:: スタイルにお
ける棒のデフォルトの幅を設定するために使います。

書式:
           set boxwidth {<width>} {absolute|relative}
           show boxwidth


デフォルトでは、隣り合う棒が接するように各々の棒の幅が広げられます。そ
れとは異なるデフォルトの幅を設定するには *Note boxwidth:: コマンドを使
用します。`relative` の場合の幅は、デフォルトの幅に対する比であると解釈
されます。

修飾子 `relative` を指定しなかった場合、棒の幅 (boxwidth) として指定さ
れた明示的な値は、現在の x 軸の単位での数字 (`absolute`) であると解釈さ
れます。x 軸が対数軸 (以下参照: `set log`) である場合、boxwidth の値は
実際には x=1 でのみ "絶対的" となり、その物理的な長さが軸全体を通じて保
持されます (すなわち、棒は x 座標の増加にともなって狭くなったりはしませ
ん)。対数軸の x 軸の範囲が x=1 から離れている場合は、適切な幅を見出すに
は何度か試してみる必要があるかも知れません。

デフォルトの値は、*Note boxes:: や *Note boxerrorbars:: スタイルの幅指定用の追加の
データ列の明示的な値があればそれによって置き換えられます。4 列のデータ
の場合、第 4 列目の値が棒の幅として使われます。ただし、その幅が -2.0
の場合には棒の幅は自動計算されます。詳細は、以下参照: *Note boxes::,
*Note boxerrorbars::。

棒の幅を自動的にセットするには
           set boxwidth


とする、あるいは 4 列のデータに対しては以下のようにします。
           set boxwidth -2


*Note plot:: のキーワード *Note using:: を使っても同じ効果を得ることができます:
           plot 'file' using 1:2:3:4:(-2)


棒の幅を自動的な値の半分にするには
           set boxwidth 0.5 relative


棒の幅を絶対的な値 2 にするには
           set boxwidth 2 absolute




File: gnuplot.info, Node: clabel, Next: clip, Prev: boxwidth, Up: set-show

clabel
------



`gnuplot` は、clabel が設定されている時には、各々の等高線のレベルに対し
て使う線種を変化させます。このオプションが有効である場合 (デフォ ルト)、
凡例によって各々の線種を、それが表す z のレベルとともに表示されます。

書式:
           set clabel {'<format>'}
           unset clabel
           show clabel


書式文字列のデフォルトは %8.3g で、小数部分は 3 桁表示されます。もし
key がそのデフォルトの値から変更されていれば、その配置は不十分なものに
なるかもしれません。

最初の等高線の線種、または clabel が無効である場合の唯一つの等高線の線
種は、(曲面の線種 +1) になります。等高線の点は曲面の点と同じものになり
ます。

以下参照: `set contour`。



File: gnuplot.info, Node: clip, Next: cntrparam, Prev: clabel, Up: set-show

clip
----




`gnuplot` はグラフの端の辺りのデータ点や線をクリッピングすることができ
ます。

書式:
             set clip <clip-type>
             unset clip <clip-type>
             show clip


`gnuplot` は点や線に対するクリップ型 (clip-type) として、`points`,
`one`, `two` の 3 種類をサポートしています。ある描画に対して、これらの
クリップ型は任意の組み合せで設定することができます。`pm3d` の色地図やカ
ラー曲面で塗りつぶされた四角形はこのコマンドでは制御できませんが、`set
pm3d clip1in` や `set pm3d clip4in` によって可能であることに注意してく
ださい。

クリップ型 `points` を設定すると、描画領域内にはあるけれど境界線に非常
に近いような点をクリップする (実際には描画しないだけですが) ように
`gnuplot` に指示します。これは点として大きなマークを使用したときに、そ
のマークが境界線からはみ出さないようにする効果があります。`points`をク
リップしない場合、境界線の辺りの点が汚く見えるかもしれません。その場合、
x や y の描画範囲 (xrange, yrange) を調整してみて下さい。

クリップ型 `one` を設定すると、一端のみが描画領域にあるような線分も描画
するように `gnuplot` に指示します。この際、描画領域内にある部分のみが実
際に描画される範囲です。設定しなかった場合、このような線分は描画対象と
ならず、どの部分も描画されません。

両端は共に描画範囲に無いが描画領域を通過するという線分もあります。クリッ
プ型 `two` を設定することによって、このような線分の描画領域の部分を描画
することができます。

どのような状況でも、描画範囲の外に線が引かれることはありません。

デフォルトでは、`noclip points`, `clip one`, `noclip two` となっていま
す。

全てのクリップ型の設定状況を見るには以下のようにします:
             show clip


過去のバージョンとの互換性のため以下の書式も使用可能です:
            set clip
            unset clip


*Note clip:: は `set clip points` と同義です。*Note clip:: は 3 種のク
リップ型全てを無効にします。



File: gnuplot.info, Node: cntrparam, Next: カラーボックス_(colorbox), Prev: clip, Up: set-show

cntrparam
---------



*Note cntrparam:: は等高線の生成方法、およびそれを滑らかに描画する方法
を制御します。`show contour` は現在の `contour` の設定だけでなく *Note
cntrparam::の設定をも表示します。

書式:
           set cntrparam { { linear
                           | cubicspline
                           | bspline
                           | points <n>
                           | order <n>
                           | levels { auto {<n>} | <n>
                                      | discrete <z1> {,<z2>{,<z3>...}}
                                      | incremental <start>, <incr> {,<end>}
                                    }
                           }
                         }
           show contour


このコマンドは 2 つの機能を持っています。一つは等高線上の点 (データ点の
線形補間、あるいは関数の標本化 (isosample) による点) での z の値の設定
で、もう一つは、そのように決定された z が等しい点同士を等高線で結ぶ方法
の制御です。<n> は整数型の定数式、<z1>, <z2> ... は任意の定数式です。各
オプション変数の意味は次の通りです:

`linear`, `cubicspline`, `bspline` -- 近似 (補間) 方法を指定します。
`linear` ならば、等高線は曲面から得られた値を区分的に直線で結びます。
`cubicspline` (3 次スプライン) ならば、区分的な直線はいくぶんなめらかな
等高線が得られるように補間されますが、多少波打つ可能性があります。
`bspline` (B-spline) は、より滑らかな曲線を描くことが保証されますが、こ
れは z の等しい点の位置を近似しているだけです。

`points` -- 最終的には、全ての描画は、区分的な直線で行われます。ここで
指定する数は、`bspline` または `cubicspline` での近似に使われる線分の数
を制御します。実際には cubicspline と bspline の区間 (曲線線分) の数は
`points` と線分の数の積に等しくなります。

`order` -- bspline 近似の次数です。この次数が大きくなるにつれて、等高線
はなめらかになります (もちろん、高次の bspline 曲線になるほど、元の区分
的直線からは離れていきます)。このオプションは `bspline` モードでのみ有
効です。指定できる値は、2 (直線) から 10 までの整数です。

`levels` -- 等高線のレベルの数は、`auto` (デフォルト), `discrete`,
`incremental` と等高線のレベル数 <n> で制御します。

`auto` では、<n> は仮のレベルの数であり、実際のレベルの数は、簡単なラベ
ルを生成するように調節されます。曲面の z 座標が zmin から zman の範囲に
あるとき、等高線はその間の dz の整数倍になるように生成されます。ここで、
dz は 10 のあるべき乗の 1, 2, 5 倍、のいずれかです (2 つの目盛りの間を
丁度割り切るように)。

`levels discrete` では、等高線は指定された z = <z1>, <z2> ... に対して
生成されます。指定した個数が等高線のレベルの個数となります。
`discrete`モードでは、`set cntrparams levels <n>` という指定は常に無視
されます。

`incremental` では、等高線は z = <start> から始まり、<increment> ずつ増
えて行き限界の個数に達するまで書かれます。<end> はその等高線の数を決定
するのに使われますが、これは後の `set cntrparam levels <n>` によって常
に変更されます。z 軸が対数軸の場合、*Note ztics:: の場合と同様に、
<increment> は倍数として解釈されます。

コマンド *Note cntrparam:: が引数なしに呼ばれた場合は、次のデフォルトの
値が使われます: linear, 5 points, order 4, 5 auto levels

例:
           set cntrparam bspline
           set cntrparam points 7
           set cntrparam order 10


以下はレベルの基準が合えば 5 個のレベルがに自動的に選択されます:
           set cntrparam levels auto 5


以下は .1, .37, .9 にレベルを設定します:
           set cntrparam levels discrete .1,1/exp(1),.9


以下は 0 から 4 まで、1 ずつ増やすレベルを設定します:
           set cntrparam levels incremental  0,1,4


以下はレベルの数を 10 に設定します (増加の最後の値 (end) または自動で設
定されるレベルの数は変更されます):
           set cntrparam levels 10


以下はレベルの数は保持したままレベルの開始値と増分値を設定します:
           set cntrparam levels incremental 100,50


等高線を描く場所の制御に関しては、以下参照: `set contour`。等高線のラベ
ルの書式と線種の制御に関しては、以下参照: *Note clabel::。

以下も参照してください。等高線のデモ (contours.dem)
(http://www.gnuplot.info/demo/contours.html)およびユーザ定義レベルの等
高線のデモ
(discrete.dem). (http://www.gnuplot.info/demo/discrete.html)



File: gnuplot.info, Node: カラーボックス_(colorbox), Next: 色名_(colornames), Prev: cntrparam, Up: set-show

カラーボックス (colorbox)
-------------------------



色の一覧表、すなわち `pm3d` の *Note palette:: の min_z から max_z まで
の滑らかな色の勾配は、`unset colorbox` が使われていない限りカラーボック
ス(colorbox) に描かれます。

           set colorbox
           set colorbox {
                      { vertical | horizontal }
                      { default | user }
                      { origin x, y }
                      { size x, y }
                      { front | back }
                      { noborder | bdefault | border [line style] }
                    }
           show colorbox
           unset colorbox


カラーボックスの位置は、`default` または `user` で指定でき、後者の場合
その位置や大きさを *Note origin:: や *Note size:: コマンドで設定します。
カラーボックスは、グラフや曲面の後 (`front`) あるいは先 (`back`) に描画
させることもできます。

色勾配の方向は、オプション `vertical` と `horizontal` で切替えることが
可能です。

`origin x, y` と `size x, y` は `user` オプションとの組でのみ使用されま
す。x, y の値は、デフォルトではスクリーン座標と解釈されますが、これは
3 次元描画用のかしこまったオプションに過ぎません。`set view map` による
splot を含む 2 次元描画では、任意の座標系での指定が可能です。例えば以下
を試してみてください:
         set colorbox horiz user origin .1,.02 size .8,.04

これは水平方向の色勾配をグラフの下の辺りに描画します。

*Note border:: は境界描画を ON にします (デフォルト) し、`noborder` は
境界描画を OFF にします。*Note border:: の後ろに正の整数を与えると、そ
れを境界を描画する時の line style のタグとして使います。例えば:
         set style line 2604 linetype -1 linewidth .4
         set colorbox border 2604

は line style `2604`、すなわち細い線のデフォルトの境界色 (-1) で境界を
描画します。`bdefault` (デフォルト) は、カラーボックスの境界の描画にデ
フォルトの境界の line style を使います。

カラーボックスの軸は `cb` と呼ばれ、通常の軸のコマンドで制御されます。
すなわち `set/unset/show` で *Note cbrange::, `[m]cbtics`, `format
cb`, `grid [m]cb`, *Note cblabel:: などが、そして多分 *Note cbdata::,
`[no]cbdtics`, `[no]cbmtics` なども使えるでしょう。

パラメータ無しの `set colorbox` はデフォルトの位置へ切替えます。`unset
colorbox` はカラーボックスのパラメータをデフォルト値にリセットし、その
上でカラーボックスを OFF にします。

以下も参照: `set pm3d`, *Note palette::, `x11 pm3d`, `set style line`。



File: gnuplot.info, Node: 色名_(colornames), Next: 等高線_(contour), Prev: カラーボックス_(colorbox), Up: set-show

色名 (colornames)
-----------------


gnuplot は限定された個数の色の名前を持っています。これらは、pm3d パレッ
トでつながれる色の範囲を定義するのに、あるいは個々の線種やラインスタイ
ルの色を出力形式に依存しない形で定義したりするのに使えます。gnuplotの持
つ色名の一覧を見るには、コマンド `show colornames` を使用してください。
例:

           set style line 1 linecolor rgb "sea-green"




File: gnuplot.info, Node: 等高線_(contour), Next: data_style, Prev: 色名_(colornames), Up: set-show

等高線 (contour)
----------------



コマンド `set contour` は曲面の等高線を引くことを指示します。このオプショ
ンは `splot` でのみ有効です。これは、格子状データ (grid data) を必要と
します。詳細は、以下参照: `grid_data`。非格子状データで等高線を描きたい
場合は、格子を生成するために *Note dgrid3d:: を使用します。

書式:
           set contour {base | surface | both}
           unset contour
           show contour


これらの 3 つのオプションは等高線をどこに引くかを指定します。`base` で
は等高線を x/y 軸の刻みのある底面に描かれ、*Note surface:: では等高線は
その曲面自体の上に描かれ、`both` では底面と曲面上の両方に描かれます。オ
プションが指定されていない場合は `base` であると仮定されます。

等高線の描画に影響を与えるパラメータについては、以下参照:
*Note cntrparam::。等高線のラベルの制御に関しては、以下参照:
*Note clabel::。

等高線のみのグラフを得るために、曲面自身の描画をしないようにすることも
できます (以下参照: *Note surface::)。*Note size:: を使って、グラフを画
面一杯に描画することも可能ですが、そういった出力形式よりも、等高線のデー
タをファイルに書き出し、それを再び 2 次元データとして読み込んで描画すれ
ばよりよい制御が可能になります:

           unset surface
           set contour
           set cntrparam ...
           set table 'filename'
           splot ...
           unset table
           # contour info now in filename
           set term <whatever>
           plot 'filename'


等高線を描くためには、データは格子状データ ("grid data") である必要があ
ります。そのようなファイルでは、一つの y-孤立線上の全ての点が順に並べら
れていきます。そして隣の y-孤立線上の点が順に並べられ、そして隣、と続い
ていきます。y-孤立線同士を分離するには一行の空行 (空白、復帰、改行以外
の文字を含まない行) を挟みます。以下参照: *Note datafile::。

以下も参照してください。等高線のデモ (contours.dem)
(http://www.gnuplot.info/demo/contours.html)およびユーザ定義レベルの等
高線のデモ
(discrete.dem). (http://www.gnuplot.info/demo/discrete.html)



File: gnuplot.info, Node: data_style, Next: datafile, Prev: 等高線_(contour), Up: set-show

data style
----------

このコマンドの形式は現在は推奨されていません。以下参照: `set style
data`。



File: gnuplot.info, Node: datafile, Next: decimalsign, Prev: data_style, Up: set-show

datafile
--------

コマンド *Note datafile:: は、*Note plot::, `splot`, `fit` コマンドで入
力データを読む場合に、その列 (field) の解釈の仕方を制御するオプションを
持ちます。現在は、6 つのそのようなオプションが実装されています。

* Menu:

* set_datafile_fortran::
* set_datafile_nofpe_trap::
* set_datafile_missing::
* set_datafile_separator::
* set_datafile_commentschars::
* set_datafile_binary::



File: gnuplot.info, Node: set_datafile_fortran, Next: set_datafile_nofpe_trap, Prev: datafile, Up: datafile

set datafile fortran
....................


コマンド `set datafile fortran` は、入力ファイルの Fortran D 型、Q 型の
定数値の特別なチェックを可能にします。この特別なチェックは入力処理を遅
くしますので、実際にそのデータファイルが Fortran D 型、Q 型の定数を持っ
ている場合にのみこれを選択すべきです。このオプションは、その後で`unset
datafile fortran` を行えば無効にできます。



File: gnuplot.info, Node: set_datafile_nofpe_trap, Next: set_datafile_missing, Prev: set_datafile_fortran, Up: datafile

set datafile nofpe_trap
.......................




コマンド `set datafile nofpe_trap` は、入力ファイルからデータの読み込み
の際に、すべての数式の評価の前に浮動小数点例外ハンドラの再初期化をしな
いように gnuplot に命令します。これにより、とても大きなファイルからのデー
タの入力がかなり速くなりますが、浮動小数点例外が起きた場合にプログラム
が異常終了してしまう危険はあります。



File: gnuplot.info, Node: set_datafile_missing, Next: set_datafile_separator, Prev: set_datafile_nofpe_trap, Up: datafile

set datafile missing
....................


コマンド `set datafile missing` は `gnuplot` に、どのような文字列がデー
タファイル中の欠けたデータ (missing data) を意味するのかを指示します。
実際にその文字列がどのように取り扱われるかは、*Note plot:: や `splot`
コマンドの *Note using:: 指定子にも依存します。

書式:
           set datafile missing {"<string>"}
           show datafile missing
           unset datafile


例:
           # IEEE NaN ("Not a Number") コードを含むエントリを無視する
           set datafile missing "NaN"


例:
           set style data linespoints
           plot '-'
              1 10
              2 20
              3 ?
              4 40
              5 50
              e
           set datafile missing "?"
           plot '-'
              1 10
              2 20
              3 ?
              4 40
              5 50
              e
           plot '-' using 1:2
              1 10
              2 20
              3 ?
              4 40
              5 50
              e
           plot '-' using 1:($2)
              1 10
              2 20
              3 ?
              4 40
              5 50
              e


最初の *Note plot:: は、"3 ?" の行では最初のデータのみを認識し、そこで
は 1行に 1 つしかデータがなかった場合の規則が適用され、行番号が "x" で
データが "y" と見なされ、その点は (2,3) に (この場合は誤って) 描画され
ます。

2 番目と 3 番目の *Note plot:: コマンドは、真中の行を正しく無視します。
描画される曲線は、(2,20) と (4,40) が結ばれます。

4 番目の *Note plot:: も真中の行を正しく無視しますが、この場合は
(2,20) と(4,40) は結ばれません。

デフォルトの `missing` 用の文字は何も定義されていませんが、多くの場合数
値が期待されるべき所にそれと認識できない文字が見つかったらそれは欠けた
データ (missing data) であると見なされます。




File: gnuplot.info, Node: set_datafile_separator, Next: set_datafile_commentschars, Prev: set_datafile_missing, Up: datafile

set datafile separator
......................


コマンド `set datafile separator "<char>"` は、`gnuplot` に、この後の入
力ファイルのデータ列の分離文字が、空白 (whitespace) でなくて <char>であ
ると指示します。このコマンドの最も一般的な使用例は、表計算ソフトやデー
タベースソフトによって作られた csv (コンマ区切り) ファイルを読む時でしょ
う。デフォルトのデータ列の分離文字は空白 (whitespace) です。

書式:
           set datafile separator {"<char>" | whitespace}


例:
           # タブ区切りのファイルを入力
           set datafile separator "\t"


           # コンマ区切りのファイルを入力
           set datafile separator ","




File: gnuplot.info, Node: set_datafile_commentschars, Next: set_datafile_binary, Prev: set_datafile_separator, Up: datafile

set datafile commentschars
..........................


コマンド `set datafile commentschars` は `gnuplot` に、どの文字がデータ
ファイル中のコメントを意味するのかを指示します。gnuplot は、指定された
文字の中の一つがデータ行の最初の非空白文字として現われた場合、その文字
以下を無視します。

書式:
           set datafile commentschars {"<string>"}
           show datafile commentschars
           unset commentschars


デフォルトの string は、VMS では "#!" で、それ以外では "#" です。

よって、データファイルの以下の行は完全に無視されます
         # 1 2 3 4

が、以下の行
         1 # 3 4

は、もし
         set datafile missing '#'

が指定されていなければ、予期せぬ結果を生じます。

例:
           set datafile commentschars "#!%"




File: gnuplot.info, Node: set_datafile_binary, Prev: set_datafile_commentschars, Up: datafile

set datafile binary
...................

コマンド *Note binary:: は、データファイルの読み込み時にバイナ
リファイルをデフォルトと設定するのに使われます。書式は、それが *Note plot::
または `splot` コマンドで使われるのと正確に同じです。<binary list> に
書けるキーワードに関しては、詳しくは、以下参照: *Note matrix::,
*Note general::。

書式:
           set datafile binary <binary list>
           show datafile binary
           show datafile
           unset datafile


例:
           set datafile binary filetype=auto
           set datafile binary array=(512,512) format="%uchar"


           show datafile binary   # 現在の設定の一覧表示




File: gnuplot.info, Node: decimalsign, Next: dgrid3d, Prev: datafile, Up: set-show

decimalsign
-----------





コマンド *Note decimalsign:: は、目盛りの見出し、あるいは `set label`
文字列に書かれる数の小数点記号を選択します。

書式:
           set decimalsign {<value> | locale {"<locale>"}}
           unset decimalsign
           show decimalsign


引数 <value> は、通常の小数点記号に置き換えて使う文字列です。典型的なも
のはピリオド '.' やコンマ ',' ですが他にも有用なものがあるでしょう。引
数 <value> を省略すると、小数点の区切りはデフォルト (ピリオド) から変更
されません。unset decimalsign も <value> を省略するのと同じ効果を持ちま
す。

例:

多くのヨーロッパ諸国での正しい出力形式を得るには:
           set decimalsign ','


次のことに注意してください: 明示的な文字列を設定した場合、これは軸の目
盛りなどの gnuplot の gprintf() 書式関数で出力される数値のみに影響し、
入力データの書式指定や sprintf() 書式関数で出力される数値には影響しませ
ん。それらの入力や出力の形式の挙動も変更したい場合は、代わりに以下を使
用してください:

           set decimalsign locale


これは、gnuplot に、入力と出力の書式を、環境変数 LC_ALL, LC_NUMERIC,
LANG の現在の設定に従ったものを使わせるようにします。

           set decimalsign locale "foo"


これは、gnuplot に、入力と出力の書式を、ロケール "foo" に従ったものにし
ますが、そのロケールがインストールされている必要があります。もしロケー
ル "foo" が見つからなかった場合、エラーメッセージが出力され、小数点の設
定は変更されません。linux システム上では、そこにインストールされている
ロケールの一覧は "locale -a" で見ることができます。linux のロケール文字
列はだいたい "sl_SI.UTF-8" のような形式をしていますが、Windowsのロケー
ル文字列は "Slovenian_Slovenia.1250"、または "slovenian" のような形式で
す。ロケール文字列の解釈は、C のランタイムライブラリが行うことに注意し
てください。古い C ライブラリでは、ロケール設定のサポート(例えば数字の
3 桁毎の区切り文字など) を部分的にしか提供していないかもしれません。

           set decimalsign locale; set decimalsign "."


これは、現在のロケールに合ったどんな小数点でも、全ての入出力に対して使
用するように設定しますが、gnuplot の内部関数 gprintf() を使って書式化す
る数値は明示的に指定された '.' になります (上書き)。



File: gnuplot.info, Node: dgrid3d, Next: dummy, Prev: decimalsign, Up: set-show

dgrid3d
-------





コマンド *Note dgrid3d:: は、非格子状データから格子状データへの写像機能
を有効にし、そのためのパラメータを設定します。格子状データの構造につい
ての詳細は、以下参照: `splot grid_data`。

書式:
           set dgrid3d {<rows>} {,{<cols>}}
                       { splines |
                         qnorm {<norm>} |
                         (gauss | cauchy | exp | box | hann)
                           {kdensity} {<dx>} {,<dy>} }
           unset dgrid3d
           show dgrid3d


デフォルトでは *Note dgrid3d:: は無効になっています。有効になると、ファ
イルから読み込まれる 3 次元のデータは「散在した」データ (非格子状デー
タ)であると見なされます。格子は、グラフと等高線の描画のために、散在した
データを囲む矩形から得られる寸法と、row_size/col_size で指定される数の
行と列を持つように生成されます。格子は x 方向 (行) と y 方向 (列) に等
間隔です。z の値は散在するデータの z の値の重み付きの平均、またはスプラ
イン補間として計算されます。言い変えれば、規則的な間隔の格子が生成され、
全ての格子点で元のデータの滑かな近似値が評価されます。元のデータの代わ
りにこの近似値が描画されます。

デフォルトの列の数は行の数に等しく、そのデフォルトの値は 10 です。

元のデータから近似値を計算するためのいくつかのアルゴリズムが用意されて
いて、追加のパラメータを指定できるものもあります。これらの補間は、格子
点に近いデータ点ほど、その格子点に対してより強い影響を与えます。

`splines` アルゴリズムは、"薄いつぎ板" を元にした補間計算を行います。こ
れは追加パラメータを取りません。

`qnorm` アルゴリズムは各格子点で入力データの重み付き平均を計算します。
各点は格子点からの距離の norm 乗の逆数で重み付けされます。(実際には、
dx, dy を各データ点と格子点との差の成分であるとすると、重みは dx^norm
+ dy^norm で与えられます。2 のべきのノルム、特に 4, 8, 16 に関しては、
その重みの計算はユークリッド距離を使うことで (dx^2+dy^2)^norm/2 のよう
に最適化されてますが、任意の負でない整数を使うことも可能です。) ノルム
のべきの値をただ一つの追加パラメータとして指定できます。このアルゴリズ
ムがデフォルトになっています。

最後に、重み付き平均の計算用に、いくつかの平滑化重み付け関数 (kernel)が
用意されています: z = Sum_i w(d_i) * z_i / Sum_i w(d_i), ここで z_iは
i 番目のデータの値で、d_i は現在の格子点と i 番目のデータ点の位置との距
離です。すべての重み付け関数が、現在の格子点に近い方のデータ点には大き
な重み、遠い方のデータ点には小さい重みを付けます。

以下の重み付け関数が使用できます:
           gauss :     w(d) = exp(-d*d)
           cauchy :    w(d) = 1/(1 + d*d)
           exp :       w(d) = exp(-d)
           box :       w(d) = 1                     d<1 の場合
                            = 0                     その他
           hann :      w(d) = 0.5*(1-cos(2*pi*d))   d<1 の場合
                       w(d) = 0                     その他


これら 5 つの平滑化重み付け関数のうち一つを使用する場合、2 つまでの追加
パラメータ dx と dy を指定できます。これらは、距離の計算時に座標の違い
をスケール変換するのに使えます: d_i = sqrt( ((x-x_i)/dx)**2 +
((y-y_i)/dy)**2 ), ここで、x,y は現在の格子点の座標で、x_i,y_i は i 番
目のデータ点の座標です。dy のデフォルトの値は dx で、そのデフォルトの値
は 1 になっています。パラメータ dx とdy は、データ点が格子点へ「データ
それ自身の単位で」の寄与を行う範囲の制御を可能にします。

オプションキーワード `kdensity2d` は、重み付け関数名の後ろで (オプショ
ンの) スケール変換のパラメータの前に置くもので、これはアルゴリズムを変
更して、格子点用に計算する値を重みの和 ( z = Sum_i w(d_i) * z_i ) では
割らないようにします。z_i がすべて定数の場合、これは事実上 2 変数の重み
付け評価を描画します: (上の 5 つのうちの一つの) 重み付け関数が各データ
点に置かれ、それらの重みの和がすべての格子点で評価され、そして元のデー
タの代わりにこの滑らかな曲面が描画されます。これは、1 次元のデータ集合
に対する `smooth kdensity` オプションが行うこととおおまかには同じです
(使用例は kdensity2d.dem を参照してください)。

後方互換性のために、わずかに異なる書式もサポートされています。どのアル
ゴリズムも明示的に選択しなかった場合、`qnorm` アルゴリズムが仮定され、
3 つ以下の、コンマ (,) 区切りのオプションパラメータを指定した場合は、そ
れらをそれぞれ行数、列数、そして norm 値であると解釈します。

オプション *Note dgrid3d:: は、散在するデータを重み付き平均で規則的な格
子に置き変える単純な仕組みに過ぎません。この問題に対するより洗練された
手法が存在しますので、この単純な方法が不十分であれば、`gnuplot` の外で
そのような方法でデータを前処理するべきでしょう。

以下も参照dgrid3d.dem: dgrid3d のデモ
(http://www.gnuplot.info/demo/dgrid3d.html)およびscatter.dem: dgrid3d
のデモ (http://www.gnuplot.info/demo/scatter.html)




File: gnuplot.info, Node: dummy, Next: encoding, Prev: dgrid3d, Up: set-show

dummy
-----



コマンド *Note dummy:: はデフォルトの仮変数名を変更します。

書式:
           set dummy {<dummy-var>} {,<dummy-var>}
           show dummy


デフォルトでは、`gnuplot` は *Note plot:: では、媒介変数モード、あるい
は極座標モードでは "t", そうでなければ "x" を独立変数 (仮変数) とし、同
様に`splot` では、媒介変数モードでは (`splot` は極座標モードでは使えま
せん) "u" と "v", そうでなければ "x" と "y" を独立変数とします。

仮変数は、物理的に意味のある名前、あるいはより便利な名前として使う方が
便利でしょう。例えば、時間の関数を描画する場合:

           set dummy t
           plot sin(t), cos(t)


このコマンドでは、少なくとも一つの仮変数が設定される必要があります。
*Note dummy:: だけだとエラーメッセージが表示されます。

例:
           set dummy u,v
           set dummy ,s


第二の例は、2 番目の変数を s とします。



File: gnuplot.info, Node: encoding, Next: fit_, Prev: dummy, Up: set-show

encoding
--------






コマンド *Note encoding:: は文字のエンコード (encoding) を選択します。
書式:
           set encoding {<value>}
           set encoding locale
           show encoding


有効な値 (value) は以下の通りです。
        default     - 出力形式にデフォルトのエンコードの使用を命令
        iso_8859_1  - 多くの Unix ワークステーションや MS-Windows で使用可
                      能な最も一般的な西ヨーロッパエンコード。このエンコー
                      ドは PostScript の世界で 'ISO-Latin1' として知られて
                      いるものです。
        iso_8859_15 - ユーロ記号を含む iso_8859_1 の亜種
        iso_8859_2  - 中央/東ヨーロッパで使用されるエンコード
        iso_8859_9  - (Latin5 として知られる) トルコで使用されるエンコード
        koi8r       - 良く使われる Unix のキリル文字エンコード
        koi8u       - Unix のウクライナ地方のキリル文字エンコード
        cp437       - MS-DOS のコードページ
        cp850       - 西ヨーロッパの OS/2 のコードページ
        cp852       - 中央/東ヨーロッパの OS/2 のコードページ
        cp950       - MS 版の Big5 (emf terminal のみ)
        cp1250      - 中央/東ヨーロッパの MS Windows のコードページ
        cp1251      - ロシア、セルビア、ブルガリア、マケドニア語 (8 ビット)
        cp1254      - トルコの MS Windows のコードページ (Latin5 の拡張)
        sjis        - Shift_JIS 日本語エンコード
        utf8        - 各文字の Unicode エントリポイントの、可変長 (マルチバ
                      イト) 表現


コマンド *Note locale:: は、他のオプションとは違い、これは現在のロカー
ルを実行時の環境から決定しようとします。たいていのシステムではこれは環
境変数 LC_ALL, LC_CTYPE, LANG のいずれかによって制御されます。この仕組
みは、例えば wxt, cairopdf 出力形式で、UTF-8 や EUC-JP のようなマルチバ
イト文字エンコードを通すために必要です。このコマンドは日付や数字などの
ロカール特有の表現には影響を与えません。以下も参照: *Note locale::,
*Note decimalsign::。

一般に、エンコードの設定は出力形式の設定の前に行なう必要があります。こ
のエンコードはどんな出力形式でもサポートされているとは限らず、そして出
力形式は要求されたどんな非標準文字も生成できなければいけません。



File: gnuplot.info, Node: fit_, Next: fontpath, Prev: encoding, Up: set-show

fit
---

`fit` の設定は、コマンド `fit` がその出力を行うファイルを定義します。

書式:
           set fit {logfile {"<filename>"}} {{no}errorvariables} {{no}quiet}
           unset fit
           show fit


引数 <filename> は、単一引用符か二重引用符で囲む必要があります。

ファイル名を指定しなかった場合、または `unset fit` を使用した場合は、ロ
グファイルはデフォルトの値である "fit.log"、または環境変数 `FIT_LOG`の
値にリセットされます。

与えられたログファイル名が / か \ で終っている場合、それはディレクトリ
名と解釈され、ログファイルはそのディレクトリの "fit.log" となります。

オプション `errorvariables` が ON にされると、`fit` コマンドで計算され
たここの当てはめパラメータの誤差が、そのパラメータの名前に "_err" をつ
けた名前のユーザ定義変数にコピーされます。これは主に、当てはめ関数とデー
タの描画グラフの上にパラメータとその誤差を参照用に出力するのに使われま
す。例えば:

            set fit errorvariables
            fit f(x) 'datafile' using 1:2 via a, b
            print "error of a is:", a_err
            set label 'a=%6.2f', a, '+/- %6.2f', a_err
            plot 'datafile' using 1:2, f(x)


デフォルトでは、ログファイルに書き出される情報は画面にも表示されます。
`set fit quiet` とすればこの画面表示は消えます。



File: gnuplot.info, Node: fontpath, Next: format_, Prev: fit_, Up: set-show

fontpath
--------



*Note fontpath:: の設定は、フォントファイルを読み込む場合のファイルの検
索パスを追加定義します。今のところ、postscript 出力形式のみが *Note
fontpath::をサポートしています。ファイルが現在のディレクトリに見つから
なかった場合、*Note fontpath:: のディレクトリが検索されます。サポートし
ているフォントファイルの形式に関するより詳しい説明は `terminal
postscript` セクションの文書中にあります。

書式:
           set fontpath {"pathlist1" {"pathlist2"...}}
           show fontpath


パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切りま
す。*Note fontpath::, *Note save::, `save set` コマンドは、可搬性のため
にOS 固有のパス区切りをスペース (' ') で置き換えます。ディレクトリ名が
エクスクラメーションマーク ('!') で終っている場合、そのディレクトリのサ
ブディレクトリも検索されます。

環境変数 GNUPLOT_FONTPATH が設定されている場合、その内容は *Note
fontpath::に追加されますが、それが設定されていない場合システムに依存し
たデフォルトの値が使用されます。最初にフォントパスを使ったときに、その
幾つかのディレクトリが存在するかテストされ、セットされます。よって、一
番最初の*Note fontpath::, *Note fontpath::, *Note fontpath:: や、埋め込
みフォントを使用した場合の *Note plot::, `splot` は、少し時間がかかりま
す。それを少しでも短くしたければ、環境変数 GNUPLOT_FONTPATH を設定して
ください。そうすればディレクトリのチェックは OFF になります。デフォルト
のフォントパスが何であるかは、*Note fontpath:: で見ることができます。

*Note fontpath:: は、ユーザ定義の fontpath とシステムの fontpath を別々
に表示しますが、*Note save::, `save set` コマンドは、ユーザ定義の
*Note fontpath::のみを保存します。

gd ライブラリを通じてファイル名でフォントにアクセスする出力ドライバに関
しては、フォント検索パスは環境変数 GDFONTPATH で制御されます。



File: gnuplot.info, Node: format_, Next: function_style, Prev: fontpath, Up: set-show

format
------



座標軸の刻みの見出しは、コマンド *Note format:: または *Note format::ま
たは個別にコマンド *Note format:: で書式を設定できます。

書式:
           set format {<axes>} {"<format-string>"}
           set format {<axes>} {'<format-string>'}
           show format


ここで、<axes> (軸) は `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb`、または何
も指定しないか (その場合その書式はすべての軸に適用されます) のいずれか
です。以下の 2 つのコマンドは全く同等です:
           set format y "%.2f"
           set ytics format "%.2f"


書式文字列の長さは 100 文字まで、と制限されています。デフォルトの書式文
字列は "% g" ですが、、"%.2f" や "%3.0em" などの書式が好まれることも多
いでしょう。。LaTeX 用にはよく "$%g$" が好まれます。書式文字列を何も与
えない場合は、format はデフォルトに戻ります。空文字列 "" を指定した場合、
刻み自身は表示されますが見出しはつきません。刻み自身を消すには、`unset
xtics` または `set tics scale 0` を使用してください。

書式文字列では、改行文字 (\n) や拡張文字列処理 (enhanced text) 用のマー
クアップも使えます。 この場合は、単一引用符 (') でなく (") を使ってくだ
さい。以下も参照: `syntax`。"%" が頭につかない文字はそのまま表示されま
す。よって、書式文字列内にスペースや文字列などを入れることができます。
例えば "%g m" とすれば、数値の後に " m" が表示されます。"%" 自身を表示
する場合には "%g %%" のように 2 つ重ねます。

刻みに関するより詳しい情報については、以下も参照: `set xtics`。また、こ
の方法で出力される数字にデフォルト以外の小数分離文字を使うやり方につい
ては、以下参照: *Note decimalsign::。以下も参照。エレクトロン (電子) デ
モ (electron.dem). (http://www.gnuplot.info/demo/electron.html)

* Menu:

* gprintf_::
* 書式指定子_(format_specifiers)::
* 日時データ指定子_(time/date_specifiers)::



File: gnuplot.info, Node: gprintf_, Next: 書式指定子_(format_specifiers), Prev: format_, Up: format_

gprintf
.......


文字列関数 gprintf("format",x) は、gnuplot コマンドの *Note format::,
*Note timestamp:: などと同様の、gnuplot 独自の書式指定子を使います。こ
れらの書式指定子は、標準的な C 言語の関数である sprintf() のものと全く
同じではありません。gprintf() は、整形化される引数は一つしか受けつけま
せん。そのために、gnuplot には sprintf("format",x1,x2,...) 関数も用意さ
れています。gnuplot の書式オプションの一覧については、以下参照:
`format specifiers`。



File: gnuplot.info, Node: 書式指定子_(format_specifiers), Next: 日時データ指定子_(time/date_specifiers), Prev: gprintf_, Up: format_

書式指定子 (format specifiers)
..............................


使用可能な書式 (時間/日付モードでない場合) は以下の通りです:


           書式       説明
           %f         固定小数点表記
           %e, %E     指数表記; 指数の前に "e", "E" をつける
           %g, %G     %e (または %E) と %f の略記
           %x, %X     16 進表記
           %o, %O     8 進表記
           %t         10 進の仮数部
           %l         現在の対数尺の底を基数とする仮数部
           %s         現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
           %T         10 進の指数部
           %L         現在の対数尺の底を基数とする指数部
           %S         補助単位の指数部 (scientific power)
           %c         補助単位文字
           %b         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
           %B         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
           %P         πの倍数




補助単位 ('scientific' power) は、指数が 3 の倍数であるようなものです。
補助単位指数 (`"%c"`) の文字への変換は -18 から +18 までの指数に対して
サポートされています。この範囲外の指数の場合、書式は通常の指数形式に戻
ります。

ほかに使うことのできる修飾詞 ("%" と書式指定子の間に書くもの) には、次
のいくつかがあります: "-" は数字を左詰めにし、"+" は正の数にも符号をつ
け、" " (空白一つ) は負の数に "-" をつけるべき場所に正の数の場合に空白
を一つつけ、"#" は小数点以下の数字が 0 だけであっても小数点をつけ、正の
整数は出力幅を定め、出力幅指定の直前の "0" (文字でなく数字) は先頭に空
いた部分を空白で埋める代わりに 0 で埋め、小数点の後に非負の整数を書いた
ものは精度を意味します (整数の場合は最小桁、小数の場合は小数点以下の桁
数)。

これらの全ての修飾詞をサポートしていない OS もあるでしょうし、逆にこれ
以外のものをもサポートする OS もあるでしょう。疑わしい場合は、適切な資
料を調べ、そして実験してみてください。

例:
           set format y "%t"; set ytics (5,10)          # "5.0" と "1.0"
           set format y "%s"; set ytics (500,1000)      # "500" と "1.0"
           set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
           set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
           set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
           set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
           set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
           set format y "%.0f%%"; set ytic(50)          # "50%"


           set log y 2; set format y '%l'; set ytics (1,2,3)
           #"1.0", "1.0", "1.5" と表示される (3 は 1.5 * 2^1 なので)


丸めと指数が必要となるような書式で 9.999 の様な数字が書かれる場合は問題
が起こることがあります。

軸のデータ型が日時データ (time/date) の場合、書式文字列は 'strftime'
関数 ('gnuplot' 外。"man strftime" としてみてください) に関する有効な
指定を行う必要があります。使える入力書式指定の一覧に関しては、以下参照:
*Note timefmt::。



File: gnuplot.info, Node: 日時データ指定子_(time/date_specifiers), Prev: 書式指定子_(format_specifiers), Up: format_

日時データ指定子 (time/date specifiers)
.......................................



日時データモード (time/date mode) では、次の書式が使用できます:


           書式         説明
           %a           曜日名の省略形 (Sun,Mon,...)
           %A           曜日名 (Sunday,Monday,...)
           %b, %h       月名の省略形 (Jan,Feb,...)
           %B           月名 (January,February,...)
           %d           日 (01--31)
           %D           "%m/%d/%y" の簡略形 (出力のみ)
           %F           "%Y-%m-%d" の簡略形 (出力のみ)
           %k           時 (0--23; 1 桁または 2 桁)
           %H           時 (00--23; 常に 2 桁)
           %l           時 (1--12; 1 桁または 2 桁)
           %I           時 (01--12; 常に 2 桁)
           %j           その年の通算日 (1--366)
           %m           月 (01--12)
           %M           分 (0--60)
           %p           "am" または "pm"
           %r           "%I:%M:%S %p" の簡略形 (出力のみ)
           %R           "%H:%M" の簡略形 (出力のみ)
           %S           秒 (出力では 0--60 の整数、入力では実数)
           %s           2000 年最初からの秒数
           %T           "%H:%M:%S" の簡略形 (出力のみ)
           %U           その年の通算週 (週は日曜日からと数える)
           %w           曜日番号 (0--6, 日曜 = 0)
           %W           その年の通算週 (週は月曜日からと数える)
           %y           西暦 (2000-2068 年は 0-68、1969-1999 年は 69-99)
           %Y           西暦 (4 桁)





数字を表す書式では、これらの指定子 (% の後ろ、指定子の前) に "0" ("オー
でなく "ゼロ") をつけることで、先頭に空白ができる場合に空白の代わりに
0 で埋めることができ、また最小の出力幅を正の整数で指定することもできま
す (出力される数字を表示するのに指定した幅が足りない場合は無視されます)。
書式 %S は実数指定も受けつけますので、小数秒も書けます。表示する文字の
長さは 24 文字まで、という制限があり、長すぎた部分は切り捨てられます。

例:

日時のデータが "76/12/25 23:11:11" の場合
           set format x                 # デフォルトでは "12/25/76" \n "23:11"
           set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
           set format x "%r %D"         # "11:11:11 pm 12/25/76"


日時のデータが "98/07/06 05:04:03.123456" の場合
           set format x "%1y/%2m/%3d %01H:%02M:%06.3S"  # "98/ 7/  6 5:04:03.123"




File: gnuplot.info, Node: function_style, Next: functions, Prev: format_, Up: set-show

function style
--------------

このコマンドの形式は現在は推奨されていません。以下参照: `set style
function`。



File: gnuplot.info, Node: functions, Next: grid, Prev: function_style, Up: set-show

functions
---------

*Note functions:: コマンドはユーザーが定義した関数とその定義内容を表示
します。

書式:
             show functions


gnuplot における関数の定義とその使い方については、以下参照:
`expressions`。以下も参照ユーザ定義関数でのスプライン (spline.dem)
(http://www.gnuplot.info/demo/spline.html)および関数と複素変数を翼に使
用 (airfoil.dem)。 (http://www.gnuplot.info/demo/airfoil.html)



File: gnuplot.info, Node: grid, Next: hidden3d, Prev: functions, Up: set-show

grid
----




コマンド *Note grid:: は格子線を描きます。

書式:
           set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                    {{no}{m}x2tics} {{no}{m}y2tics}
                    {{no}{m}cbtics}
                    {polar {<angle>}}
                    {layerdefault | front | back}
                    { {linestyle <major_linestyle>}
                      | {linetype | lt <major_linetype>}
                        {linewidth | lw <major_linewidth>}
                      { , {linestyle | ls <minor_linestyle>}
                          | {linetype | lt <minor_linetype>}
                            {linewidth | lw <minor_linewidth>} } }
           unset grid
           show grid


格子線は任意の軸の任意の主目盛/副目盛に対して有効/無効にでき、その主目
盛りと副目盛りに対する線種、線幅も指定でき、現在の出力装置がサポートす
る範囲で、あらかじめ定義したラインスタイルを使用することもできます。

さらに、2 次元の描画では極座標格子も使うことができます。定義可能な区間
に対して、選択された目盛りを通る同心円と中心からの放射状の線が描かれま
す (その区間は *Note angles:: の設定にしたがって度、またはラジアンで指
定します)。極座標格子は現在は極座標モードでは自動的には生成されないこと
に注意してください。

*Note grid:: が描く前に、必要な目盛りは有効になっていなければなりません。
`gnuplot` は、存在しない目盛りに対する格子の描画の命令は単に無視します。
しかし、後でその目盛りが有効になればそれに対する格子も描きます。

副格子線に対する線種を何も指定しなければ、主格子線と同じ線種が使われま
す。デフォルトの極座標の角度は 30 度です。

`front` を指定すると、格子線はグラフのデータの上に描かれます。`back`が
指定された場合は格子線はグラフのデータの下に描かれます。`front` を使え
ば、密集したデータで格子線が見えなくなることを防ぐことができます。デフォ
ルトでは `layerdefault` で、これは 2D 描画では `back` と同じです。3D 描
画のデフォルトは、格子とグラフの枠を 2 つの描画単位に分離し、格子は後ろ
に、枠は描画データまたは関数の前に書きます。ただし、*Note hidden3d::モー
ドでは、それがそれ自身の並び換えをしていますので、格子線の順番のオプショ
ンは全て無視され、格子線も隠線処理にかけられます。これらのオプションは、
実際には格子線だけでなく、*Note border:: による境界線とその目盛りの刻み
(以下参照: `set xtics`) にも影響を及ぼします。

z の格子線は描画の底面に描かれます。これは描画の周りに部分的な箱が描画
されている場合にはいいでしょう。以下参照: *Note border::。



File: gnuplot.info, Node: hidden3d, Next: historysize, Prev: grid, Up: set-show

hidden3d
--------




*Note hidden3d:: コマンドは曲面描画 (以下参照: `splot`) で隠線処理を行
なうように指示します。その処理の内部アルゴリズムに関する追加機能もこの
コマンドで制御できます。

書式:
           set hidden3d {defaults} |
                        { {front|back}
                          {{offset <offset>} | {nooffset}}
                          {trianglepattern <bitpattern>}
                          {{undefined <level>} | {noundefined}}
                          {{no}altdiagonal}
                          {{no}bentover} }
           unset hidden3d
           show hidden3d


gnuplot の通常の表示とは異なり、隠線処理では与えられた関数、またはデー
タの格子線を、実際の曲面がその曲面の背後にあって隠されている描画要素は
見せないのと同じように処理します。これが機能するためには、その曲面が'格
子状' (以下参照: *Note datafile::) である必要があり、またそれらは`with
lines` か *Note linespoints:: で描かれていなければいけません。

*Note hidden3d:: が有効なときは、格子線だけでなく、面部分や土台の上の等
高線(以下参照: `set contour`) も隠されます。複数の面を描画している場合
は、各曲面は自分自身と他の曲面で隠される部分も持ちます。曲面上への等高
線の表示 (*Note surface::) は機能しません。

見出しと矢印は常に表示され、影響を受けません。グラフの説明 (key) も曲面
に隠されることはありません。gnuplot バージョン 4.6 では、グラフ上に曲面
が一つもない状態でも、hidden3d は `points`, *Note labels::, *Note
vectors::, *Note impulses:: の 3 次元の描画スタイルに影響を与えます。グ
ラフ内の各々の描画をこの処理から明示的に除外したいときは、*Note with::
指定に特別のオプション `nohidden3d` を追加してください。

hidden3d は、pm3d モードで描画された、塗り潰された曲面には影響を与えま
せん。pm3d の曲面に対して同様の効果を純粋に得たいならば、これの代わりに
`set pm3d depthorder` を使ってください。複数の pm3d 曲面に通常の*Note
hidden3d:: 処理を組み合わせるには、hidden3d 処理の全ての要素を強制的に
残りの他の描画要素の後に描画するためのオプション `set hidden3d front`を
使用し、そして曲面を 2 度描画してください。最初は `with lines lt -2`で、
2 度目は `with pm3d` で描画します。最初の方では、隠される描画要素の計算
を行っている間は隠す方の曲面も含まれているのですが、実際にはその曲面自
体は描画されません。

関数値は格子孤立線の交点で評価されます。見ることの出来る線分を求めると
きは個々の関数値、あるいはデータ点の間はそのアルゴリズムによって線形補
間されます。これは、*Note hidden3d:: で描画する場合と `nohidden3d` で描
画する場合で関数の見かけが異なることを意味します。なぜならば、後者の場
合関数値は各標本点で評価されるからです。この違いに関する議論については、
以下参照: *Note samples::, *Note isosamples::。

曲面の隠される部分を消去するのに使われるアルゴリズムは、このコマンドで
制御されるいくつかの追加オプションを持っています。`defaults` を指定すれ
ばそれらはすべて、以下で述べるようなデフォルトの値に設定されます。
`defaults` が指定されなかった場合には、明示的に指定されたオプションのみ
が影響を受け、それ以外のものは以前の値が引き継がれます。よって、それら
のオプションの値をいちいち修正することなく、単に `set {no}hidden3d`のみ
で隠線処理をオン/オフできることになります。

最初のオプション `offset` は '裏側' の線を描画する線の線種に影響を与え
ます。通常は曲面の表裏を区別するために、裏側の線種は、表側の線種より一
つ大きい番号の線種が使われます。`offset <offset>` によって、その追加す
る値を、デフォルトの 1 とは異なる増分値に変更できます。`nooffset` オプ
ションは `offset 0` を意味し、これは表裏で同じ線種を使うことになります。

次のオプションは `trianglepattern <bitpattern>` です。<bitpattern> は0
から 7 までの数字で、ビットパターンと解釈されます。各曲面は三角形に分割
されますが、このビットパターンの各ビットはそれらの三角形の各辺の表示を
決定します。ビット 0 は格子の水平辺、ビット 1 は格子の垂直辺、ビット 2
は、元々の格子が 2 つの三角形に分割されるときの対角辺です。デフォルトの
ビットパターンは 3 で、これは全ての水平辺と垂直辺を表示し、対角辺は表示
しないことを意味します。対角辺も表示する場合は 7 を指定します。

オプション `undefined <level>` は、定義されていない (欠けているデータま
たは未定義の関数値) か、または与えられた x,y,z の範囲を超えているデータ
点に適用させるアルゴリズムを指示します。そのような点は、それでも表示さ
れてしまうか、または入力データから取り除かれます。取り除かれてしまう点
に接する全ての曲面要素は同様に取り除かれ、よって曲面に穴が生じます。
<level> = 3 の場合、これは `noundefined` と同じで、どんな点も捨てられま
せん。これは他の場所であらゆる種類の問題を引き起こし得るので使わないべ
きです。<level> = 2 では未定義の点は捨てられますが、範囲を超えた点は捨
てられません。<level> = 1 では、これがデフォルトですが、範囲を超えた点
も捨てられます。

`noaltdiagonal` を指定すると、`undefined` が有効のとき (すなわち
<level>が 3 でない場合) に起こる以下の場合のデフォルトでの取扱いを変更
できます。入力曲面の各格子状の部分は一方の対角線によって 2 つの三角形に
分割されます。通常はそれらの対角線の全てが格子に対して同じ方向を向いて
います。もし、ある格子の 4 つの角のうち一つが `undefined` 処理によりと
り除かれていて、その角が通常の方向の対角線に乗っている場合は、その両方
の三角形が取り除かれてしまいます。しかし、もしデフォルトの設定である
`altdiagonal` が有効になっている場合、その格子については他方向の対角線
が代わりに選択され、曲面の穴の大きさが最小になるようにします。

`bentover` オプションは今度は `trianglepattern` とともに起こる別のこと
を制御します。かなりしわくちゃの曲面では、下の ASCII 文字絵に書いたよう
に、曲面の 1 つの格子が 2 つに分けられた三角形の表と裏の反対側が見えて
しまう場合 (すなわち、元の四角形が折り曲げられている ('bent over')場合)
があります:

                                                                   C----B
              元の 4 角形:     A--B      表示される 4 角形:        |\   |
           ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                               |/ |                                |  \ |
                               C--D                                |   \|
                                                                   A    D


曲面の格子の対角辺が <bitpattern> の 2 bit によって見えるようにはなって
はいない場合、上の対角辺 CB はどこにも書かれないことになり、それが結果
の表示を理解しにくいものにします。デフォルトで定義される `bentover`オプ
ションは、このような場合それを表示するようにします。もしそうしたくない
なら、`nobentover` を選択してください。以下も参照隠線処理のデモ
(hidden.dem) (http://www.gnuplot.info/demo/hidden.html)および複雑な隠線
のデモ (singulr.dem). (http://www.gnuplot.info/demo/singulr.html)



File: gnuplot.info, Node: historysize, Next: isosamples, Prev: hidden3d, Up: set-show

historysize
-----------




注意: コマンド *Note historysize:: は、gnuplot が GNU readline ライブラ
リを使うように configure された場合のみ有効です。

書式:
           set historysize <int>
           unset historysize


historysize の値は、gnuplot の終了時に history の行を高々その行数までに
切り捨てるために使われます。デフォルトは 500 です。*Note historysize::
は history の切捨てを無効にしますので、history ファイルに書き出す行数の
制限をしません。



File: gnuplot.info, Node: isosamples, Next: key, Prev: historysize, Up: set-show

isosamples
----------



関数を面として描画する場合の孤立線 (格子) の密度はコマンド *Note
isosamples::で変更できます。

書式:
           set isosamples <iso_1> {,<iso_2>}
           show isosamples


各曲面グラフは <iso_1> 個の u-孤立線と <iso_2> 個の v-孤立線を持ちます。
<iso_1> のみ指定すれば、<iso_2> は <iso_1> と同じ値に設定されます。デフォ
ルトでは、u, v それぞれ 10 本の標本化が行われます。標本数をもっと多くす
ればより正確なグラフが作られますが、時間がかかります。これらのパラメー
タは、データファイルの描画には何も影響を与えません。

孤立線とは、曲面の一つの媒介変数を固定して、もう一つの媒介変数によって
描かれる曲線のことです。孤立線は、曲面を表示する単純な方法を与えます。
曲面 s(u,v) の媒介変数 u を固定することで u-孤立線 c(v) = s(u0,v) が作
られ、媒介変数 v を固定することで v-孤立線 c(u) = s(u,v0) ができます。

関数の曲面グラフが隠線処理なしで描かれている場合、*Note samples:: は各
孤立線上で標本化される点の数を制御します。以下参照: *Note samples::,
*Note hidden3d::。等高線描画ルーチンは、関数の点の標本化は各孤立線の交
点で行われると仮定しているので、関数の曲面と等高線の解像度を変更すると
きは、*Note isosamples:: と同じように *Note samples:: を変更するのが望
ましいでしょう。



File: gnuplot.info, Node: key, Next: ラベル_(label), Prev: isosamples, Up: set-show

key
---





コマンド `set key` は描画された曲線の説明や表題を表示することを可能にし
ます。

説明 (key) の内容、すなわち描画される個々のデータ集合や関数につける名
前、およびそれらグラフの曲線とグラフ上の点を表す記号からなるサンプルは、
*Note plot:: (または `splot`) コマンドの *Note title::, *Note with:: オプションにより決
定されます。より詳しい情報については、以下参照: *Note title::,
*Note with::。

書式:
           set key {on|off} {default}
                   {{inside | outside} | {lmargin | rmargin | tmargin | bmargin}
                     | {at <position>}}
                   {left | right | center} {top | bottom | center}
                   {vertical | horizontal} {Left | Right}
                   {{no}opaque}
                   {{no}reverse} {{no}invert}
                   {samplen <sample_length>} {spacing <vertical_spacing>}
                   {width <width_increment>}
                   {height <height_increment>}
                   {{no}autotitles {columnheader}}
                   {title "<text>"} {{no}enhanced}
                   {font "<face>,<size>"} {textcolor <colorspec>}
                   {{no}box { {linestyle | ls <line_style>}
                              | {linetype | lt <line_type>}
                                {linewidth | lw <line_width>}}}
                   {maxcols {<max no. of columns> | auto}}
                   {maxrows {<max no. of rows> | auto}}
           unset key
           show key


キー (説明) は、グラフ内の各描画に対するタイトルとサンプル (凡例; 線、
点、箱) から成ります。キーの機能は、`set key off` または `unset key`で
無効にできます。個々のキーのエントリは、対応する plot コマンド内にキー
ワード `notitle` を使うことで無効にできます。

キー内の各要素は `vertical` (縦) または `horizontal` (横) に従って重ね
られます。`vertical` の場合、key は可能ならば 2,3 個の縦の列を使います。
すなわち、各要素は垂直スペースがなくなるまでは 1 つの列に整列されますが、
そこから新しい列が開始されます。垂直スペースは、`maxrows` を使って制限
できます。`horizontal` の場合は、key は横の行をできるだけ少なく使おうと
します。水平方向のスペースは `maxcols` により制限できます。

デフォルトでは、key はグラフ領域の内側の右上の角に置かれます。キーワー
ド `left`, `right`, `top`, `bottom`, `center`, `inside`, `outside`,
*Note lmargin::, *Note rmargin::, *Note tmargin::, *Note bmargin:: (,
`above`, `over`, `below`, `under`) は、グラフ領域の他の場所への自動的な
配置のために使用します。key の描画をどこに置くかをより詳しく指示するた
めの `at <position>` もあります。この場合、キーワード `left`, `right`,
`top`, `bottom`, `center` が同様の基準点合わせの設定の目的で使われます。
より詳しくは、以下参照: `key placement`。

グラフのタイトルの行揃えは `Left`, `Right` (デフォルト) で指示します。
ラベル文字列と曲線のサンプルは左右入れ替えることができます(`reverse`)
し、 全体を枠で囲むこともできます (`box {...}`)。その枠の線は、線種
(`linetype`), 線幅 (`linewidth`)、あるいは定義済のラインスタイル
(`linestyle`) を指定することもできます。

デフォルトでは、key は一つのグラフと同時に作られます。すなわち、key の
記号とタイトルは、それに対応するグラフと同時に描かれます。それは、新し
いグラフが時には key の上に要素をかぶせて配置しうることを意味します。
`set key opaque` は、key をすべてのグラフの描画が終った後に生成させます。
この場合、key の領域は背景色で塗りつぶされて key の記号とタイトルが描か
れます。よって、key 自身はいくつかの描画要素を覆い隠してしまい得ること
になります。`set key noopaque` でデフォルトに復帰できます。

デフォルトでは、最初の描画のラベルが説明の一番上に現われ、それに続くラ
ベルがその下に並んで行きます。オプション `invert` は、最初のラベルを説
明の一番下に置き、それに続くラベルをその上に並べて行きます。このオプショ
ンは、説明のラベルの縦の並びの順番を、積み上げ形式のヒストグラム(*Note
histograms::) の箱の順番に合わせるときに便利でしょう。

<height_increment> は、説明の箱の高さに加えたり減らしたりする高さ (何文
字分か) を表す数値です。これは主に、説明の回りに箱を描く場合で、説明の
並びの回りの境界線をより大きくしたい場合のものです。

*Note plot:: や `splot` で描画される全ての曲線は、デフォルトのオプショ
ン`autotitles` に従って表題 (title) がつけられます。表題の自動生成は、
`noautotaitle` で抑制できますがその場合、`(s)plot ... title ...` で明示
的に指定された表題のみが描かれることになります。


コマンド `set key autotitle columnheader` は、各入力データの先頭行の各
列のエントリをテキスト文字列と解釈し、対応する描画グラフのタイトルとし
て使用します。描画される量が、複数の列データの関数である場合は、
gnuplot はどの列をタイトルの描画に使えばいいのかわかりませんので、その
ような場合、plot コマンド上で、例えば以下のように明示的にタイトルの列を
指定する必要があります。

           plot "datafile" using (($2+$3)/$4) title columnhead(3) with lines


全体に渡る表題は説明の上につけることもできます (`title "<text>"`)。単一
引用符 (') と二重引用符 (") の違いについては、以下も参照: `syntax`。説
明の表題の行揃えは、グラフの表題の行揃えと同じものが使われます。

`set key` のデフォルトは、`on`, `right`, `top`, `vertical`, `Right`,
`noreverse`, `noinvert`, `samplen 4`, `spacing 1.25`, `title ""`,
`nobox` です。説明の枠の線種はデフォルトではグラフ描画の外枠と同じもの
が使われます。`set key default` とするとデフォルトの設定に戻ります。

説明は、1 行に 1 曲線分ずつの数行のまとまりとして書かれます。各行の右側
には (`reverse` を使っていれば左側には) その曲線と同じ種類の直線のサン
プルが引かれ、他の側には *Note plot:: コマンドから得られる文字列
(title)が置かれます。これらの行は、架空の直線が説明の左側と右側を分ける
かのように垂直に整列されます。コマンド `set key` で指定する座標はこの架
空の線分の上の端の座標です。*Note plot:: では直線の位置を指定するために
x と yだけが使われ、`splot` では、x, y, z の値全てを使い、グラフを 2 次
元面へ投影するのと同じ方法を使って、架空の直線の 2 次元画面での位置を生
成します。

TeX や、整形情報が文字列に埋め込まれる出力を使う場合は、`gnuplot` は説
明の位置合わせのための文字列の幅を正しく評価することしかできません。よっ
て説明を左に置く場合は `set key left Left reverse` という組合せを使うの
がいいでしょう。

`splot` で等高線を書く場合、説明には等高線のラベルも表示されます。
これらのラベルの並び具合がうまくいかない、または別な位置に小数点を
置きたい場合はそのラベルの書式を指定できます。詳細は、以下参照:
*Note clabel::。

例:

以下はデフォルトの位置に説明を表示します:
           set key default


以下は説明を表示しなくします:
           unset key


以下はデフォルトの (第一の) 座標系での (2,3.5,2) の位置に説明を表示しま
す:
           set key at 2,3.5,2


以下は説明をグラフの下に表示します:
           set key below


以下は説明を左下角に表示し、テキストは左に行揃えで、タイトルをつけ、線
種 3 の外枠を書きます:
           set key left bottom Left title 'Legend' box 3


* Menu:

* キーの配置_(key_placement)::
* キーの凡例_(key_samples)::



File: gnuplot.info, Node: キーの配置_(key_placement), Next: キーの凡例_(key_samples), Prev: key, Up: key

キーの配置 (key placement)
..........................

配置の仕組みを理解ための最も重要な概念は、グラフ領域、すなわち内か外か
ということと、グラフ領域の境界との間の余白 (margin) を考えることです。
グラフ領域に沿って、キーワード `left/center/right` (l/c/r) と
`top/center/bottom` (t/c/b) は、key をその領域の内側のどこに置くかを制
御します。

モード `inside` では、key はキーワード `left` (l), `right` (r), `top`
(t), `bottom` (b), `center` (c) によって以下の図のように描画領域の境界
に向かって出力されます:

          t/l   t/c   t/r


          c/l    c    c/r


          b/l   b/c   b/r



モード `outside` でも上と同様に自動的に配置されますが、グラフ領域の境界
に対して、というよりもむしろ見た目に対して、というべきでしょう。すなわ
ち、グラフの境界は、グラフ領域の外の key の場所を作るために、内側に移動
することになります。しかし、これは他のラベルの邪魔をしますし、もしかし
たら出力デバイスによってはエラーを引き起こすかもしれません。key の出力
に合わせてどの描画境界が移動するかは、上に述べた key の位置、および重ね
上げの方向に依存します。4 方向の中心揃えのオプション (`center`)に関して
は、どの境界が動くのかに関するあいまいさはありませんが、角への出力のオ
プションについては、重ね上げ方向が `vertical` の場合は左または右の境界
が、`horizontal` の場合は上または下の境界が、それぞれ内側に適切に移動し
ます。

余白 (margin) の書き方は、重ね上げの方向にかかわない自動的な配置を可能
にしています。*Note lmargin:: (lm), *Note rmargin:: (rm), *Note
tmargin:: (tm), *Note bmargin:: (bm) のうちの一つを、矛盾しない 1 方向
のキーワードと組み合わせて使用した場合、以下の図に示した場所に key が配
置されます:

               l/tm  c/tm  r/tm


          t/lm                  t/rm


          c/lm                  c/rm


          b/lm                  b/rm


               l/bm  c/bm  r/bm



キーワード `above` と `over` は *Note tmargin:: と同じ意味です。以前の
バージョンとの互換性のために、`above` と `over` は l/c/r や重ね上げ方向
のキーワードなしで使用すると、`center` で `horizontal` を使います。キー
ワード `below` と `under` は *Note bmargin:: と同じ意味です。互換性のた
めに、`below` と `under` は l/c/r や重ね上げ方向のキーワードなしで使用
すると`center` で `horizontal` を使います。さらに、`outside` も互換性の
ために t/b/c や重ね上げ方向のキーワードがなければ、`top`, `right`,
`vertical` (つまり上の t/rm と同じ) を使用します。

説明の位置 (<position>) は、以前のバージョンと同様単に x,y,z を指定して
もいいですが、その最初のサンプル行の座標の座表系を選択するための 5つの
キーワード (`first`, `second`, `graph`, `screen`, `character`) を頭につ
けることもできます。詳細は、以下参照: `coordinates`。<position>が与えら
れた場合の `left`, `right`, `top`, `bottom`, `center` の効果は、label
コマンドで配置される文字列の場合と同じように基準位置の位置合わせに使用
されます。すなわち、`left` は key が <position> の右に置かれて左合わせ
で出力されます。他の場合も同様です。



File: gnuplot.info, Node: キーの凡例_(key_samples), Prev: キーの配置_(key_placement), Up: key

キーの凡例 (key samples)
........................

デフォルトでは、グラフ上の各描画はキー内にそれぞれに対応するエントリを
生成します。このエントリには、描画タイトルと、その描画で使われるのと同
じ色、同じ塗りつぶし属性による線/点/箱 のサンプルが入ります。font と
textcolor 属性は、キー内に現われる個々の描画タイトルの見た目を制御しま
す。textcolor を "variable" にセットすると、キーの各エントリの文字列は、
描画グラフの線や塗りつぶし色と同じ色になります。これは、以前のある時期
の gnuplot のデフォルトの挙動でした。

グラフ曲線のサンプルの線分の長さは `samplen` で指定できます。その長さは
目盛りの長さと、<sample_length>*(文字幅) の和として計算されます。
`sapmlen` は、グラフ上の点のサンプルの位置にも (もしサンプル線分自身が
書かれなくても) 影響を与えています。それは、点の記号はサンプル線分の中
央に書かれるためです。

行間の垂直スペースは、`spacing` で指定できます。その幅は、点のサイズ
(pointsize) と垂直な目盛りのサイズと <vertical_spacing> の積になります。
この垂直スペースは、文字の高さよりも小さくはならないことが保証されてい
ます。

<width_increment> は、文字列の長さに加えたり減らしたりする幅 (何文字分
か) を表す数値です。これは、説明に外枠を書き、文字列に制御文字を使う場
合にだけ有用でしょう。`gnuplot` は外枠の幅を計算するときは、ラベル文字
列の文字数を単純に数えるだけなので、それを修正するのに使えます。



File: gnuplot.info, Node: ラベル_(label), Next: 線種_(linetype), Prev: key, Up: set-show

ラベル (label)
--------------



`set label` コマンドを使うことによって任意の見出し (label) をグラフ中に
表示することができます。

書式:
           set label {<tag>} {"<label text>"} {at <position>}
                     {left | center | right}
                     {norotate | rotate {by <degrees>}}
                     {font "<name>{,<size>}"}
                     {noenhanced}
                     {front | back}
                     {textcolor <colorspec>}
                     {point <pointstyle> | nopoint}
                     {offset <offset>}
           unset label {<tag>}
           show label


位置 (<position>) は x,y か x,y,z のどちらかで指定し、座標系を選択する
にはその座標の前に `first`, `second`, `graph`, `screen`, `character`を
つけます。詳細は、以下参照: `coordinates`。

タグ (<tag>) は見出しを識別するための整数値です。タグを指定しなかった場
合未使用のもので最も小さい値が自動的に割り当てられます。現在の見出しを
変更するときはそのタグと変更したい項目を指定して `set label` コマンドを
使います。

<label text> は文字列定数でも構いませんし、文字列変数、または文字列の値
を持つ式でも構いません。以下参照: `strings`, *Note sprintf::, *Note
gprintf::。

デフォルトでは、指定した点 x,y,z に見出しの文章の左端が来るように配置さ
れます。x,y,z を見出しのどこに揃えるかを変更するには変数
<justification> を指定します。これには、`left`, `right`, `center` のい
ずれかが指定でき、それぞれ文章の左、右、真中が指定した点に来るように配
置さるようになります。描画範囲の外にはみ出るような指定も許されますが、
座標軸の見出しや他の文字列と重なる場合があります。

`rotate` を指定するとラベルは縦書きになります (もちろん出力ドライバが対
応していれば、ですが)。`rotate by <degrees>` が与えられた場合は、それに
適合している出力ドライバは指定された角度で文字列を書こうとしますがそう
でない出力形式では、垂直な文字列として扱われます。

フォントとそのサイズは、出力形式がフォントの設定をサポートしていれば
`font "<name>{,<size>}"` で明示的に選択できます。そうでない出力形式では、
デフォルトのフォントが使われます。

通常は、現在の出力形式がサポートしていれば、ラベル文字列の全ての文字列
に拡張文字列処理モード (enhanced text mode) が使用されます。
`noenhanced` を使用することで、特定のラベルを拡張文字列処理から外すこと
ができます。これは、ラベルが例えばアンダースコア (_) を含んでいる場合な
どに有用です。以下参照: `enhanced text`。

`front` が与えられると、見出しはデータのグラフの上に書かれます。
`back`が与えられると (デフォルト)、見出しはグラフの下に書かれます。
`front`を使うことで、密なデータによって見出しが隠されてしまうことを避け
ることが出来ます。

`textcolor <colorspec>` は見出し文字列の色を変更します。<colorspec> は
線種、rgb 色、またはパレットへの割当のいずれかが指定できます。以下参照:
`colorspec`, *Note palette::。`textcolor` は、`tc` と省略可能です。
        `tc default` は、文字色をデフォルトにします。
        `tc lt <n>` は、文字色を線種 <n> (line type)と同じものにします。
        `tc ls <n>` は、文字色を line style <n> と同じものにします。
        `tc palette z` は、見出しの z の位置に対応したパレット色になります。
        `tc palette cb <val>` は、色見本 (colorbar) の <val> の色になります。
        `tc palette fraction <val>` (0<=val<=1) は、[0:1] から *Note palette:: の
            灰色階調/カラーへの写像に対応した色になります。
        `tc rgb "#RRGGBB"` は、任意の 24-bit RGB 色を選択します。


<pointstyle> がキーワード `lt`, `pt`, `ps` とともに与えられると (以下参
照: *Note style::)、与えられたスタイルと、与えられた線種の色で見出し位
置に点 (point) が描画され、見出し文字列は少し移動されます。このオプショ
ンは `mouse` 拡張された出力形式でのラベルの配置に、デフォルトで使用され
ています。見出し文字列近くの点の描画機能を off (これがデフォルト) にす
るには、`nopoint` を使用してください。

その移動は、デフォルトでは、<pointstyle> が与えられれば *Note
pointsize:: の単位で 1,1 で、<pointstyle> が与えられていなければ 0,0 で
す。移動は、追加の `offset <offset>` でも制御できます。ここで、
<offset> は x,y かまたは x,y,z の形式ですが、それに座標系を選択して、そ
の前に `first`, `second`, `graph`, `screen`, `character` のいずれかをつ
けることもできます。詳細は、以下参照: `coordinates`。

もし一つ (あるいはそれ以上の) 軸が時間軸である場合、座標は *Note
timefmt::の書式にしたがって引用符で囲まれた文字列で与える必要があります。
以下参照: *Note xdata::, *Note timefmt::。

EEPIC, Imagen, LaTeX, TPIC で出力する場合は、\\ を使うことで見出しを改
行させることができます。

ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
照: *Note labels::)。

例:

(1,2) の位置に "y=x" と書く場合:
           set label "y=x" at 1,2


Symbol フォントのサイズ 24 の "シグマ" (Σ) をグラフの真中に書く場合:
           set label "S" at graph 0.5,0.5 center font "Symbol,24"


見出し "y=x^2" の右端が (2,3,4) に来るようにし、タグ番号として 3 を使う
場合:
           set label 3 "y=x^2" at 2,3,4 right


その見出しを中央揃えにする場合:
           set label 3 center


タグ番号 2 の見出しを削除する場合:
           unset label 2


全ての見出しを削除する場合:
           unset label


全ての見出しをタグ番号順に表示する場合:
           show label


x 軸が時間軸であるグラフに見出しを設定する例:
           set timefmt "%d/%m/%y,%H:%M"
           set label "Harvest" at "25/8/93",1


データと、新たに当てはめられたパラメータによる当てはめ関数を描画したい
場合、`fit` の後でかつ *Note plot:: の前に以下を実行します:
           set label sprintf("a = %3.5g",par_a) at 30,15
           bfit = gprintf("b = %s*10^%S",par_b)
           set label bfit at 30,20


当てはめられるパラメータのついた関数の定義式を表示したい場合:
           f(x)=a+b*x
           fit f(x) 'datafile' via a,b
           set label GPFUN_f at graph .05,.95
           set label sprintf("a = %g", a) at graph .05,.90
           set label sprintf("b = %g", b) at graph .05,.85


見出し文字列を小さい点から少しだけ移動する場合:
           set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1


pm3d を使った 3 次元のカラー曲面上のある点の位置に、その z の値 (この場
合 5.5) に対応した色を見出し文字列につける場合:
           set label 'text' at 0,0,5.5 tc palette z




File: gnuplot.info, Node: 線種_(linetype), Next: lmargin, Prev: ラベル_(label), Up: set-show

線種 (linetype)
---------------


コマンド `set linetype` は各種描画に使用される基本的な線種 (linetype)を
再定義することを可能にします。このコマンドのオプションは、"set style
line" のものと全く同じです。ラインスタイルと違うところは、`set
linetype` による再定義は永続的なことで、これは *Note reset:: の影響を受
けません。

例えば、線種の 1 と 2 はデフォルトでは赤と緑です。それを以下のように再
定義します:

           set linetype 1 lw 2 lc rgb "blue" pointtype 6
           set linetype 2 lw 2 lc rgb "forest-green" pointtype 8


すると lt 1 を使用しているすべてのものが、細い赤線 (lt 1 の以前のデフォ
ルト) か太い青線になります。この性質は、lt 1 に基づいて作られた一時的な
ラインスタイルの定義のようなものも含んでいます。

`注意`: このコマンドは gnuplot バージョン 4.6 で新たに導入されたもので、
バージョン 4.2 のあいまいなコマンド "set style increment user" に置き換
わるものです。古いコマンドは現在は非推奨です。

この仕組みは、gnuplot で使用する線種列に対する個人的な好みを設定するの
にも使えます。それを行うには、実行時初期化ファイル ~/.gnuplot に、例え
ば以下のようなそれ用のコマンド列を追加することをお勧めします:

           if ((GPVAL_VERSION < 4.5) \
           ||  (!strstrt(GPVAL_COMPILE_OPTIONS,"+USER_LINETYPES"))) \
               exit
           set linetype 1 lc rgb "dark-violet" lw 2 pt 0
           set linetype 2 lc rgb "sea-green"   lw 2 pt 7
           set linetype 3 lc rgb "cyan"        lw 2 pt 6 pi -1
           set linetype 4 lc rgb "dark-red"    lw 2 pt 5 pi -1
           set linetype 5 lc rgb "blue"        lw 2 pt 8
           set linetype 6 lc rgb "dark-orange" lw 2 pt 3
           set linetype 7 lc rgb "black"       lw 2 pt 11
           set linetype 8 lc rgb "goldenrod"   lw 2
           set linetype cycle 8


こうすると、あなたが gnuplot を実行する度に線種はこれらの値に初期化され
ます。線種はあなたが好む数だけ初期化できます。再定義しない場合は、それ
はデフォルトの属性を持ち続けます。例えば線種 3 を再定義から外せば、それ
は青で pt 3, lw 1 となります。なお、サンプルスクリプトの最初の 2,3の行
は、古いバージョンの gnuplot ではスキップさせるための保険です。

同様のスクリプトファイルで、テーマベースの色選択の定義を行ったり、特定
の描画タイプ、あるいは特定の出力形式用に色をカスタマイズしたりすること
も可能です。


コマンド `set linetype cycle 8` は、大きな番号の線種に対しては色や線幅
に関するこれらの定義を再利用することを gnuplot に伝えます。すなわち、線
種 (linetype) 9-16, 17-24 等に対しては、これと同じ色、幅の列を使用しま
す。ただし、点の属性 (pointtype, pointsize, pointinterval) は、このコマ
ンドの影響は受けません。`unset linetype cycle` はこの機能を無効にします。
大きな線種番号の線の属性を明示的に定義した場合は、それは小さい番号の線
種の属性の再利用よりも優先されます。




